{"ast":null,"code":"import { toJSONSchema } from \"zod/v4/core\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport { dereference } from \"@cfworker/json-schema\";\nimport { isZodSchemaV3, isZodSchemaV4, interopZodObjectStrict, isZodObjectV4, interopZodTransformInputSchema } from \"./types/zod.js\";\nexport { deepCompareStrict, Validator } from \"@cfworker/json-schema\";\n/**\n * Converts a Zod schema or JSON schema to a JSON schema.\n * @param schema - The schema to convert.\n * @returns The converted schema.\n */\nexport function toJsonSchema(schema) {\n  if (isZodSchemaV4(schema)) {\n    const inputSchema = interopZodTransformInputSchema(schema, true);\n    if (isZodObjectV4(inputSchema)) {\n      const strictSchema = interopZodObjectStrict(inputSchema, true);\n      return toJSONSchema(strictSchema);\n    } else {\n      return toJSONSchema(schema);\n    }\n  }\n  if (isZodSchemaV3(schema)) {\n    return zodToJsonSchema(schema);\n  }\n  return schema;\n}\n/**\n * Validates if a JSON schema validates only strings. May return false negatives in some edge cases\n * (like recursive or unresolvable refs).\n *\n * @param schema - The schema to validate.\n * @returns `true` if the schema validates only strings, `false` otherwise.\n */\nexport function validatesOnlyStrings(schema) {\n  // Null, undefined, or empty schema\n  if (!schema || typeof schema !== \"object\" || Object.keys(schema).length === 0 || Array.isArray(schema)) {\n    return false; // Validates anything, not just strings\n  }\n  // Explicit type constraint\n  if (\"type\" in schema) {\n    if (typeof schema.type === \"string\") {\n      return schema.type === \"string\";\n    }\n    if (Array.isArray(schema.type)) {\n      // not sure why someone would do `\"type\": [\"string\"]` or especially `\"type\": [\"string\",\n      // \"string\", \"string\", ...]` but we're not here to judge\n      return schema.type.every(t => t === \"string\");\n    }\n    return false; // Invalid or non-string type\n  }\n  // Enum with only string values\n  if (\"enum\" in schema) {\n    return Array.isArray(schema.enum) && schema.enum.length > 0 && schema.enum.every(val => typeof val === \"string\");\n  }\n  // String constant\n  if (\"const\" in schema) {\n    return typeof schema.const === \"string\";\n  }\n  // Schema combinations\n  if (\"allOf\" in schema && Array.isArray(schema.allOf)) {\n    // If any subschema validates only strings, then the overall schema validates only strings\n    return schema.allOf.some(subschema => validatesOnlyStrings(subschema));\n  }\n  if (\"anyOf\" in schema && Array.isArray(schema.anyOf) || \"oneOf\" in schema && Array.isArray(schema.oneOf)) {\n    const subschemas = \"anyOf\" in schema ? schema.anyOf : schema.oneOf;\n    // All subschemas must validate only strings\n    return subschemas.length > 0 && subschemas.every(subschema => validatesOnlyStrings(subschema));\n  }\n  // We're not going to try on this one, it's too complex - we just assume if it has a \"not\" key and hasn't matched one of the above checks, it's not a string schema.\n  if (\"not\" in schema) {\n    return false; // The not case can validate non-strings\n  }\n  if (\"$ref\" in schema && typeof schema.$ref === \"string\") {\n    const ref = schema.$ref;\n    const resolved = dereference(schema);\n    if (resolved[ref]) {\n      return validatesOnlyStrings(resolved[ref]);\n    }\n    return false;\n  }\n  // ignore recursive refs and other cases where type is omitted for now\n  // ignore other cases for now where type is omitted\n  return false;\n}","map":{"version":3,"names":["toJSONSchema","zodToJsonSchema","dereference","isZodSchemaV3","isZodSchemaV4","interopZodObjectStrict","isZodObjectV4","interopZodTransformInputSchema","deepCompareStrict","Validator","toJsonSchema","schema","inputSchema","strictSchema","validatesOnlyStrings","Object","keys","length","Array","isArray","type","every","t","enum","val","const","allOf","some","subschema","anyOf","oneOf","subschemas","$ref","ref","resolved"],"sources":["/Users/chetan/Desktop/summarize_agent/frontend/node_modules/@langchain/core/dist/utils/json_schema.js"],"sourcesContent":["import { toJSONSchema } from \"zod/v4/core\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport { dereference } from \"@cfworker/json-schema\";\nimport { isZodSchemaV3, isZodSchemaV4, interopZodObjectStrict, isZodObjectV4, interopZodTransformInputSchema, } from \"./types/zod.js\";\nexport { deepCompareStrict, Validator } from \"@cfworker/json-schema\";\n/**\n * Converts a Zod schema or JSON schema to a JSON schema.\n * @param schema - The schema to convert.\n * @returns The converted schema.\n */\nexport function toJsonSchema(schema) {\n    if (isZodSchemaV4(schema)) {\n        const inputSchema = interopZodTransformInputSchema(schema, true);\n        if (isZodObjectV4(inputSchema)) {\n            const strictSchema = interopZodObjectStrict(inputSchema, true);\n            return toJSONSchema(strictSchema);\n        }\n        else {\n            return toJSONSchema(schema);\n        }\n    }\n    if (isZodSchemaV3(schema)) {\n        return zodToJsonSchema(schema);\n    }\n    return schema;\n}\n/**\n * Validates if a JSON schema validates only strings. May return false negatives in some edge cases\n * (like recursive or unresolvable refs).\n *\n * @param schema - The schema to validate.\n * @returns `true` if the schema validates only strings, `false` otherwise.\n */\nexport function validatesOnlyStrings(schema) {\n    // Null, undefined, or empty schema\n    if (!schema ||\n        typeof schema !== \"object\" ||\n        Object.keys(schema).length === 0 ||\n        Array.isArray(schema)) {\n        return false; // Validates anything, not just strings\n    }\n    // Explicit type constraint\n    if (\"type\" in schema) {\n        if (typeof schema.type === \"string\") {\n            return schema.type === \"string\";\n        }\n        if (Array.isArray(schema.type)) {\n            // not sure why someone would do `\"type\": [\"string\"]` or especially `\"type\": [\"string\",\n            // \"string\", \"string\", ...]` but we're not here to judge\n            return schema.type.every((t) => t === \"string\");\n        }\n        return false; // Invalid or non-string type\n    }\n    // Enum with only string values\n    if (\"enum\" in schema) {\n        return (Array.isArray(schema.enum) &&\n            schema.enum.length > 0 &&\n            schema.enum.every((val) => typeof val === \"string\"));\n    }\n    // String constant\n    if (\"const\" in schema) {\n        return typeof schema.const === \"string\";\n    }\n    // Schema combinations\n    if (\"allOf\" in schema && Array.isArray(schema.allOf)) {\n        // If any subschema validates only strings, then the overall schema validates only strings\n        return schema.allOf.some((subschema) => validatesOnlyStrings(subschema));\n    }\n    if ((\"anyOf\" in schema && Array.isArray(schema.anyOf)) ||\n        (\"oneOf\" in schema && Array.isArray(schema.oneOf))) {\n        const subschemas = (\"anyOf\" in schema ? schema.anyOf : schema.oneOf);\n        // All subschemas must validate only strings\n        return (subschemas.length > 0 &&\n            subschemas.every((subschema) => validatesOnlyStrings(subschema)));\n    }\n    // We're not going to try on this one, it's too complex - we just assume if it has a \"not\" key and hasn't matched one of the above checks, it's not a string schema.\n    if (\"not\" in schema) {\n        return false; // The not case can validate non-strings\n    }\n    if (\"$ref\" in schema && typeof schema.$ref === \"string\") {\n        const ref = schema.$ref;\n        const resolved = dereference(schema);\n        if (resolved[ref]) {\n            return validatesOnlyStrings(resolved[ref]);\n        }\n        return false;\n    }\n    // ignore recursive refs and other cases where type is omitted for now\n    // ignore other cases for now where type is omitted\n    return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}