{"ast":null,"code":"import { parse, parseAsync, globalRegistry, util, clone, _unknown, _never, $ZodUnknown, $ZodNever, $ZodOptional } from \"zod/v4/core\";\nexport function isZodSchemaV4(schema) {\n  if (typeof schema !== \"object\" || schema === null) {\n    return false;\n  }\n  const obj = schema;\n  if (!(\"_zod\" in obj)) {\n    return false;\n  }\n  const zod = obj._zod;\n  return typeof zod === \"object\" && zod !== null && \"def\" in zod;\n}\nexport function isZodSchemaV3(schema) {\n  if (typeof schema !== \"object\" || schema === null) {\n    return false;\n  }\n  const obj = schema;\n  if (!(\"_def\" in obj) || \"_zod\" in obj) {\n    return false;\n  }\n  const def = obj._def;\n  return typeof def === \"object\" && def != null && \"typeName\" in def;\n}\n/** Backward compatible isZodSchema for Zod 3 */\nexport function isZodSchema(schema) {\n  if (isZodSchemaV4(schema)) {\n    console.warn(\"[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior.\");\n  }\n  return isZodSchemaV3(schema);\n}\n/**\n * Given either a Zod schema, or plain object, determine if the input is a Zod schema.\n *\n * @param {unknown} input\n * @returns {boolean} Whether or not the provided input is a Zod schema.\n */\nexport function isInteropZodSchema(input) {\n  if (!input) {\n    return false;\n  }\n  if (typeof input !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(input)) {\n    return false;\n  }\n  if (isZodSchemaV4(input) || isZodSchemaV3(input)) {\n    return true;\n  }\n  return false;\n}\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns a safe parse result.\n * This function handles both Zod v3 and v4 schemas, returning a result object indicating success or failure.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<InteropZodSafeParseResult<T>>} A promise that resolves to a safe parse result object.\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nexport async function interopSafeParseAsync(schema, input) {\n  if (isZodSchemaV4(schema)) {\n    try {\n      const data = await parseAsync(schema, input);\n      return {\n        success: true,\n        data\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error\n      };\n    }\n  }\n  if (isZodSchemaV3(schema)) {\n    return schema.safeParse(input);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<T>} A promise that resolves to the parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nexport async function interopParseAsync(schema, input) {\n  if (isZodSchemaV4(schema)) {\n    return parse(schema, input);\n  }\n  if (isZodSchemaV3(schema)) {\n    return schema.parse(input);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Safely parses the input using the provided Zod schema (v3 or v4) and returns a result object\n * indicating success or failure. This function is compatible with both Zod v3 and v4 schemas.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {InteropZodSafeParseResult<T>} An object with either the parsed data (on success)\n *   or the error (on failure).\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nexport function interopSafeParse(schema, input) {\n  if (isZodSchemaV4(schema)) {\n    try {\n      const data = parse(schema, input);\n      return {\n        success: true,\n        data\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error\n      };\n    }\n  }\n  if (isZodSchemaV3(schema)) {\n    return schema.safeParse(input);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {T} The parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nexport function interopParse(schema, input) {\n  if (isZodSchemaV4(schema)) {\n    return parse(schema, input);\n  }\n  if (isZodSchemaV3(schema)) {\n    return schema.parse(input);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Retrieves the description from a schema definition (v3, v4, or plain object), if available.\n *\n * @param {unknown} schema - The schema to extract the description from.\n * @returns {string | undefined} The description of the schema, or undefined if not present.\n */\nexport function getSchemaDescription(schema) {\n  if (isZodSchemaV4(schema)) {\n    return globalRegistry.get(schema)?.description;\n  }\n  if (isZodSchemaV3(schema)) {\n    return schema.description;\n  }\n  if (\"description\" in schema && typeof schema.description === \"string\") {\n    return schema.description;\n  }\n  return undefined;\n}\n/**\n * Determines if the provided Zod schema is \"shapeless\".\n * A shapeless schema is one that does not define any object shape,\n * such as ZodString, ZodNumber, ZodBoolean, ZodAny, etc.\n * For ZodObject, it must have no shape keys to be considered shapeless.\n * ZodRecord schemas are considered shapeless since they define dynamic\n * key-value mappings without fixed keys.\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is shapeless, false otherwise.\n */\nexport function isShapelessZodSchema(schema) {\n  if (!isInteropZodSchema(schema)) {\n    return false;\n  }\n  // Check for v3 schemas\n  if (isZodSchemaV3(schema)) {\n    // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n    const def = schema._def;\n    // ZodObject is only shaped if it has actual shape keys\n    if (def.typeName === \"ZodObject\") {\n      const obj = schema;\n      return !obj.shape || Object.keys(obj.shape).length === 0;\n    }\n    // ZodRecord is shapeless (dynamic key-value mapping)\n    if (def.typeName === \"ZodRecord\") {\n      return true;\n    }\n  }\n  // Check for v4 schemas\n  if (isZodSchemaV4(schema)) {\n    const def = schema._zod.def;\n    // Object type is only shaped if it has actual shape keys\n    if (def.type === \"object\") {\n      const obj = schema;\n      return !obj.shape || Object.keys(obj.shape).length === 0;\n    }\n    // Record type is shapeless (dynamic key-value mapping)\n    if (def.type === \"record\") {\n      return true;\n    }\n  }\n  // For other schemas, check if they have a `shape` property\n  // If they don't have shape, they're likely shapeless\n  if (typeof schema === \"object\" && schema !== null && !(\"shape\" in schema)) {\n    return true;\n  }\n  return false;\n}\n/**\n * Determines if the provided Zod schema should be treated as a simple string schema\n * that maps to DynamicTool. This aligns with the type-level constraint of\n * InteropZodType<string | undefined> which only matches basic string schemas.\n * If the provided schema is just z.string(), we can make the determination that\n * the tool is just a generic string tool that doesn't require any input validation.\n *\n * This function only returns true for basic ZodString schemas, including:\n * - Basic string schemas (z.string())\n * - String schemas with validations (z.string().min(1), z.string().email(), etc.)\n *\n * This function returns false for everything else, including:\n * - String schemas with defaults (z.string().default(\"value\"))\n * - Branded string schemas (z.string().brand<\"UserId\">())\n * - String schemas with catch operations (z.string().catch(\"default\"))\n * - Optional/nullable string schemas (z.string().optional())\n * - Transformed schemas (z.string().transform() or z.object().transform())\n * - Object or record schemas, even if they're empty\n * - Any other schema type\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is a basic ZodString, false otherwise.\n */\nexport function isSimpleStringZodSchema(schema) {\n  if (!isInteropZodSchema(schema)) {\n    return false;\n  }\n  // For v3 schemas\n  if (isZodSchemaV3(schema)) {\n    // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n    const def = schema._def;\n    // Only accept basic ZodString\n    return def.typeName === \"ZodString\";\n  }\n  // For v4 schemas\n  if (isZodSchemaV4(schema)) {\n    const def = schema._zod.def;\n    // Only accept basic string type\n    return def.type === \"string\";\n  }\n  return false;\n}\nexport function isZodObjectV3(obj) {\n  // Zod v3 object schemas have _def.typeName === \"ZodObject\"\n  if (typeof obj === \"object\" && obj !== null && \"_def\" in obj && typeof obj._def === \"object\" && obj._def !== null && \"typeName\" in obj._def && obj._def.typeName === \"ZodObject\") {\n    return true;\n  }\n  return false;\n}\nexport function isZodObjectV4(obj) {\n  if (!isZodSchemaV4(obj)) return false;\n  // Zod v4 object schemas have _zod.def.type === \"object\"\n  if (typeof obj === \"object\" && obj !== null && \"_zod\" in obj && typeof obj._zod === \"object\" && obj._zod !== null && \"def\" in obj._zod && typeof obj._zod.def === \"object\" && obj._zod.def !== null && \"type\" in obj._zod.def && obj._zod.def.type === \"object\") {\n    return true;\n  }\n  return false;\n}\nexport function isZodArrayV4(obj) {\n  if (!isZodSchemaV4(obj)) return false;\n  // Zod v4 array schemas have _zod.def.type === \"array\"\n  if (typeof obj === \"object\" && obj !== null && \"_zod\" in obj && typeof obj._zod === \"object\" && obj._zod !== null && \"def\" in obj._zod && typeof obj._zod.def === \"object\" && obj._zod.def !== null && \"type\" in obj._zod.def && obj._zod.def.type === \"array\") {\n    return true;\n  }\n  return false;\n}\n/**\n * Determines if the provided value is an InteropZodObject (Zod v3 or v4 object schema).\n *\n * @param obj The value to check.\n * @returns {boolean} True if the value is a Zod v3 or v4 object schema, false otherwise.\n */\nexport function isInteropZodObject(obj) {\n  if (isZodObjectV3(obj)) return true;\n  if (isZodObjectV4(obj)) return true;\n  return false;\n}\n/**\n * Retrieves the shape (fields) of a Zod object schema, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObjectShape<T>} The shape of the object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function getInteropZodObjectShape(schema) {\n  if (isZodSchemaV3(schema)) {\n    return schema.shape;\n  }\n  if (isZodSchemaV4(schema)) {\n    return schema._zod.def.shape;\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Extends a Zod object schema with additional fields, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {InteropZodObjectShape} extension - The fields to add to the schema.\n * @returns {InteropZodObject} The extended Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function extendInteropZodObject(schema, extension) {\n  if (isZodSchemaV3(schema)) {\n    return schema.extend(extension);\n  }\n  if (isZodSchemaV4(schema)) {\n    return util.extend(schema, extension);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a partial version of a Zod object schema, making all fields optional.\n * Supports both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObject} The partial Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectPartial(schema) {\n  if (isZodSchemaV3(schema)) {\n    // z3: .partial() exists and works as expected\n    return schema.partial();\n  }\n  if (isZodSchemaV4(schema)) {\n    // z4: util.partial exists and works as expected\n    return util.partial($ZodOptional, schema, undefined);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a strict version of a Zod object schema, disallowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies strictness\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply strictness recursively to nested objects/arrays.\n * @returns {InteropZodObject} The strict Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectStrict(schema, recursive = false) {\n  if (isZodSchemaV3(schema)) {\n    // TODO: v3 schemas aren't recursively handled here\n    // (currently not necessary since zodToJsonSchema handles this)\n    return schema.strict();\n  }\n  if (isZodObjectV4(schema)) {\n    const outputShape = schema._zod.def.shape;\n    if (recursive) {\n      for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n        // If the shape key is a v4 object schema, we need to make it strict\n        if (isZodObjectV4(keySchema)) {\n          const outputSchema = interopZodObjectStrict(keySchema, recursive);\n          outputShape[key] = outputSchema;\n        }\n        // If the shape key is a v4 array schema, we need to make the element\n        // schema strict if it's an object schema\n        else if (isZodArrayV4(keySchema)) {\n          let elementSchema = keySchema._zod.def.element;\n          if (isZodObjectV4(elementSchema)) {\n            elementSchema = interopZodObjectStrict(elementSchema, recursive);\n          }\n          outputShape[key] = clone(keySchema, {\n            ...keySchema._zod.def,\n            element: elementSchema\n          });\n        }\n        // Otherwise, just use the keySchema\n        else {\n          outputShape[key] = keySchema;\n        }\n        // Assign meta fields to the keySchema\n        const meta = globalRegistry.get(keySchema);\n        if (meta) globalRegistry.add(outputShape[key], meta);\n      }\n    }\n    const modifiedSchema = clone(schema, {\n      ...schema._zod.def,\n      shape: outputShape,\n      catchall: _never($ZodNever)\n    });\n    const meta = globalRegistry.get(schema);\n    if (meta) globalRegistry.add(modifiedSchema, meta);\n    return modifiedSchema;\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a passthrough version of a Zod object schema, allowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies passthrough\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply passthrough recursively to nested objects/arrays.\n * @returns {InteropZodObject} The passthrough Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectPassthrough(schema, recursive = false) {\n  if (isZodObjectV3(schema)) {\n    // TODO: v3 schemas aren't recursively handled here\n    // (currently not necessary since zodToJsonSchema handles this)\n    return schema.passthrough();\n  }\n  if (isZodObjectV4(schema)) {\n    const outputShape = schema._zod.def.shape;\n    if (recursive) {\n      for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n        // If the shape key is a v4 object schema, we need to make it passthrough\n        if (isZodObjectV4(keySchema)) {\n          const outputSchema = interopZodObjectPassthrough(keySchema, recursive);\n          outputShape[key] = outputSchema;\n        }\n        // If the shape key is a v4 array schema, we need to make the element\n        // schema passthrough if it's an object schema\n        else if (isZodArrayV4(keySchema)) {\n          let elementSchema = keySchema._zod.def.element;\n          if (isZodObjectV4(elementSchema)) {\n            elementSchema = interopZodObjectPassthrough(elementSchema, recursive);\n          }\n          outputShape[key] = clone(keySchema, {\n            ...keySchema._zod.def,\n            element: elementSchema\n          });\n        }\n        // Otherwise, just use the keySchema\n        else {\n          outputShape[key] = keySchema;\n        }\n        // Assign meta fields to the keySchema\n        const meta = globalRegistry.get(keySchema);\n        if (meta) globalRegistry.add(outputShape[key], meta);\n      }\n    }\n    const modifiedSchema = clone(schema, {\n      ...schema._zod.def,\n      shape: outputShape,\n      catchall: _unknown($ZodUnknown)\n    });\n    const meta = globalRegistry.get(schema);\n    if (meta) globalRegistry.add(modifiedSchema, meta);\n    return modifiedSchema;\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a getter function for the default value of a Zod schema, if one is defined.\n * Supports both Zod v3 and v4 schemas. If the schema has a default value,\n * the returned function will return that value when called. If no default is defined,\n * returns undefined.\n *\n * @template T - The type of the Zod schema.\n * @param {T} schema - The Zod schema instance (either v3 or v4).\n * @returns {(() => InferInteropZodOutput<T>) | undefined} A function that returns the default value, or undefined if no default is set.\n */\nexport function getInteropZodDefaultGetter(schema) {\n  if (isZodSchemaV3(schema)) {\n    try {\n      const defaultValue = schema.parse(undefined);\n      return () => defaultValue;\n    } catch {\n      return undefined;\n    }\n  }\n  if (isZodSchemaV4(schema)) {\n    try {\n      const defaultValue = parse(schema, undefined);\n      return () => defaultValue;\n    } catch {\n      return undefined;\n    }\n  }\n  return undefined;\n}\nfunction isZodTransformV3(schema) {\n  return isZodSchemaV3(schema) && \"typeName\" in schema._def && schema._def.typeName === \"ZodEffects\";\n}\nfunction isZodTransformV4(schema) {\n  return isZodSchemaV4(schema) && schema._zod.def.type === \"pipe\";\n}\n/**\n * Returns the input type of a Zod transform schema, for both v3 and v4.\n * If the schema is not a transform, returns undefined. If `recursive` is true,\n * recursively processes nested object schemas and arrays of object schemas.\n *\n * @param schema - The Zod schema instance (v3 or v4)\n * @param {boolean} [recursive=false] - Whether to recursively process nested objects/arrays.\n * @returns The input Zod schema of the transform, or undefined if not a transform\n */\nexport function interopZodTransformInputSchema(schema, recursive = false) {\n  // Zod v3: ._def.schema is the input schema for ZodEffects (transform)\n  if (isZodSchemaV3(schema)) {\n    if (isZodTransformV3(schema)) {\n      return interopZodTransformInputSchema(schema._def.schema, recursive);\n    }\n    // TODO: v3 schemas aren't recursively handled here\n    // (currently not necessary since zodToJsonSchema handles this)\n    return schema;\n  }\n  // Zod v4: _def.type is the input schema for ZodEffects (transform)\n  if (isZodSchemaV4(schema)) {\n    let outputSchema = schema;\n    if (isZodTransformV4(schema)) {\n      outputSchema = interopZodTransformInputSchema(schema._zod.def.in, recursive);\n    }\n    if (recursive) {\n      // Handle nested object schemas\n      if (isZodObjectV4(outputSchema)) {\n        const outputShape = outputSchema._zod.def.shape;\n        for (const [key, keySchema] of Object.entries(outputSchema._zod.def.shape)) {\n          outputShape[key] = interopZodTransformInputSchema(keySchema, recursive);\n        }\n        outputSchema = clone(outputSchema, {\n          ...outputSchema._zod.def,\n          shape: outputShape\n        });\n      }\n      // Handle nested array schemas\n      else if (isZodArrayV4(outputSchema)) {\n        const elementSchema = interopZodTransformInputSchema(outputSchema._zod.def.element, recursive);\n        outputSchema = clone(outputSchema, {\n          ...outputSchema._zod.def,\n          element: elementSchema\n        });\n      }\n    }\n    const meta = globalRegistry.get(schema);\n    if (meta) globalRegistry.add(outputSchema, meta);\n    return outputSchema;\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}","map":{"version":3,"names":["parse","parseAsync","globalRegistry","util","clone","_unknown","_never","$ZodUnknown","$ZodNever","$ZodOptional","isZodSchemaV4","schema","obj","zod","_zod","isZodSchemaV3","def","_def","isZodSchema","console","warn","isInteropZodSchema","input","Array","isArray","interopSafeParseAsync","data","success","error","safeParse","Error","interopParseAsync","interopSafeParse","interopParse","getSchemaDescription","get","description","undefined","isShapelessZodSchema","typeName","shape","Object","keys","length","type","isSimpleStringZodSchema","isZodObjectV3","isZodObjectV4","isZodArrayV4","isInteropZodObject","getInteropZodObjectShape","extendInteropZodObject","extension","extend","interopZodObjectPartial","partial","interopZodObjectStrict","recursive","strict","outputShape","key","keySchema","entries","outputSchema","elementSchema","element","meta","add","modifiedSchema","catchall","interopZodObjectPassthrough","passthrough","getInteropZodDefaultGetter","defaultValue","isZodTransformV3","isZodTransformV4","interopZodTransformInputSchema","in"],"sources":["/Users/chetan/Desktop/summarize_agent/frontend/node_modules/@langchain/core/dist/utils/types/zod.js"],"sourcesContent":["import { parse, parseAsync, globalRegistry, util, clone, _unknown, _never, $ZodUnknown, $ZodNever, $ZodOptional, } from \"zod/v4/core\";\nexport function isZodSchemaV4(schema) {\n    if (typeof schema !== \"object\" || schema === null) {\n        return false;\n    }\n    const obj = schema;\n    if (!(\"_zod\" in obj)) {\n        return false;\n    }\n    const zod = obj._zod;\n    return (typeof zod === \"object\" &&\n        zod !== null &&\n        \"def\" in zod);\n}\nexport function isZodSchemaV3(schema) {\n    if (typeof schema !== \"object\" || schema === null) {\n        return false;\n    }\n    const obj = schema;\n    if (!(\"_def\" in obj) || \"_zod\" in obj) {\n        return false;\n    }\n    const def = obj._def;\n    return (typeof def === \"object\" &&\n        def != null &&\n        \"typeName\" in def);\n}\n/** Backward compatible isZodSchema for Zod 3 */\nexport function isZodSchema(schema) {\n    if (isZodSchemaV4(schema)) {\n        console.warn(\"[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior.\");\n    }\n    return isZodSchemaV3(schema);\n}\n/**\n * Given either a Zod schema, or plain object, determine if the input is a Zod schema.\n *\n * @param {unknown} input\n * @returns {boolean} Whether or not the provided input is a Zod schema.\n */\nexport function isInteropZodSchema(input) {\n    if (!input) {\n        return false;\n    }\n    if (typeof input !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(input)) {\n        return false;\n    }\n    if (isZodSchemaV4(input) ||\n        isZodSchemaV3(input)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns a safe parse result.\n * This function handles both Zod v3 and v4 schemas, returning a result object indicating success or failure.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<InteropZodSafeParseResult<T>>} A promise that resolves to a safe parse result object.\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nexport async function interopSafeParseAsync(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        try {\n            const data = await parseAsync(schema, input);\n            return {\n                success: true,\n                data,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error,\n            };\n        }\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.safeParse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<T>} A promise that resolves to the parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nexport async function interopParseAsync(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        return parse(schema, input);\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.parse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Safely parses the input using the provided Zod schema (v3 or v4) and returns a result object\n * indicating success or failure. This function is compatible with both Zod v3 and v4 schemas.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {InteropZodSafeParseResult<T>} An object with either the parsed data (on success)\n *   or the error (on failure).\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nexport function interopSafeParse(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        try {\n            const data = parse(schema, input);\n            return {\n                success: true,\n                data,\n            };\n        }\n        catch (error) {\n            return {\n                success: false,\n                error: error,\n            };\n        }\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.safeParse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {T} The parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nexport function interopParse(schema, input) {\n    if (isZodSchemaV4(schema)) {\n        return parse(schema, input);\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.parse(input);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n/**\n * Retrieves the description from a schema definition (v3, v4, or plain object), if available.\n *\n * @param {unknown} schema - The schema to extract the description from.\n * @returns {string | undefined} The description of the schema, or undefined if not present.\n */\nexport function getSchemaDescription(schema) {\n    if (isZodSchemaV4(schema)) {\n        return globalRegistry.get(schema)?.description;\n    }\n    if (isZodSchemaV3(schema)) {\n        return schema.description;\n    }\n    if (\"description\" in schema && typeof schema.description === \"string\") {\n        return schema.description;\n    }\n    return undefined;\n}\n/**\n * Determines if the provided Zod schema is \"shapeless\".\n * A shapeless schema is one that does not define any object shape,\n * such as ZodString, ZodNumber, ZodBoolean, ZodAny, etc.\n * For ZodObject, it must have no shape keys to be considered shapeless.\n * ZodRecord schemas are considered shapeless since they define dynamic\n * key-value mappings without fixed keys.\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is shapeless, false otherwise.\n */\nexport function isShapelessZodSchema(schema) {\n    if (!isInteropZodSchema(schema)) {\n        return false;\n    }\n    // Check for v3 schemas\n    if (isZodSchemaV3(schema)) {\n        // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n        const def = schema._def;\n        // ZodObject is only shaped if it has actual shape keys\n        if (def.typeName === \"ZodObject\") {\n            const obj = schema;\n            return !obj.shape || Object.keys(obj.shape).length === 0;\n        }\n        // ZodRecord is shapeless (dynamic key-value mapping)\n        if (def.typeName === \"ZodRecord\") {\n            return true;\n        }\n    }\n    // Check for v4 schemas\n    if (isZodSchemaV4(schema)) {\n        const def = schema._zod.def;\n        // Object type is only shaped if it has actual shape keys\n        if (def.type === \"object\") {\n            const obj = schema;\n            return !obj.shape || Object.keys(obj.shape).length === 0;\n        }\n        // Record type is shapeless (dynamic key-value mapping)\n        if (def.type === \"record\") {\n            return true;\n        }\n    }\n    // For other schemas, check if they have a `shape` property\n    // If they don't have shape, they're likely shapeless\n    if (typeof schema === \"object\" && schema !== null && !(\"shape\" in schema)) {\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if the provided Zod schema should be treated as a simple string schema\n * that maps to DynamicTool. This aligns with the type-level constraint of\n * InteropZodType<string | undefined> which only matches basic string schemas.\n * If the provided schema is just z.string(), we can make the determination that\n * the tool is just a generic string tool that doesn't require any input validation.\n *\n * This function only returns true for basic ZodString schemas, including:\n * - Basic string schemas (z.string())\n * - String schemas with validations (z.string().min(1), z.string().email(), etc.)\n *\n * This function returns false for everything else, including:\n * - String schemas with defaults (z.string().default(\"value\"))\n * - Branded string schemas (z.string().brand<\"UserId\">())\n * - String schemas with catch operations (z.string().catch(\"default\"))\n * - Optional/nullable string schemas (z.string().optional())\n * - Transformed schemas (z.string().transform() or z.object().transform())\n * - Object or record schemas, even if they're empty\n * - Any other schema type\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is a basic ZodString, false otherwise.\n */\nexport function isSimpleStringZodSchema(schema) {\n    if (!isInteropZodSchema(schema)) {\n        return false;\n    }\n    // For v3 schemas\n    if (isZodSchemaV3(schema)) {\n        // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n        const def = schema._def;\n        // Only accept basic ZodString\n        return def.typeName === \"ZodString\";\n    }\n    // For v4 schemas\n    if (isZodSchemaV4(schema)) {\n        const def = schema._zod.def;\n        // Only accept basic string type\n        return def.type === \"string\";\n    }\n    return false;\n}\nexport function isZodObjectV3(obj) {\n    // Zod v3 object schemas have _def.typeName === \"ZodObject\"\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        \"_def\" in obj &&\n        typeof obj._def === \"object\" &&\n        obj._def !== null &&\n        \"typeName\" in obj._def &&\n        obj._def.typeName === \"ZodObject\") {\n        return true;\n    }\n    return false;\n}\nexport function isZodObjectV4(obj) {\n    if (!isZodSchemaV4(obj))\n        return false;\n    // Zod v4 object schemas have _zod.def.type === \"object\"\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        \"_zod\" in obj &&\n        typeof obj._zod === \"object\" &&\n        obj._zod !== null &&\n        \"def\" in obj._zod &&\n        typeof obj._zod.def === \"object\" &&\n        obj._zod.def !== null &&\n        \"type\" in obj._zod.def &&\n        obj._zod.def.type === \"object\") {\n        return true;\n    }\n    return false;\n}\nexport function isZodArrayV4(obj) {\n    if (!isZodSchemaV4(obj))\n        return false;\n    // Zod v4 array schemas have _zod.def.type === \"array\"\n    if (typeof obj === \"object\" &&\n        obj !== null &&\n        \"_zod\" in obj &&\n        typeof obj._zod === \"object\" &&\n        obj._zod !== null &&\n        \"def\" in obj._zod &&\n        typeof obj._zod.def === \"object\" &&\n        obj._zod.def !== null &&\n        \"type\" in obj._zod.def &&\n        obj._zod.def.type === \"array\") {\n        return true;\n    }\n    return false;\n}\n/**\n * Determines if the provided value is an InteropZodObject (Zod v3 or v4 object schema).\n *\n * @param obj The value to check.\n * @returns {boolean} True if the value is a Zod v3 or v4 object schema, false otherwise.\n */\nexport function isInteropZodObject(obj) {\n    if (isZodObjectV3(obj))\n        return true;\n    if (isZodObjectV4(obj))\n        return true;\n    return false;\n}\n/**\n * Retrieves the shape (fields) of a Zod object schema, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObjectShape<T>} The shape of the object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function getInteropZodObjectShape(schema) {\n    if (isZodSchemaV3(schema)) {\n        return schema.shape;\n    }\n    if (isZodSchemaV4(schema)) {\n        return schema._zod.def.shape;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Extends a Zod object schema with additional fields, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {InteropZodObjectShape} extension - The fields to add to the schema.\n * @returns {InteropZodObject} The extended Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function extendInteropZodObject(schema, extension) {\n    if (isZodSchemaV3(schema)) {\n        return schema.extend(extension);\n    }\n    if (isZodSchemaV4(schema)) {\n        return util.extend(schema, extension);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a partial version of a Zod object schema, making all fields optional.\n * Supports both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObject} The partial Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectPartial(schema) {\n    if (isZodSchemaV3(schema)) {\n        // z3: .partial() exists and works as expected\n        return schema.partial();\n    }\n    if (isZodSchemaV4(schema)) {\n        // z4: util.partial exists and works as expected\n        return util.partial($ZodOptional, schema, undefined);\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a strict version of a Zod object schema, disallowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies strictness\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply strictness recursively to nested objects/arrays.\n * @returns {InteropZodObject} The strict Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectStrict(schema, recursive = false) {\n    if (isZodSchemaV3(schema)) {\n        // TODO: v3 schemas aren't recursively handled here\n        // (currently not necessary since zodToJsonSchema handles this)\n        return schema.strict();\n    }\n    if (isZodObjectV4(schema)) {\n        const outputShape = schema._zod.def.shape;\n        if (recursive) {\n            for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n                // If the shape key is a v4 object schema, we need to make it strict\n                if (isZodObjectV4(keySchema)) {\n                    const outputSchema = interopZodObjectStrict(keySchema, recursive);\n                    outputShape[key] = outputSchema;\n                }\n                // If the shape key is a v4 array schema, we need to make the element\n                // schema strict if it's an object schema\n                else if (isZodArrayV4(keySchema)) {\n                    let elementSchema = keySchema._zod.def.element;\n                    if (isZodObjectV4(elementSchema)) {\n                        elementSchema = interopZodObjectStrict(elementSchema, recursive);\n                    }\n                    outputShape[key] = clone(keySchema, {\n                        ...keySchema._zod.def,\n                        element: elementSchema,\n                    });\n                }\n                // Otherwise, just use the keySchema\n                else {\n                    outputShape[key] = keySchema;\n                }\n                // Assign meta fields to the keySchema\n                const meta = globalRegistry.get(keySchema);\n                if (meta)\n                    globalRegistry.add(outputShape[key], meta);\n            }\n        }\n        const modifiedSchema = clone(schema, {\n            ...schema._zod.def,\n            shape: outputShape,\n            catchall: _never($ZodNever),\n        });\n        const meta = globalRegistry.get(schema);\n        if (meta)\n            globalRegistry.add(modifiedSchema, meta);\n        return modifiedSchema;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a passthrough version of a Zod object schema, allowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies passthrough\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply passthrough recursively to nested objects/arrays.\n * @returns {InteropZodObject} The passthrough Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectPassthrough(schema, recursive = false) {\n    if (isZodObjectV3(schema)) {\n        // TODO: v3 schemas aren't recursively handled here\n        // (currently not necessary since zodToJsonSchema handles this)\n        return schema.passthrough();\n    }\n    if (isZodObjectV4(schema)) {\n        const outputShape = schema._zod.def.shape;\n        if (recursive) {\n            for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n                // If the shape key is a v4 object schema, we need to make it passthrough\n                if (isZodObjectV4(keySchema)) {\n                    const outputSchema = interopZodObjectPassthrough(keySchema, recursive);\n                    outputShape[key] = outputSchema;\n                }\n                // If the shape key is a v4 array schema, we need to make the element\n                // schema passthrough if it's an object schema\n                else if (isZodArrayV4(keySchema)) {\n                    let elementSchema = keySchema._zod.def.element;\n                    if (isZodObjectV4(elementSchema)) {\n                        elementSchema = interopZodObjectPassthrough(elementSchema, recursive);\n                    }\n                    outputShape[key] = clone(keySchema, {\n                        ...keySchema._zod.def,\n                        element: elementSchema,\n                    });\n                }\n                // Otherwise, just use the keySchema\n                else {\n                    outputShape[key] = keySchema;\n                }\n                // Assign meta fields to the keySchema\n                const meta = globalRegistry.get(keySchema);\n                if (meta)\n                    globalRegistry.add(outputShape[key], meta);\n            }\n        }\n        const modifiedSchema = clone(schema, {\n            ...schema._zod.def,\n            shape: outputShape,\n            catchall: _unknown($ZodUnknown),\n        });\n        const meta = globalRegistry.get(schema);\n        if (meta)\n            globalRegistry.add(modifiedSchema, meta);\n        return modifiedSchema;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodObject or z4.$ZodObject\");\n}\n/**\n * Returns a getter function for the default value of a Zod schema, if one is defined.\n * Supports both Zod v3 and v4 schemas. If the schema has a default value,\n * the returned function will return that value when called. If no default is defined,\n * returns undefined.\n *\n * @template T - The type of the Zod schema.\n * @param {T} schema - The Zod schema instance (either v3 or v4).\n * @returns {(() => InferInteropZodOutput<T>) | undefined} A function that returns the default value, or undefined if no default is set.\n */\nexport function getInteropZodDefaultGetter(schema) {\n    if (isZodSchemaV3(schema)) {\n        try {\n            const defaultValue = schema.parse(undefined);\n            return () => defaultValue;\n        }\n        catch {\n            return undefined;\n        }\n    }\n    if (isZodSchemaV4(schema)) {\n        try {\n            const defaultValue = parse(schema, undefined);\n            return () => defaultValue;\n        }\n        catch {\n            return undefined;\n        }\n    }\n    return undefined;\n}\nfunction isZodTransformV3(schema) {\n    return (isZodSchemaV3(schema) &&\n        \"typeName\" in schema._def &&\n        schema._def.typeName === \"ZodEffects\");\n}\nfunction isZodTransformV4(schema) {\n    return isZodSchemaV4(schema) && schema._zod.def.type === \"pipe\";\n}\n/**\n * Returns the input type of a Zod transform schema, for both v3 and v4.\n * If the schema is not a transform, returns undefined. If `recursive` is true,\n * recursively processes nested object schemas and arrays of object schemas.\n *\n * @param schema - The Zod schema instance (v3 or v4)\n * @param {boolean} [recursive=false] - Whether to recursively process nested objects/arrays.\n * @returns The input Zod schema of the transform, or undefined if not a transform\n */\nexport function interopZodTransformInputSchema(schema, recursive = false) {\n    // Zod v3: ._def.schema is the input schema for ZodEffects (transform)\n    if (isZodSchemaV3(schema)) {\n        if (isZodTransformV3(schema)) {\n            return interopZodTransformInputSchema(schema._def.schema, recursive);\n        }\n        // TODO: v3 schemas aren't recursively handled here\n        // (currently not necessary since zodToJsonSchema handles this)\n        return schema;\n    }\n    // Zod v4: _def.type is the input schema for ZodEffects (transform)\n    if (isZodSchemaV4(schema)) {\n        let outputSchema = schema;\n        if (isZodTransformV4(schema)) {\n            outputSchema = interopZodTransformInputSchema(schema._zod.def.in, recursive);\n        }\n        if (recursive) {\n            // Handle nested object schemas\n            if (isZodObjectV4(outputSchema)) {\n                const outputShape = outputSchema._zod.def.shape;\n                for (const [key, keySchema] of Object.entries(outputSchema._zod.def.shape)) {\n                    outputShape[key] = interopZodTransformInputSchema(keySchema, recursive);\n                }\n                outputSchema = clone(outputSchema, {\n                    ...outputSchema._zod.def,\n                    shape: outputShape,\n                });\n            }\n            // Handle nested array schemas\n            else if (isZodArrayV4(outputSchema)) {\n                const elementSchema = interopZodTransformInputSchema(outputSchema._zod.def.element, recursive);\n                outputSchema = clone(outputSchema, {\n                    ...outputSchema._zod.def,\n                    element: elementSchema,\n                });\n            }\n        }\n        const meta = globalRegistry.get(schema);\n        if (meta)\n            globalRegistry.add(outputSchema, meta);\n        return outputSchema;\n    }\n    throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}