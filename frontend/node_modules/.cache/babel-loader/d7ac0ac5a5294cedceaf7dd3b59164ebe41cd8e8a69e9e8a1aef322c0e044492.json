{"ast":null,"code":"export function isDataContentBlock(content_block) {\n  return typeof content_block === \"object\" && content_block !== null && \"type\" in content_block && typeof content_block.type === \"string\" && \"source_type\" in content_block && (content_block.source_type === \"url\" || content_block.source_type === \"base64\" || content_block.source_type === \"text\" || content_block.source_type === \"id\");\n}\nexport function isURLContentBlock(content_block) {\n  return isDataContentBlock(content_block) && content_block.source_type === \"url\" && \"url\" in content_block && typeof content_block.url === \"string\";\n}\nexport function isBase64ContentBlock(content_block) {\n  return isDataContentBlock(content_block) && content_block.source_type === \"base64\" && \"data\" in content_block && typeof content_block.data === \"string\";\n}\nexport function isPlainTextContentBlock(content_block) {\n  return isDataContentBlock(content_block) && content_block.source_type === \"text\" && \"text\" in content_block && typeof content_block.text === \"string\";\n}\nexport function isIDContentBlock(content_block) {\n  return isDataContentBlock(content_block) && content_block.source_type === \"id\" && \"id\" in content_block && typeof content_block.id === \"string\";\n}\nexport function convertToOpenAIImageBlock(content_block) {\n  if (isDataContentBlock(content_block)) {\n    if (content_block.source_type === \"url\") {\n      return {\n        type: \"image_url\",\n        image_url: {\n          url: content_block.url\n        }\n      };\n    }\n    if (content_block.source_type === \"base64\") {\n      if (!content_block.mime_type) {\n        throw new Error(\"mime_type key is required for base64 data.\");\n      }\n      const mime_type = content_block.mime_type;\n      return {\n        type: \"image_url\",\n        image_url: {\n          url: `data:${mime_type};base64,${content_block.data}`\n        }\n      };\n    }\n  }\n  throw new Error(\"Unsupported source type. Only 'url' and 'base64' are supported.\");\n}\n/**\n * Utility function for ChatModelProviders. Parses a mime type into a type, subtype, and parameters.\n *\n * @param mime_type - The mime type to parse.\n * @returns An object containing the type, subtype, and parameters.\n */\nexport function parseMimeType(mime_type) {\n  const parts = mime_type.split(\";\")[0].split(\"/\");\n  if (parts.length !== 2) {\n    throw new Error(`Invalid mime type: \"${mime_type}\" - does not match type/subtype format.`);\n  }\n  const type = parts[0].trim();\n  const subtype = parts[1].trim();\n  if (type === \"\" || subtype === \"\") {\n    throw new Error(`Invalid mime type: \"${mime_type}\" - type or subtype is empty.`);\n  }\n  const parameters = {};\n  for (const parameterKvp of mime_type.split(\";\").slice(1)) {\n    const parameterParts = parameterKvp.split(\"=\");\n    if (parameterParts.length !== 2) {\n      throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n    }\n    const key = parameterParts[0].trim();\n    const value = parameterParts[1].trim();\n    if (key === \"\") {\n      throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n    }\n    parameters[key] = value;\n  }\n  return {\n    type,\n    subtype,\n    parameters\n  };\n}\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns The parsed data and mime type, or undefined if the data URL is invalid.\n */\nexport function parseBase64DataUrl({\n  dataUrl: data_url,\n  asTypedArray = false\n}) {\n  const formatMatch = data_url.match(/^data:(\\w+\\/\\w+);base64,([A-Za-z0-9+/]+=*)$/);\n  let mime_type;\n  if (formatMatch) {\n    mime_type = formatMatch[1].toLowerCase();\n    const data = asTypedArray ? Uint8Array.from(atob(formatMatch[2]), c => c.charCodeAt(0)) : formatMatch[2];\n    return {\n      mime_type,\n      data\n    };\n  }\n  return undefined;\n}\n/**\n * Convert from a standard data content block to a provider's proprietary data content block format.\n *\n * Don't override this method. Instead, override the more specific conversion methods and use this\n * method unmodified.\n *\n * @param block - The standard data content block to convert.\n * @returns The provider data content block.\n * @throws An error if the standard data content block type is not supported.\n */\nexport function convertToProviderContentBlock(block, converter) {\n  if (block.type === \"text\") {\n    if (!converter.fromStandardTextBlock) {\n      throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardTextBlock\\` method.`);\n    }\n    return converter.fromStandardTextBlock(block);\n  }\n  if (block.type === \"image\") {\n    if (!converter.fromStandardImageBlock) {\n      throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardImageBlock\\` method.`);\n    }\n    return converter.fromStandardImageBlock(block);\n  }\n  if (block.type === \"audio\") {\n    if (!converter.fromStandardAudioBlock) {\n      throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardAudioBlock\\` method.`);\n    }\n    return converter.fromStandardAudioBlock(block);\n  }\n  if (block.type === \"file\") {\n    if (!converter.fromStandardFileBlock) {\n      throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardFileBlock\\` method.`);\n    }\n    return converter.fromStandardFileBlock(block);\n  }\n  throw new Error(`Unable to convert content block type '${block.type}' to provider-specific format: not recognized.`);\n}","map":{"version":3,"names":["isDataContentBlock","content_block","type","source_type","isURLContentBlock","url","isBase64ContentBlock","data","isPlainTextContentBlock","text","isIDContentBlock","id","convertToOpenAIImageBlock","image_url","mime_type","Error","parseMimeType","parts","split","length","trim","subtype","parameters","parameterKvp","slice","parameterParts","key","value","parseBase64DataUrl","dataUrl","data_url","asTypedArray","formatMatch","match","toLowerCase","Uint8Array","from","atob","c","charCodeAt","undefined","convertToProviderContentBlock","block","converter","fromStandardTextBlock","providerName","fromStandardImageBlock","fromStandardAudioBlock","fromStandardFileBlock"],"sources":["/Users/chetan/Desktop/summarize_agent/frontend/node_modules/@langchain/core/dist/messages/content_blocks.js"],"sourcesContent":["export function isDataContentBlock(content_block) {\n    return (typeof content_block === \"object\" &&\n        content_block !== null &&\n        \"type\" in content_block &&\n        typeof content_block.type === \"string\" &&\n        \"source_type\" in content_block &&\n        (content_block.source_type === \"url\" ||\n            content_block.source_type === \"base64\" ||\n            content_block.source_type === \"text\" ||\n            content_block.source_type === \"id\"));\n}\nexport function isURLContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"url\" &&\n        \"url\" in content_block &&\n        typeof content_block.url === \"string\");\n}\nexport function isBase64ContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"base64\" &&\n        \"data\" in content_block &&\n        typeof content_block.data === \"string\");\n}\nexport function isPlainTextContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"text\" &&\n        \"text\" in content_block &&\n        typeof content_block.text === \"string\");\n}\nexport function isIDContentBlock(content_block) {\n    return (isDataContentBlock(content_block) &&\n        content_block.source_type === \"id\" &&\n        \"id\" in content_block &&\n        typeof content_block.id === \"string\");\n}\nexport function convertToOpenAIImageBlock(content_block) {\n    if (isDataContentBlock(content_block)) {\n        if (content_block.source_type === \"url\") {\n            return {\n                type: \"image_url\",\n                image_url: {\n                    url: content_block.url,\n                },\n            };\n        }\n        if (content_block.source_type === \"base64\") {\n            if (!content_block.mime_type) {\n                throw new Error(\"mime_type key is required for base64 data.\");\n            }\n            const mime_type = content_block.mime_type;\n            return {\n                type: \"image_url\",\n                image_url: {\n                    url: `data:${mime_type};base64,${content_block.data}`,\n                },\n            };\n        }\n    }\n    throw new Error(\"Unsupported source type. Only 'url' and 'base64' are supported.\");\n}\n/**\n * Utility function for ChatModelProviders. Parses a mime type into a type, subtype, and parameters.\n *\n * @param mime_type - The mime type to parse.\n * @returns An object containing the type, subtype, and parameters.\n */\nexport function parseMimeType(mime_type) {\n    const parts = mime_type.split(\";\")[0].split(\"/\");\n    if (parts.length !== 2) {\n        throw new Error(`Invalid mime type: \"${mime_type}\" - does not match type/subtype format.`);\n    }\n    const type = parts[0].trim();\n    const subtype = parts[1].trim();\n    if (type === \"\" || subtype === \"\") {\n        throw new Error(`Invalid mime type: \"${mime_type}\" - type or subtype is empty.`);\n    }\n    const parameters = {};\n    for (const parameterKvp of mime_type.split(\";\").slice(1)) {\n        const parameterParts = parameterKvp.split(\"=\");\n        if (parameterParts.length !== 2) {\n            throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n        }\n        const key = parameterParts[0].trim();\n        const value = parameterParts[1].trim();\n        if (key === \"\") {\n            throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n        }\n        parameters[key] = value;\n    }\n    return {\n        type,\n        subtype,\n        parameters,\n    };\n}\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns The parsed data and mime type, or undefined if the data URL is invalid.\n */\nexport function parseBase64DataUrl({ dataUrl: data_url, asTypedArray = false, }) {\n    const formatMatch = data_url.match(/^data:(\\w+\\/\\w+);base64,([A-Za-z0-9+/]+=*)$/);\n    let mime_type;\n    if (formatMatch) {\n        mime_type = formatMatch[1].toLowerCase();\n        const data = asTypedArray\n            ? Uint8Array.from(atob(formatMatch[2]), (c) => c.charCodeAt(0))\n            : formatMatch[2];\n        return {\n            mime_type,\n            data,\n        };\n    }\n    return undefined;\n}\n/**\n * Convert from a standard data content block to a provider's proprietary data content block format.\n *\n * Don't override this method. Instead, override the more specific conversion methods and use this\n * method unmodified.\n *\n * @param block - The standard data content block to convert.\n * @returns The provider data content block.\n * @throws An error if the standard data content block type is not supported.\n */\nexport function convertToProviderContentBlock(block, converter) {\n    if (block.type === \"text\") {\n        if (!converter.fromStandardTextBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardTextBlock\\` method.`);\n        }\n        return converter.fromStandardTextBlock(block);\n    }\n    if (block.type === \"image\") {\n        if (!converter.fromStandardImageBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardImageBlock\\` method.`);\n        }\n        return converter.fromStandardImageBlock(block);\n    }\n    if (block.type === \"audio\") {\n        if (!converter.fromStandardAudioBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardAudioBlock\\` method.`);\n        }\n        return converter.fromStandardAudioBlock(block);\n    }\n    if (block.type === \"file\") {\n        if (!converter.fromStandardFileBlock) {\n            throw new Error(`Converter for ${converter.providerName} does not implement \\`fromStandardFileBlock\\` method.`);\n        }\n        return converter.fromStandardFileBlock(block);\n    }\n    throw new Error(`Unable to convert content block type '${block.type}' to provider-specific format: not recognized.`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}