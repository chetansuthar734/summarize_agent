{"ast":null,"code":"import { AsyncCaller } from \"./utils/async_caller.js\";\nimport { getEnvironmentVariable } from \"./utils/env.js\";\nimport { mergeSignals } from \"./utils/signals.js\";\nimport { BytesLineDecoder, SSEDecoder } from \"./utils/sse.js\";\nimport { IterableReadableStream } from \"./utils/stream.js\";\nfunction* iterateHeaders(headers) {\n  let iter;\n  let shouldClear = false;\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  if (headers instanceof Headers) {\n    const entries = [];\n    headers.forEach((value, name) => {\n      entries.push([name, value]);\n    });\n    iter = entries;\n  } else if (Array.isArray(headers)) {\n    iter = headers;\n  } else {\n    shouldClear = true;\n    iter = Object.entries(headers ?? {});\n  }\n  for (const item of iter) {\n    const name = item[0];\n    if (typeof name !== \"string\") throw new TypeError(`Expected header name to be a string, got ${typeof name}`);\n    const values = Array.isArray(item[1]) ? item[1] : [item[1]];\n    let didClear = false;\n    for (const value of values) {\n      if (value === undefined) continue;\n      // New object keys should always overwrite older headers\n      // Yield a null to clear the header in the headers object\n      // before adding the new value\n      if (shouldClear && !didClear) {\n        didClear = true;\n        yield [name, null];\n      }\n      yield [name, value];\n    }\n  }\n}\nfunction mergeHeaders(...headerObjects) {\n  const outputHeaders = new Headers();\n  for (const headers of headerObjects) {\n    if (!headers) continue;\n    for (const [name, value] of iterateHeaders(headers)) {\n      if (value === null) outputHeaders.delete(name);else outputHeaders.append(name, value);\n    }\n  }\n  const headerEntries = [];\n  outputHeaders.forEach((value, name) => {\n    headerEntries.push([name, value]);\n  });\n  return Object.fromEntries(headerEntries);\n}\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - Optional API key provided as an argument\n * @returns The API key if found, otherwise undefined\n */\nexport function getApiKey(apiKey) {\n  if (apiKey) {\n    return apiKey;\n  }\n  const prefixes = [\"LANGGRAPH\", \"LANGSMITH\", \"LANGCHAIN\"];\n  for (const prefix of prefixes) {\n    const envKey = getEnvironmentVariable(`${prefix}_API_KEY`);\n    if (envKey) {\n      // Remove surrounding quotes\n      return envKey.trim().replace(/^[\"']|[\"']$/g, \"\");\n    }\n  }\n  return undefined;\n}\nconst REGEX_RUN_METADATA = /(\\/threads\\/(?<thread_id>.+))?\\/runs\\/(?<run_id>.+)/;\nfunction getRunMetadataFromResponse(response) {\n  const contentLocation = response.headers.get(\"Content-Location\");\n  if (!contentLocation) return undefined;\n  const match = REGEX_RUN_METADATA.exec(contentLocation);\n  if (!match?.groups?.run_id) return undefined;\n  return {\n    run_id: match.groups.run_id,\n    thread_id: match.groups.thread_id || undefined\n  };\n}\nclass BaseClient {\n  constructor(config) {\n    Object.defineProperty(this, \"asyncCaller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"timeoutMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"apiUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"defaultHeaders\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"onRequest\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    const callerOptions = {\n      maxRetries: 4,\n      maxConcurrency: 4,\n      ...config?.callerOptions\n    };\n    let defaultApiUrl = \"http://localhost:8123\";\n    if (!config?.apiUrl && typeof globalThis === \"object\" && globalThis != null) {\n      const fetchSmb = Symbol.for(\"langgraph_api:fetch\");\n      const urlSmb = Symbol.for(\"langgraph_api:url\");\n      const global = globalThis;\n      if (global[fetchSmb]) callerOptions.fetch ??= global[fetchSmb];\n      if (global[urlSmb]) defaultApiUrl = global[urlSmb];\n    }\n    this.asyncCaller = new AsyncCaller(callerOptions);\n    this.timeoutMs = config?.timeoutMs;\n    // default limit being capped by Chrome\n    // https://github.com/nodejs/undici/issues/1373\n    // Regex to remove trailing slash, if present\n    this.apiUrl = config?.apiUrl?.replace(/\\/$/, \"\") || defaultApiUrl;\n    this.defaultHeaders = config?.defaultHeaders || {};\n    this.onRequest = config?.onRequest;\n    const apiKey = getApiKey(config?.apiKey);\n    if (apiKey) {\n      this.defaultHeaders[\"x-api-key\"] = apiKey;\n    }\n  }\n  prepareFetchOptions(path, options) {\n    const mutatedOptions = {\n      ...options,\n      headers: mergeHeaders(this.defaultHeaders, options?.headers)\n    };\n    if (mutatedOptions.json) {\n      mutatedOptions.body = JSON.stringify(mutatedOptions.json);\n      mutatedOptions.headers = mergeHeaders(mutatedOptions.headers, {\n        \"content-type\": \"application/json\"\n      });\n      delete mutatedOptions.json;\n    }\n    if (mutatedOptions.withResponse) {\n      delete mutatedOptions.withResponse;\n    }\n    let timeoutSignal = null;\n    if (typeof options?.timeoutMs !== \"undefined\") {\n      if (options.timeoutMs != null) {\n        timeoutSignal = AbortSignal.timeout(options.timeoutMs);\n      }\n    } else if (this.timeoutMs != null) {\n      timeoutSignal = AbortSignal.timeout(this.timeoutMs);\n    }\n    mutatedOptions.signal = mergeSignals(timeoutSignal, mutatedOptions.signal);\n    const targetUrl = new URL(`${this.apiUrl}${path}`);\n    if (mutatedOptions.params) {\n      for (const [key, value] of Object.entries(mutatedOptions.params)) {\n        if (value == null) continue;\n        const strValue = typeof value === \"string\" || typeof value === \"number\" ? value.toString() : JSON.stringify(value);\n        targetUrl.searchParams.append(key, strValue);\n      }\n      delete mutatedOptions.params;\n    }\n    return [targetUrl, mutatedOptions];\n  }\n  async fetch(path, options) {\n    const [url, init] = this.prepareFetchOptions(path, options);\n    let finalInit = init;\n    if (this.onRequest) {\n      finalInit = await this.onRequest(url, init);\n    }\n    const response = await this.asyncCaller.fetch(url, finalInit);\n    const body = (() => {\n      if (response.status === 202 || response.status === 204) {\n        return undefined;\n      }\n      return response.json();\n    })();\n    if (options?.withResponse) {\n      return [await body, response];\n    }\n    return body;\n  }\n}\nexport class CronsClient extends BaseClient {\n  /**\n   *\n   * @param threadId The ID of the thread.\n   * @param assistantId Assistant ID to use for this cron job.\n   * @param payload Payload for creating a cron job.\n   * @returns The created background run.\n   */\n  async createForThread(threadId, assistantId, payload) {\n    const json = {\n      schedule: payload?.schedule,\n      input: payload?.input,\n      config: payload?.config,\n      context: payload?.context,\n      metadata: payload?.metadata,\n      assistant_id: assistantId,\n      interrupt_before: payload?.interruptBefore,\n      interrupt_after: payload?.interruptAfter,\n      webhook: payload?.webhook,\n      multitask_strategy: payload?.multitaskStrategy,\n      if_not_exists: payload?.ifNotExists,\n      checkpoint_during: payload?.checkpointDuring\n    };\n    return this.fetch(`/threads/${threadId}/runs/crons`, {\n      method: \"POST\",\n      json\n    });\n  }\n  /**\n   *\n   * @param assistantId Assistant ID to use for this cron job.\n   * @param payload Payload for creating a cron job.\n   * @returns\n   */\n  async create(assistantId, payload) {\n    const json = {\n      schedule: payload?.schedule,\n      input: payload?.input,\n      config: payload?.config,\n      context: payload?.context,\n      metadata: payload?.metadata,\n      assistant_id: assistantId,\n      interrupt_before: payload?.interruptBefore,\n      interrupt_after: payload?.interruptAfter,\n      webhook: payload?.webhook,\n      multitask_strategy: payload?.multitaskStrategy,\n      if_not_exists: payload?.ifNotExists,\n      checkpoint_during: payload?.checkpointDuring\n    };\n    return this.fetch(`/runs/crons`, {\n      method: \"POST\",\n      json\n    });\n  }\n  /**\n   *\n   * @param cronId Cron ID of Cron job to delete.\n   */\n  async delete(cronId) {\n    await this.fetch(`/runs/crons/${cronId}`, {\n      method: \"DELETE\"\n    });\n  }\n  /**\n   *\n   * @param query Query options.\n   * @returns List of crons.\n   */\n  async search(query) {\n    return this.fetch(\"/runs/crons/search\", {\n      method: \"POST\",\n      json: {\n        assistant_id: query?.assistantId ?? undefined,\n        thread_id: query?.threadId ?? undefined,\n        limit: query?.limit ?? 10,\n        offset: query?.offset ?? 0,\n        sort_by: query?.sortBy ?? undefined,\n        sort_order: query?.sortOrder ?? undefined\n      }\n    });\n  }\n}\nexport class AssistantsClient extends BaseClient {\n  /**\n   * Get an assistant by ID.\n   *\n   * @param assistantId The ID of the assistant.\n   * @returns Assistant\n   */\n  async get(assistantId) {\n    return this.fetch(`/assistants/${assistantId}`);\n  }\n  /**\n   * Get the JSON representation of the graph assigned to a runnable\n   * @param assistantId The ID of the assistant.\n   * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n   * @returns Serialized graph\n   */\n  async getGraph(assistantId, options) {\n    return this.fetch(`/assistants/${assistantId}/graph`, {\n      params: {\n        xray: options?.xray\n      }\n    });\n  }\n  /**\n   * Get the state and config schema of the graph assigned to a runnable\n   * @param assistantId The ID of the assistant.\n   * @returns Graph schema\n   */\n  async getSchemas(assistantId) {\n    return this.fetch(`/assistants/${assistantId}/schemas`);\n  }\n  /**\n   * Get the schemas of an assistant by ID.\n   *\n   * @param assistantId The ID of the assistant to get the schema of.\n   * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n   * @returns The subgraphs of the assistant.\n   */\n  async getSubgraphs(assistantId, options) {\n    if (options?.namespace) {\n      return this.fetch(`/assistants/${assistantId}/subgraphs/${options.namespace}`, {\n        params: {\n          recurse: options?.recurse\n        }\n      });\n    }\n    return this.fetch(`/assistants/${assistantId}/subgraphs`, {\n      params: {\n        recurse: options?.recurse\n      }\n    });\n  }\n  /**\n   * Create a new assistant.\n   * @param payload Payload for creating an assistant.\n   * @returns The created assistant.\n   */\n  async create(payload) {\n    return this.fetch(\"/assistants\", {\n      method: \"POST\",\n      json: {\n        graph_id: payload.graphId,\n        config: payload.config,\n        context: payload.context,\n        metadata: payload.metadata,\n        assistant_id: payload.assistantId,\n        if_exists: payload.ifExists,\n        name: payload.name,\n        description: payload.description\n      }\n    });\n  }\n  /**\n   * Update an assistant.\n   * @param assistantId ID of the assistant.\n   * @param payload Payload for updating the assistant.\n   * @returns The updated assistant.\n   */\n  async update(assistantId, payload) {\n    return this.fetch(`/assistants/${assistantId}`, {\n      method: \"PATCH\",\n      json: {\n        graph_id: payload.graphId,\n        config: payload.config,\n        context: payload.context,\n        metadata: payload.metadata,\n        name: payload.name,\n        description: payload.description\n      }\n    });\n  }\n  /**\n   * Delete an assistant.\n   *\n   * @param assistantId ID of the assistant.\n   */\n  async delete(assistantId) {\n    return this.fetch(`/assistants/${assistantId}`, {\n      method: \"DELETE\"\n    });\n  }\n  /**\n   * List assistants.\n   * @param query Query options.\n   * @returns List of assistants.\n   */\n  async search(query) {\n    return this.fetch(\"/assistants/search\", {\n      method: \"POST\",\n      json: {\n        graph_id: query?.graphId ?? undefined,\n        metadata: query?.metadata ?? undefined,\n        limit: query?.limit ?? 10,\n        offset: query?.offset ?? 0,\n        sort_by: query?.sortBy ?? undefined,\n        sort_order: query?.sortOrder ?? undefined\n      }\n    });\n  }\n  /**\n   * List all versions of an assistant.\n   *\n   * @param assistantId ID of the assistant.\n   * @returns List of assistant versions.\n   */\n  async getVersions(assistantId, payload) {\n    return this.fetch(`/assistants/${assistantId}/versions`, {\n      method: \"POST\",\n      json: {\n        metadata: payload?.metadata ?? undefined,\n        limit: payload?.limit ?? 10,\n        offset: payload?.offset ?? 0\n      }\n    });\n  }\n  /**\n   * Change the version of an assistant.\n   *\n   * @param assistantId ID of the assistant.\n   * @param version The version to change to.\n   * @returns The updated assistant.\n   */\n  async setLatest(assistantId, version) {\n    return this.fetch(`/assistants/${assistantId}/latest`, {\n      method: \"POST\",\n      json: {\n        version\n      }\n    });\n  }\n}\nexport class ThreadsClient extends BaseClient {\n  /**\n   * Get a thread by ID.\n   *\n   * @param threadId ID of the thread.\n   * @returns The thread.\n   */\n  async get(threadId) {\n    return this.fetch(`/threads/${threadId}`);\n  }\n  /**\n   * Create a new thread.\n   *\n   * @param payload Payload for creating a thread.\n   * @returns The created thread.\n   */\n  async create(payload) {\n    return this.fetch(`/threads`, {\n      method: \"POST\",\n      json: {\n        metadata: {\n          ...payload?.metadata,\n          graph_id: payload?.graphId\n        },\n        thread_id: payload?.threadId,\n        if_exists: payload?.ifExists,\n        supersteps: payload?.supersteps?.map(s => ({\n          updates: s.updates.map(u => ({\n            values: u.values,\n            command: u.command,\n            as_node: u.asNode\n          }))\n        }))\n      }\n    });\n  }\n  /**\n   * Copy an existing thread\n   * @param threadId ID of the thread to be copied\n   * @returns Newly copied thread\n   */\n  async copy(threadId) {\n    return this.fetch(`/threads/${threadId}/copy`, {\n      method: \"POST\"\n    });\n  }\n  /**\n   * Update a thread.\n   *\n   * @param threadId ID of the thread.\n   * @param payload Payload for updating the thread.\n   * @returns The updated thread.\n   */\n  async update(threadId, payload) {\n    return this.fetch(`/threads/${threadId}`, {\n      method: \"PATCH\",\n      json: {\n        metadata: payload?.metadata\n      }\n    });\n  }\n  /**\n   * Delete a thread.\n   *\n   * @param threadId ID of the thread.\n   */\n  async delete(threadId) {\n    return this.fetch(`/threads/${threadId}`, {\n      method: \"DELETE\"\n    });\n  }\n  /**\n   * List threads\n   *\n   * @param query Query options\n   * @returns List of threads\n   */\n  async search(query) {\n    return this.fetch(\"/threads/search\", {\n      method: \"POST\",\n      json: {\n        metadata: query?.metadata ?? undefined,\n        limit: query?.limit ?? 10,\n        offset: query?.offset ?? 0,\n        status: query?.status,\n        sort_by: query?.sortBy,\n        sort_order: query?.sortOrder\n      }\n    });\n  }\n  /**\n   * Get state for a thread.\n   *\n   * @param threadId ID of the thread.\n   * @returns Thread state.\n   */\n  async getState(threadId, checkpoint, options) {\n    if (checkpoint != null) {\n      if (typeof checkpoint !== \"string\") {\n        return this.fetch(`/threads/${threadId}/state/checkpoint`, {\n          method: \"POST\",\n          json: {\n            checkpoint,\n            subgraphs: options?.subgraphs\n          }\n        });\n      }\n      // deprecated\n      return this.fetch(`/threads/${threadId}/state/${checkpoint}`, {\n        params: {\n          subgraphs: options?.subgraphs\n        }\n      });\n    }\n    return this.fetch(`/threads/${threadId}/state`, {\n      params: {\n        subgraphs: options?.subgraphs\n      }\n    });\n  }\n  /**\n   * Add state to a thread.\n   *\n   * @param threadId The ID of the thread.\n   * @returns\n   */\n  async updateState(threadId, options) {\n    return this.fetch(`/threads/${threadId}/state`, {\n      method: \"POST\",\n      json: {\n        values: options.values,\n        checkpoint_id: options.checkpointId,\n        checkpoint: options.checkpoint,\n        as_node: options?.asNode\n      }\n    });\n  }\n  /**\n   * Patch the metadata of a thread.\n   *\n   * @param threadIdOrConfig Thread ID or config to patch the state of.\n   * @param metadata Metadata to patch the state with.\n   */\n  async patchState(threadIdOrConfig, metadata) {\n    let threadId;\n    if (typeof threadIdOrConfig !== \"string\") {\n      if (typeof threadIdOrConfig.configurable?.thread_id !== \"string\") {\n        throw new Error(\"Thread ID is required when updating state with a config.\");\n      }\n      threadId = threadIdOrConfig.configurable.thread_id;\n    } else {\n      threadId = threadIdOrConfig;\n    }\n    return this.fetch(`/threads/${threadId}/state`, {\n      method: \"PATCH\",\n      json: {\n        metadata\n      }\n    });\n  }\n  /**\n   * Get all past states for a thread.\n   *\n   * @param threadId ID of the thread.\n   * @param options Additional options.\n   * @returns List of thread states.\n   */\n  async getHistory(threadId, options) {\n    return this.fetch(`/threads/${threadId}/history`, {\n      method: \"POST\",\n      json: {\n        limit: options?.limit ?? 10,\n        before: options?.before,\n        metadata: options?.metadata,\n        checkpoint: options?.checkpoint\n      }\n    });\n  }\n}\nexport class RunsClient extends BaseClient {\n  /**\n   * Create a run and stream the results.\n   *\n   * @param threadId The ID of the thread.\n   * @param assistantId Assistant ID to use for this run.\n   * @param payload Payload for creating a run.\n   */\n  async *stream(threadId, assistantId, payload) {\n    const json = {\n      input: payload?.input,\n      command: payload?.command,\n      config: payload?.config,\n      context: payload?.context,\n      metadata: payload?.metadata,\n      stream_mode: payload?.streamMode,\n      stream_subgraphs: payload?.streamSubgraphs,\n      stream_resumable: payload?.streamResumable,\n      feedback_keys: payload?.feedbackKeys,\n      assistant_id: assistantId,\n      interrupt_before: payload?.interruptBefore,\n      interrupt_after: payload?.interruptAfter,\n      checkpoint: payload?.checkpoint,\n      checkpoint_id: payload?.checkpointId,\n      webhook: payload?.webhook,\n      multitask_strategy: payload?.multitaskStrategy,\n      on_completion: payload?.onCompletion,\n      on_disconnect: payload?.onDisconnect,\n      after_seconds: payload?.afterSeconds,\n      if_not_exists: payload?.ifNotExists,\n      checkpoint_during: payload?.checkpointDuring\n    };\n    const endpoint = threadId == null ? `/runs/stream` : `/threads/${threadId}/runs/stream`;\n    const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(endpoint, {\n      method: \"POST\",\n      json,\n      timeoutMs: null,\n      signal: payload?.signal\n    }));\n    const runMetadata = getRunMetadataFromResponse(response);\n    if (runMetadata) payload?.onRunCreated?.(runMetadata);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const stream = (response.body || new ReadableStream({\n      start: ctrl => ctrl.close()\n    })).pipeThrough(BytesLineDecoder()).pipeThrough(SSEDecoder());\n    yield* IterableReadableStream.fromReadableStream(stream);\n  }\n  /**\n   * Create a run.\n   *\n   * @param threadId The ID of the thread.\n   * @param assistantId Assistant ID to use for this run.\n   * @param payload Payload for creating a run.\n   * @returns The created run.\n   */\n  async create(threadId, assistantId, payload) {\n    const json = {\n      input: payload?.input,\n      command: payload?.command,\n      config: payload?.config,\n      context: payload?.context,\n      metadata: payload?.metadata,\n      stream_mode: payload?.streamMode,\n      stream_subgraphs: payload?.streamSubgraphs,\n      stream_resumable: payload?.streamResumable,\n      assistant_id: assistantId,\n      interrupt_before: payload?.interruptBefore,\n      interrupt_after: payload?.interruptAfter,\n      webhook: payload?.webhook,\n      checkpoint: payload?.checkpoint,\n      checkpoint_id: payload?.checkpointId,\n      multitask_strategy: payload?.multitaskStrategy,\n      after_seconds: payload?.afterSeconds,\n      if_not_exists: payload?.ifNotExists,\n      checkpoint_during: payload?.checkpointDuring,\n      langsmith_tracer: payload?._langsmithTracer ? {\n        project_name: payload?._langsmithTracer?.projectName,\n        example_id: payload?._langsmithTracer?.exampleId\n      } : undefined\n    };\n    const [run, response] = await this.fetch(`/threads/${threadId}/runs`, {\n      method: \"POST\",\n      json,\n      signal: payload?.signal,\n      withResponse: true\n    });\n    const runMetadata = getRunMetadataFromResponse(response);\n    if (runMetadata) payload?.onRunCreated?.(runMetadata);\n    return run;\n  }\n  /**\n   * Create a batch of stateless background runs.\n   *\n   * @param payloads An array of payloads for creating runs.\n   * @returns An array of created runs.\n   */\n  async createBatch(payloads) {\n    const filteredPayloads = payloads.map(payload => ({\n      ...payload,\n      assistant_id: payload.assistantId\n    })).map(payload => {\n      return Object.fromEntries(Object.entries(payload).filter(([_, v]) => v !== undefined));\n    });\n    return this.fetch(\"/runs/batch\", {\n      method: \"POST\",\n      json: filteredPayloads\n    });\n  }\n  /**\n   * Create a run and wait for it to complete.\n   *\n   * @param threadId The ID of the thread.\n   * @param assistantId Assistant ID to use for this run.\n   * @param payload Payload for creating a run.\n   * @returns The last values chunk of the thread.\n   */\n  async wait(threadId, assistantId, payload) {\n    const json = {\n      input: payload?.input,\n      command: payload?.command,\n      config: payload?.config,\n      context: payload?.context,\n      metadata: payload?.metadata,\n      assistant_id: assistantId,\n      interrupt_before: payload?.interruptBefore,\n      interrupt_after: payload?.interruptAfter,\n      checkpoint: payload?.checkpoint,\n      checkpoint_id: payload?.checkpointId,\n      webhook: payload?.webhook,\n      multitask_strategy: payload?.multitaskStrategy,\n      on_completion: payload?.onCompletion,\n      on_disconnect: payload?.onDisconnect,\n      after_seconds: payload?.afterSeconds,\n      if_not_exists: payload?.ifNotExists,\n      checkpoint_during: payload?.checkpointDuring,\n      langsmith_tracer: payload?._langsmithTracer ? {\n        project_name: payload?._langsmithTracer?.projectName,\n        example_id: payload?._langsmithTracer?.exampleId\n      } : undefined\n    };\n    const endpoint = threadId == null ? `/runs/wait` : `/threads/${threadId}/runs/wait`;\n    const [run, response] = await this.fetch(endpoint, {\n      method: \"POST\",\n      json,\n      timeoutMs: null,\n      signal: payload?.signal,\n      withResponse: true\n    });\n    const runMetadata = getRunMetadataFromResponse(response);\n    if (runMetadata) payload?.onRunCreated?.(runMetadata);\n    const raiseError = payload?.raiseError !== undefined ? payload.raiseError : true;\n    if (raiseError && \"__error__\" in run && typeof run.__error__ === \"object\" && run.__error__ && \"error\" in run.__error__ && \"message\" in run.__error__) {\n      throw new Error(`${run.__error__?.error}: ${run.__error__?.message}`);\n    }\n    return run;\n  }\n  /**\n   * List all runs for a thread.\n   *\n   * @param threadId The ID of the thread.\n   * @param options Filtering and pagination options.\n   * @returns List of runs.\n   */\n  async list(threadId, options) {\n    return this.fetch(`/threads/${threadId}/runs`, {\n      params: {\n        limit: options?.limit ?? 10,\n        offset: options?.offset ?? 0,\n        status: options?.status ?? undefined\n      }\n    });\n  }\n  /**\n   * Get a run by ID.\n   *\n   * @param threadId The ID of the thread.\n   * @param runId The ID of the run.\n   * @returns The run.\n   */\n  async get(threadId, runId) {\n    return this.fetch(`/threads/${threadId}/runs/${runId}`);\n  }\n  /**\n   * Cancel a run.\n   *\n   * @param threadId The ID of the thread.\n   * @param runId The ID of the run.\n   * @param wait Whether to block when canceling\n   * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n   * @returns\n   */\n  async cancel(threadId, runId, wait = false, action = \"interrupt\") {\n    return this.fetch(`/threads/${threadId}/runs/${runId}/cancel`, {\n      method: \"POST\",\n      params: {\n        wait: wait ? \"1\" : \"0\",\n        action\n      }\n    });\n  }\n  /**\n   * Block until a run is done.\n   *\n   * @param threadId The ID of the thread.\n   * @param runId The ID of the run.\n   * @returns\n   */\n  async join(threadId, runId, options) {\n    return this.fetch(`/threads/${threadId}/runs/${runId}/join`, {\n      timeoutMs: null,\n      signal: options?.signal\n    });\n  }\n  /**\n   * Stream output from a run in real-time, until the run is done.\n   *\n   * @param threadId The ID of the thread. Can be set to `null` | `undefined` for stateless runs.\n   * @param runId The ID of the run.\n   * @param options Additional options for controlling the stream behavior:\n   *   - signal: An AbortSignal that can be used to cancel the stream request\n   *   - lastEventId: The ID of the last event received. Can be used to reconnect to a stream without losing events.\n   *   - cancelOnDisconnect: When true, automatically cancels the run if the client disconnects from the stream\n   *   - streamMode: Controls what types of events to receive from the stream (can be a single mode or array of modes)\n   *        Must be a subset of the stream modes passed when creating the run. Background runs default to having the union of all\n   *        stream modes enabled.\n   * @returns An async generator yielding stream parts.\n   */\n  async *joinStream(threadId, runId, options\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    const opts = typeof options === \"object\" && options != null &&\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    options instanceof AbortSignal ? {\n      signal: options\n    } : options;\n    const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(threadId != null ? `/threads/${threadId}/runs/${runId}/stream` : `/runs/${runId}/stream`, {\n      method: \"GET\",\n      timeoutMs: null,\n      signal: opts?.signal,\n      headers: opts?.lastEventId ? {\n        \"Last-Event-ID\": opts.lastEventId\n      } : undefined,\n      params: {\n        cancel_on_disconnect: opts?.cancelOnDisconnect ? \"1\" : \"0\",\n        stream_mode: opts?.streamMode\n      }\n    }));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const stream = (response.body || new ReadableStream({\n      start: ctrl => ctrl.close()\n    })).pipeThrough(BytesLineDecoder()).pipeThrough(SSEDecoder());\n    yield* IterableReadableStream.fromReadableStream(stream);\n  }\n  /**\n   * Delete a run.\n   *\n   * @param threadId The ID of the thread.\n   * @param runId The ID of the run.\n   * @returns\n   */\n  async delete(threadId, runId) {\n    return this.fetch(`/threads/${threadId}/runs/${runId}`, {\n      method: \"DELETE\"\n    });\n  }\n}\nexport class StoreClient extends BaseClient {\n  /**\n   * Store or update an item.\n   *\n   * @param namespace A list of strings representing the namespace path.\n   * @param key The unique identifier for the item within the namespace.\n   * @param value A dictionary containing the item's data.\n   * @param options.index Controls search indexing - null (use defaults), false (disable), or list of field paths to index.\n   * @param options.ttl Optional time-to-live in minutes for the item, or null for no expiration.\n   * @returns Promise<void>\n   *\n   * @example\n   * ```typescript\n   * await client.store.putItem(\n   *   [\"documents\", \"user123\"],\n   *   \"item456\",\n   *   { title: \"My Document\", content: \"Hello World\" },\n   *   { ttl: 60 } // expires in 60 minutes\n   * );\n   * ```\n   */\n  async putItem(namespace, key, value, options) {\n    namespace.forEach(label => {\n      if (label.includes(\".\")) {\n        throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n      }\n    });\n    const payload = {\n      namespace,\n      key,\n      value,\n      index: options?.index,\n      ttl: options?.ttl\n    };\n    return this.fetch(\"/store/items\", {\n      method: \"PUT\",\n      json: payload\n    });\n  }\n  /**\n   * Retrieve a single item.\n   *\n   * @param namespace A list of strings representing the namespace path.\n   * @param key The unique identifier for the item.\n   * @param options.refreshTtl Whether to refresh the TTL on this read operation. If null, uses the store's default behavior.\n   * @returns Promise<Item>\n   *\n   * @example\n   * ```typescript\n   * const item = await client.store.getItem(\n   *   [\"documents\", \"user123\"],\n   *   \"item456\",\n   *   { refreshTtl: true }\n   * );\n   * console.log(item);\n   * // {\n   * //   namespace: [\"documents\", \"user123\"],\n   * //   key: \"item456\",\n   * //   value: { title: \"My Document\", content: \"Hello World\" },\n   * //   createdAt: \"2024-07-30T12:00:00Z\",\n   * //   updatedAt: \"2024-07-30T12:00:00Z\"\n   * // }\n   * ```\n   */\n  async getItem(namespace, key, options) {\n    namespace.forEach(label => {\n      if (label.includes(\".\")) {\n        throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n      }\n    });\n    const params = {\n      namespace: namespace.join(\".\"),\n      key\n    };\n    if (options?.refreshTtl !== undefined) {\n      params.refresh_ttl = options.refreshTtl;\n    }\n    const response = await this.fetch(\"/store/items\", {\n      params\n    });\n    return response ? {\n      ...response,\n      createdAt: response.created_at,\n      updatedAt: response.updated_at\n    } : null;\n  }\n  /**\n   * Delete an item.\n   *\n   * @param namespace A list of strings representing the namespace path.\n   * @param key The unique identifier for the item.\n   * @returns Promise<void>\n   */\n  async deleteItem(namespace, key) {\n    namespace.forEach(label => {\n      if (label.includes(\".\")) {\n        throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n      }\n    });\n    return this.fetch(\"/store/items\", {\n      method: \"DELETE\",\n      json: {\n        namespace,\n        key\n      }\n    });\n  }\n  /**\n   * Search for items within a namespace prefix.\n   *\n   * @param namespacePrefix List of strings representing the namespace prefix.\n   * @param options.filter Optional dictionary of key-value pairs to filter results.\n   * @param options.limit Maximum number of items to return (default is 10).\n   * @param options.offset Number of items to skip before returning results (default is 0).\n   * @param options.query Optional search query.\n   * @param options.refreshTtl Whether to refresh the TTL on items returned by this search. If null, uses the store's default behavior.\n   * @returns Promise<SearchItemsResponse>\n   *\n   * @example\n   * ```typescript\n   * const results = await client.store.searchItems(\n   *   [\"documents\"],\n   *   {\n   *     filter: { author: \"John Doe\" },\n   *     limit: 5,\n   *     refreshTtl: true\n   *   }\n   * );\n   * console.log(results);\n   * // {\n   * //   items: [\n   * //     {\n   * //       namespace: [\"documents\", \"user123\"],\n   * //       key: \"item789\",\n   * //       value: { title: \"Another Document\", author: \"John Doe\" },\n   * //       createdAt: \"2024-07-30T12:00:00Z\",\n   * //       updatedAt: \"2024-07-30T12:00:00Z\"\n   * //     },\n   * //     // ... additional items ...\n   * //   ]\n   * // }\n   * ```\n   */\n  async searchItems(namespacePrefix, options) {\n    const payload = {\n      namespace_prefix: namespacePrefix,\n      filter: options?.filter,\n      limit: options?.limit ?? 10,\n      offset: options?.offset ?? 0,\n      query: options?.query,\n      refresh_ttl: options?.refreshTtl\n    };\n    const response = await this.fetch(\"/store/items/search\", {\n      method: \"POST\",\n      json: payload\n    });\n    return {\n      items: response.items.map(item => ({\n        ...item,\n        createdAt: item.created_at,\n        updatedAt: item.updated_at\n      }))\n    };\n  }\n  /**\n   * List namespaces with optional match conditions.\n   *\n   * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n   * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n   * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n   * @param options.limit Maximum number of namespaces to return (default is 100).\n   * @param options.offset Number of namespaces to skip before returning results (default is 0).\n   * @returns Promise<ListNamespaceResponse>\n   */\n  async listNamespaces(options) {\n    const payload = {\n      prefix: options?.prefix,\n      suffix: options?.suffix,\n      max_depth: options?.maxDepth,\n      limit: options?.limit ?? 100,\n      offset: options?.offset ?? 0\n    };\n    return this.fetch(\"/store/namespaces\", {\n      method: \"POST\",\n      json: payload\n    });\n  }\n}\nclass UiClient extends BaseClient {\n  static getOrCached(key, fn) {\n    if (UiClient.promiseCache[key] != null) {\n      return UiClient.promiseCache[key];\n    }\n    const promise = fn();\n    UiClient.promiseCache[key] = promise;\n    return promise;\n  }\n  async getComponent(assistantId, agentName) {\n    return UiClient.getOrCached(`${this.apiUrl}-${assistantId}-${agentName}`, async () => {\n      const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(`/ui/${assistantId}`, {\n        headers: {\n          Accept: \"text/html\",\n          \"Content-Type\": \"application/json\"\n        },\n        method: \"POST\",\n        json: {\n          name: agentName\n        }\n      }));\n      return response.text();\n    });\n  }\n}\nObject.defineProperty(UiClient, \"promiseCache\", {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: {}\n});\nexport class Client {\n  constructor(config) {\n    /**\n     * The client for interacting with assistants.\n     */\n    Object.defineProperty(this, \"assistants\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The client for interacting with threads.\n     */\n    Object.defineProperty(this, \"threads\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The client for interacting with runs.\n     */\n    Object.defineProperty(this, \"runs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The client for interacting with cron runs.\n     */\n    Object.defineProperty(this, \"crons\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The client for interacting with the KV store.\n     */\n    Object.defineProperty(this, \"store\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\n     * The client for interacting with the UI.\n     * @internal Used by LoadExternalComponent and the API might change in the future.\n     */\n    Object.defineProperty(this, \"~ui\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\n     * @internal Used to obtain a stable key representing the client.\n     */\n    Object.defineProperty(this, \"~configHash\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this[\"~configHash\"] = (() => JSON.stringify({\n      apiUrl: config?.apiUrl,\n      apiKey: config?.apiKey,\n      timeoutMs: config?.timeoutMs,\n      defaultHeaders: config?.defaultHeaders,\n      maxConcurrency: config?.callerOptions?.maxConcurrency,\n      maxRetries: config?.callerOptions?.maxRetries,\n      callbacks: {\n        onFailedResponseHook: config?.callerOptions?.onFailedResponseHook != null,\n        onRequest: config?.onRequest != null,\n        fetch: config?.callerOptions?.fetch != null\n      }\n    }))();\n    this.assistants = new AssistantsClient(config);\n    this.threads = new ThreadsClient(config);\n    this.runs = new RunsClient(config);\n    this.crons = new CronsClient(config);\n    this.store = new StoreClient(config);\n    this[\"~ui\"] = new UiClient(config);\n  }\n}\n/**\n * @internal Used to obtain a stable key representing the client.\n */\nexport function getClientConfigHash(client) {\n  return client[\"~configHash\"];\n}","map":{"version":3,"names":["AsyncCaller","getEnvironmentVariable","mergeSignals","BytesLineDecoder","SSEDecoder","IterableReadableStream","iterateHeaders","headers","iter","shouldClear","Headers","entries","forEach","value","name","push","Array","isArray","Object","item","TypeError","values","didClear","undefined","mergeHeaders","headerObjects","outputHeaders","delete","append","headerEntries","fromEntries","getApiKey","apiKey","prefixes","prefix","envKey","trim","replace","REGEX_RUN_METADATA","getRunMetadataFromResponse","response","contentLocation","get","match","exec","groups","run_id","thread_id","BaseClient","constructor","config","defineProperty","enumerable","configurable","writable","callerOptions","maxRetries","maxConcurrency","defaultApiUrl","apiUrl","globalThis","fetchSmb","Symbol","for","urlSmb","global","fetch","asyncCaller","timeoutMs","defaultHeaders","onRequest","prepareFetchOptions","path","options","mutatedOptions","json","body","JSON","stringify","withResponse","timeoutSignal","AbortSignal","timeout","signal","targetUrl","URL","params","key","strValue","toString","searchParams","url","init","finalInit","status","CronsClient","createForThread","threadId","assistantId","payload","schedule","input","context","metadata","assistant_id","interrupt_before","interruptBefore","interrupt_after","interruptAfter","webhook","multitask_strategy","multitaskStrategy","if_not_exists","ifNotExists","checkpoint_during","checkpointDuring","method","create","cronId","search","query","limit","offset","sort_by","sortBy","sort_order","sortOrder","AssistantsClient","getGraph","xray","getSchemas","getSubgraphs","namespace","recurse","graph_id","graphId","if_exists","ifExists","description","update","getVersions","setLatest","version","ThreadsClient","supersteps","map","s","updates","u","command","as_node","asNode","copy","getState","checkpoint","subgraphs","updateState","checkpoint_id","checkpointId","patchState","threadIdOrConfig","Error","getHistory","before","RunsClient","stream","stream_mode","streamMode","stream_subgraphs","streamSubgraphs","stream_resumable","streamResumable","feedback_keys","feedbackKeys","on_completion","onCompletion","on_disconnect","onDisconnect","after_seconds","afterSeconds","endpoint","runMetadata","onRunCreated","ReadableStream","start","ctrl","close","pipeThrough","fromReadableStream","langsmith_tracer","_langsmithTracer","project_name","projectName","example_id","exampleId","run","createBatch","payloads","filteredPayloads","filter","_","v","wait","raiseError","__error__","error","message","list","runId","cancel","action","join","joinStream","opts","lastEventId","cancel_on_disconnect","cancelOnDisconnect","StoreClient","putItem","label","includes","index","ttl","getItem","refreshTtl","refresh_ttl","createdAt","created_at","updatedAt","updated_at","deleteItem","searchItems","namespacePrefix","namespace_prefix","items","listNamespaces","suffix","max_depth","maxDepth","UiClient","getOrCached","fn","promiseCache","promise","getComponent","agentName","Accept","text","Client","callbacks","onFailedResponseHook","assistants","threads","runs","crons","store","getClientConfigHash","client"],"sources":["/Users/chetan/Desktop/summarize_agent/frontend/node_modules/@langchain/langgraph-sdk/dist/client.js"],"sourcesContent":["import { AsyncCaller } from \"./utils/async_caller.js\";\nimport { getEnvironmentVariable } from \"./utils/env.js\";\nimport { mergeSignals } from \"./utils/signals.js\";\nimport { BytesLineDecoder, SSEDecoder } from \"./utils/sse.js\";\nimport { IterableReadableStream } from \"./utils/stream.js\";\nfunction* iterateHeaders(headers) {\n    let iter;\n    let shouldClear = false;\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (headers instanceof Headers) {\n        const entries = [];\n        headers.forEach((value, name) => {\n            entries.push([name, value]);\n        });\n        iter = entries;\n    }\n    else if (Array.isArray(headers)) {\n        iter = headers;\n    }\n    else {\n        shouldClear = true;\n        iter = Object.entries(headers ?? {});\n    }\n    for (const item of iter) {\n        const name = item[0];\n        if (typeof name !== \"string\")\n            throw new TypeError(`Expected header name to be a string, got ${typeof name}`);\n        const values = Array.isArray(item[1]) ? item[1] : [item[1]];\n        let didClear = false;\n        for (const value of values) {\n            if (value === undefined)\n                continue;\n            // New object keys should always overwrite older headers\n            // Yield a null to clear the header in the headers object\n            // before adding the new value\n            if (shouldClear && !didClear) {\n                didClear = true;\n                yield [name, null];\n            }\n            yield [name, value];\n        }\n    }\n}\nfunction mergeHeaders(...headerObjects) {\n    const outputHeaders = new Headers();\n    for (const headers of headerObjects) {\n        if (!headers)\n            continue;\n        for (const [name, value] of iterateHeaders(headers)) {\n            if (value === null)\n                outputHeaders.delete(name);\n            else\n                outputHeaders.append(name, value);\n        }\n    }\n    const headerEntries = [];\n    outputHeaders.forEach((value, name) => {\n        headerEntries.push([name, value]);\n    });\n    return Object.fromEntries(headerEntries);\n}\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - Optional API key provided as an argument\n * @returns The API key if found, otherwise undefined\n */\nexport function getApiKey(apiKey) {\n    if (apiKey) {\n        return apiKey;\n    }\n    const prefixes = [\"LANGGRAPH\", \"LANGSMITH\", \"LANGCHAIN\"];\n    for (const prefix of prefixes) {\n        const envKey = getEnvironmentVariable(`${prefix}_API_KEY`);\n        if (envKey) {\n            // Remove surrounding quotes\n            return envKey.trim().replace(/^[\"']|[\"']$/g, \"\");\n        }\n    }\n    return undefined;\n}\nconst REGEX_RUN_METADATA = /(\\/threads\\/(?<thread_id>.+))?\\/runs\\/(?<run_id>.+)/;\nfunction getRunMetadataFromResponse(response) {\n    const contentLocation = response.headers.get(\"Content-Location\");\n    if (!contentLocation)\n        return undefined;\n    const match = REGEX_RUN_METADATA.exec(contentLocation);\n    if (!match?.groups?.run_id)\n        return undefined;\n    return {\n        run_id: match.groups.run_id,\n        thread_id: match.groups.thread_id || undefined,\n    };\n}\nclass BaseClient {\n    constructor(config) {\n        Object.defineProperty(this, \"asyncCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeoutMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"defaultHeaders\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onRequest\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const callerOptions = {\n            maxRetries: 4,\n            maxConcurrency: 4,\n            ...config?.callerOptions,\n        };\n        let defaultApiUrl = \"http://localhost:8123\";\n        if (!config?.apiUrl &&\n            typeof globalThis === \"object\" &&\n            globalThis != null) {\n            const fetchSmb = Symbol.for(\"langgraph_api:fetch\");\n            const urlSmb = Symbol.for(\"langgraph_api:url\");\n            const global = globalThis;\n            if (global[fetchSmb])\n                callerOptions.fetch ??= global[fetchSmb];\n            if (global[urlSmb])\n                defaultApiUrl = global[urlSmb];\n        }\n        this.asyncCaller = new AsyncCaller(callerOptions);\n        this.timeoutMs = config?.timeoutMs;\n        // default limit being capped by Chrome\n        // https://github.com/nodejs/undici/issues/1373\n        // Regex to remove trailing slash, if present\n        this.apiUrl = config?.apiUrl?.replace(/\\/$/, \"\") || defaultApiUrl;\n        this.defaultHeaders = config?.defaultHeaders || {};\n        this.onRequest = config?.onRequest;\n        const apiKey = getApiKey(config?.apiKey);\n        if (apiKey) {\n            this.defaultHeaders[\"x-api-key\"] = apiKey;\n        }\n    }\n    prepareFetchOptions(path, options) {\n        const mutatedOptions = {\n            ...options,\n            headers: mergeHeaders(this.defaultHeaders, options?.headers),\n        };\n        if (mutatedOptions.json) {\n            mutatedOptions.body = JSON.stringify(mutatedOptions.json);\n            mutatedOptions.headers = mergeHeaders(mutatedOptions.headers, {\n                \"content-type\": \"application/json\",\n            });\n            delete mutatedOptions.json;\n        }\n        if (mutatedOptions.withResponse) {\n            delete mutatedOptions.withResponse;\n        }\n        let timeoutSignal = null;\n        if (typeof options?.timeoutMs !== \"undefined\") {\n            if (options.timeoutMs != null) {\n                timeoutSignal = AbortSignal.timeout(options.timeoutMs);\n            }\n        }\n        else if (this.timeoutMs != null) {\n            timeoutSignal = AbortSignal.timeout(this.timeoutMs);\n        }\n        mutatedOptions.signal = mergeSignals(timeoutSignal, mutatedOptions.signal);\n        const targetUrl = new URL(`${this.apiUrl}${path}`);\n        if (mutatedOptions.params) {\n            for (const [key, value] of Object.entries(mutatedOptions.params)) {\n                if (value == null)\n                    continue;\n                const strValue = typeof value === \"string\" || typeof value === \"number\"\n                    ? value.toString()\n                    : JSON.stringify(value);\n                targetUrl.searchParams.append(key, strValue);\n            }\n            delete mutatedOptions.params;\n        }\n        return [targetUrl, mutatedOptions];\n    }\n    async fetch(path, options) {\n        const [url, init] = this.prepareFetchOptions(path, options);\n        let finalInit = init;\n        if (this.onRequest) {\n            finalInit = await this.onRequest(url, init);\n        }\n        const response = await this.asyncCaller.fetch(url, finalInit);\n        const body = (() => {\n            if (response.status === 202 || response.status === 204) {\n                return undefined;\n            }\n            return response.json();\n        })();\n        if (options?.withResponse) {\n            return [await body, response];\n        }\n        return body;\n    }\n}\nexport class CronsClient extends BaseClient {\n    /**\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns The created background run.\n     */\n    async createForThread(threadId, assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n        };\n        return this.fetch(`/threads/${threadId}/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns\n     */\n    async create(assistantId, payload) {\n        const json = {\n            schedule: payload?.schedule,\n            input: payload?.input,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n        };\n        return this.fetch(`/runs/crons`, {\n            method: \"POST\",\n            json,\n        });\n    }\n    /**\n     *\n     * @param cronId Cron ID of Cron job to delete.\n     */\n    async delete(cronId) {\n        await this.fetch(`/runs/crons/${cronId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     *\n     * @param query Query options.\n     * @returns List of crons.\n     */\n    async search(query) {\n        return this.fetch(\"/runs/crons/search\", {\n            method: \"POST\",\n            json: {\n                assistant_id: query?.assistantId ?? undefined,\n                thread_id: query?.threadId ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                sort_by: query?.sortBy ?? undefined,\n                sort_order: query?.sortOrder ?? undefined,\n            },\n        });\n    }\n}\nexport class AssistantsClient extends BaseClient {\n    /**\n     * Get an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant.\n     * @returns Assistant\n     */\n    async get(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`);\n    }\n    /**\n     * Get the JSON representation of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n     * @returns Serialized graph\n     */\n    async getGraph(assistantId, options) {\n        return this.fetch(`/assistants/${assistantId}/graph`, {\n            params: { xray: options?.xray },\n        });\n    }\n    /**\n     * Get the state and config schema of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Graph schema\n     */\n    async getSchemas(assistantId) {\n        return this.fetch(`/assistants/${assistantId}/schemas`);\n    }\n    /**\n     * Get the schemas of an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant to get the schema of.\n     * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n     * @returns The subgraphs of the assistant.\n     */\n    async getSubgraphs(assistantId, options) {\n        if (options?.namespace) {\n            return this.fetch(`/assistants/${assistantId}/subgraphs/${options.namespace}`, { params: { recurse: options?.recurse } });\n        }\n        return this.fetch(`/assistants/${assistantId}/subgraphs`, {\n            params: { recurse: options?.recurse },\n        });\n    }\n    /**\n     * Create a new assistant.\n     * @param payload Payload for creating an assistant.\n     * @returns The created assistant.\n     */\n    async create(payload) {\n        return this.fetch(\"/assistants\", {\n            method: \"POST\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                context: payload.context,\n                metadata: payload.metadata,\n                assistant_id: payload.assistantId,\n                if_exists: payload.ifExists,\n                name: payload.name,\n                description: payload.description,\n            },\n        });\n    }\n    /**\n     * Update an assistant.\n     * @param assistantId ID of the assistant.\n     * @param payload Payload for updating the assistant.\n     * @returns The updated assistant.\n     */\n    async update(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"PATCH\",\n            json: {\n                graph_id: payload.graphId,\n                config: payload.config,\n                context: payload.context,\n                metadata: payload.metadata,\n                name: payload.name,\n                description: payload.description,\n            },\n        });\n    }\n    /**\n     * Delete an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     */\n    async delete(assistantId) {\n        return this.fetch(`/assistants/${assistantId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List assistants.\n     * @param query Query options.\n     * @returns List of assistants.\n     */\n    async search(query) {\n        return this.fetch(\"/assistants/search\", {\n            method: \"POST\",\n            json: {\n                graph_id: query?.graphId ?? undefined,\n                metadata: query?.metadata ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                sort_by: query?.sortBy ?? undefined,\n                sort_order: query?.sortOrder ?? undefined,\n            },\n        });\n    }\n    /**\n     * List all versions of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @returns List of assistant versions.\n     */\n    async getVersions(assistantId, payload) {\n        return this.fetch(`/assistants/${assistantId}/versions`, {\n            method: \"POST\",\n            json: {\n                metadata: payload?.metadata ?? undefined,\n                limit: payload?.limit ?? 10,\n                offset: payload?.offset ?? 0,\n            },\n        });\n    }\n    /**\n     * Change the version of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param version The version to change to.\n     * @returns The updated assistant.\n     */\n    async setLatest(assistantId, version) {\n        return this.fetch(`/assistants/${assistantId}/latest`, {\n            method: \"POST\",\n            json: { version },\n        });\n    }\n}\nexport class ThreadsClient extends BaseClient {\n    /**\n     * Get a thread by ID.\n     *\n     * @param threadId ID of the thread.\n     * @returns The thread.\n     */\n    async get(threadId) {\n        return this.fetch(`/threads/${threadId}`);\n    }\n    /**\n     * Create a new thread.\n     *\n     * @param payload Payload for creating a thread.\n     * @returns The created thread.\n     */\n    async create(payload) {\n        return this.fetch(`/threads`, {\n            method: \"POST\",\n            json: {\n                metadata: {\n                    ...payload?.metadata,\n                    graph_id: payload?.graphId,\n                },\n                thread_id: payload?.threadId,\n                if_exists: payload?.ifExists,\n                supersteps: payload?.supersteps?.map((s) => ({\n                    updates: s.updates.map((u) => ({\n                        values: u.values,\n                        command: u.command,\n                        as_node: u.asNode,\n                    })),\n                })),\n            },\n        });\n    }\n    /**\n     * Copy an existing thread\n     * @param threadId ID of the thread to be copied\n     * @returns Newly copied thread\n     */\n    async copy(threadId) {\n        return this.fetch(`/threads/${threadId}/copy`, {\n            method: \"POST\",\n        });\n    }\n    /**\n     * Update a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param payload Payload for updating the thread.\n     * @returns The updated thread.\n     */\n    async update(threadId, payload) {\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"PATCH\",\n            json: { metadata: payload?.metadata },\n        });\n    }\n    /**\n     * Delete a thread.\n     *\n     * @param threadId ID of the thread.\n     */\n    async delete(threadId) {\n        return this.fetch(`/threads/${threadId}`, {\n            method: \"DELETE\",\n        });\n    }\n    /**\n     * List threads\n     *\n     * @param query Query options\n     * @returns List of threads\n     */\n    async search(query) {\n        return this.fetch(\"/threads/search\", {\n            method: \"POST\",\n            json: {\n                metadata: query?.metadata ?? undefined,\n                limit: query?.limit ?? 10,\n                offset: query?.offset ?? 0,\n                status: query?.status,\n                sort_by: query?.sortBy,\n                sort_order: query?.sortOrder,\n            },\n        });\n    }\n    /**\n     * Get state for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @returns Thread state.\n     */\n    async getState(threadId, checkpoint, options) {\n        if (checkpoint != null) {\n            if (typeof checkpoint !== \"string\") {\n                return this.fetch(`/threads/${threadId}/state/checkpoint`, {\n                    method: \"POST\",\n                    json: { checkpoint, subgraphs: options?.subgraphs },\n                });\n            }\n            // deprecated\n            return this.fetch(`/threads/${threadId}/state/${checkpoint}`, { params: { subgraphs: options?.subgraphs } });\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            params: { subgraphs: options?.subgraphs },\n        });\n    }\n    /**\n     * Add state to a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @returns\n     */\n    async updateState(threadId, options) {\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"POST\",\n            json: {\n                values: options.values,\n                checkpoint_id: options.checkpointId,\n                checkpoint: options.checkpoint,\n                as_node: options?.asNode,\n            },\n        });\n    }\n    /**\n     * Patch the metadata of a thread.\n     *\n     * @param threadIdOrConfig Thread ID or config to patch the state of.\n     * @param metadata Metadata to patch the state with.\n     */\n    async patchState(threadIdOrConfig, metadata) {\n        let threadId;\n        if (typeof threadIdOrConfig !== \"string\") {\n            if (typeof threadIdOrConfig.configurable?.thread_id !== \"string\") {\n                throw new Error(\"Thread ID is required when updating state with a config.\");\n            }\n            threadId = threadIdOrConfig.configurable.thread_id;\n        }\n        else {\n            threadId = threadIdOrConfig;\n        }\n        return this.fetch(`/threads/${threadId}/state`, {\n            method: \"PATCH\",\n            json: { metadata },\n        });\n    }\n    /**\n     * Get all past states for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param options Additional options.\n     * @returns List of thread states.\n     */\n    async getHistory(threadId, options) {\n        return this.fetch(`/threads/${threadId}/history`, {\n            method: \"POST\",\n            json: {\n                limit: options?.limit ?? 10,\n                before: options?.before,\n                metadata: options?.metadata,\n                checkpoint: options?.checkpoint,\n            },\n        });\n    }\n}\nexport class RunsClient extends BaseClient {\n    /**\n     * Create a run and stream the results.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     */\n    async *stream(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            stream_mode: payload?.streamMode,\n            stream_subgraphs: payload?.streamSubgraphs,\n            stream_resumable: payload?.streamResumable,\n            feedback_keys: payload?.feedbackKeys,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            on_completion: payload?.onCompletion,\n            on_disconnect: payload?.onDisconnect,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n        };\n        const endpoint = threadId == null ? `/runs/stream` : `/threads/${threadId}/runs/stream`;\n        const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(endpoint, {\n            method: \"POST\",\n            json,\n            timeoutMs: null,\n            signal: payload?.signal,\n        }));\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata)\n            payload?.onRunCreated?.(runMetadata);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough(BytesLineDecoder())\n            .pipeThrough(SSEDecoder());\n        yield* IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Create a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The created run.\n     */\n    async create(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            stream_mode: payload?.streamMode,\n            stream_subgraphs: payload?.streamSubgraphs,\n            stream_resumable: payload?.streamResumable,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            webhook: payload?.webhook,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            multitask_strategy: payload?.multitaskStrategy,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            langsmith_tracer: payload?._langsmithTracer\n                ? {\n                    project_name: payload?._langsmithTracer?.projectName,\n                    example_id: payload?._langsmithTracer?.exampleId,\n                }\n                : undefined,\n        };\n        const [run, response] = await this.fetch(`/threads/${threadId}/runs`, {\n            method: \"POST\",\n            json,\n            signal: payload?.signal,\n            withResponse: true,\n        });\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata)\n            payload?.onRunCreated?.(runMetadata);\n        return run;\n    }\n    /**\n     * Create a batch of stateless background runs.\n     *\n     * @param payloads An array of payloads for creating runs.\n     * @returns An array of created runs.\n     */\n    async createBatch(payloads) {\n        const filteredPayloads = payloads\n            .map((payload) => ({ ...payload, assistant_id: payload.assistantId }))\n            .map((payload) => {\n            return Object.fromEntries(Object.entries(payload).filter(([_, v]) => v !== undefined));\n        });\n        return this.fetch(\"/runs/batch\", {\n            method: \"POST\",\n            json: filteredPayloads,\n        });\n    }\n    /**\n     * Create a run and wait for it to complete.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The last values chunk of the thread.\n     */\n    async wait(threadId, assistantId, payload) {\n        const json = {\n            input: payload?.input,\n            command: payload?.command,\n            config: payload?.config,\n            context: payload?.context,\n            metadata: payload?.metadata,\n            assistant_id: assistantId,\n            interrupt_before: payload?.interruptBefore,\n            interrupt_after: payload?.interruptAfter,\n            checkpoint: payload?.checkpoint,\n            checkpoint_id: payload?.checkpointId,\n            webhook: payload?.webhook,\n            multitask_strategy: payload?.multitaskStrategy,\n            on_completion: payload?.onCompletion,\n            on_disconnect: payload?.onDisconnect,\n            after_seconds: payload?.afterSeconds,\n            if_not_exists: payload?.ifNotExists,\n            checkpoint_during: payload?.checkpointDuring,\n            langsmith_tracer: payload?._langsmithTracer\n                ? {\n                    project_name: payload?._langsmithTracer?.projectName,\n                    example_id: payload?._langsmithTracer?.exampleId,\n                }\n                : undefined,\n        };\n        const endpoint = threadId == null ? `/runs/wait` : `/threads/${threadId}/runs/wait`;\n        const [run, response] = await this.fetch(endpoint, {\n            method: \"POST\",\n            json,\n            timeoutMs: null,\n            signal: payload?.signal,\n            withResponse: true,\n        });\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata)\n            payload?.onRunCreated?.(runMetadata);\n        const raiseError = payload?.raiseError !== undefined ? payload.raiseError : true;\n        if (raiseError &&\n            \"__error__\" in run &&\n            typeof run.__error__ === \"object\" &&\n            run.__error__ &&\n            \"error\" in run.__error__ &&\n            \"message\" in run.__error__) {\n            throw new Error(`${run.__error__?.error}: ${run.__error__?.message}`);\n        }\n        return run;\n    }\n    /**\n     * List all runs for a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @param options Filtering and pagination options.\n     * @returns List of runs.\n     */\n    async list(threadId, options) {\n        return this.fetch(`/threads/${threadId}/runs`, {\n            params: {\n                limit: options?.limit ?? 10,\n                offset: options?.offset ?? 0,\n                status: options?.status ?? undefined,\n            },\n        });\n    }\n    /**\n     * Get a run by ID.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns The run.\n     */\n    async get(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`);\n    }\n    /**\n     * Cancel a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param wait Whether to block when canceling\n     * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n     * @returns\n     */\n    async cancel(threadId, runId, wait = false, action = \"interrupt\") {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/cancel`, {\n            method: \"POST\",\n            params: {\n                wait: wait ? \"1\" : \"0\",\n                action,\n            },\n        });\n    }\n    /**\n     * Block until a run is done.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async join(threadId, runId, options) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}/join`, {\n            timeoutMs: null,\n            signal: options?.signal,\n        });\n    }\n    /**\n     * Stream output from a run in real-time, until the run is done.\n     *\n     * @param threadId The ID of the thread. Can be set to `null` | `undefined` for stateless runs.\n     * @param runId The ID of the run.\n     * @param options Additional options for controlling the stream behavior:\n     *   - signal: An AbortSignal that can be used to cancel the stream request\n     *   - lastEventId: The ID of the last event received. Can be used to reconnect to a stream without losing events.\n     *   - cancelOnDisconnect: When true, automatically cancels the run if the client disconnects from the stream\n     *   - streamMode: Controls what types of events to receive from the stream (can be a single mode or array of modes)\n     *        Must be a subset of the stream modes passed when creating the run. Background runs default to having the union of all\n     *        stream modes enabled.\n     * @returns An async generator yielding stream parts.\n     */\n    async *joinStream(threadId, runId, options\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        const opts = typeof options === \"object\" &&\n            options != null &&\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            options instanceof AbortSignal\n            ? { signal: options }\n            : options;\n        const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(threadId != null\n            ? `/threads/${threadId}/runs/${runId}/stream`\n            : `/runs/${runId}/stream`, {\n            method: \"GET\",\n            timeoutMs: null,\n            signal: opts?.signal,\n            headers: opts?.lastEventId\n                ? { \"Last-Event-ID\": opts.lastEventId }\n                : undefined,\n            params: {\n                cancel_on_disconnect: opts?.cancelOnDisconnect ? \"1\" : \"0\",\n                stream_mode: opts?.streamMode,\n            },\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const stream = (response.body || new ReadableStream({ start: (ctrl) => ctrl.close() }))\n            .pipeThrough(BytesLineDecoder())\n            .pipeThrough(SSEDecoder());\n        yield* IterableReadableStream.fromReadableStream(stream);\n    }\n    /**\n     * Delete a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    async delete(threadId, runId) {\n        return this.fetch(`/threads/${threadId}/runs/${runId}`, {\n            method: \"DELETE\",\n        });\n    }\n}\nexport class StoreClient extends BaseClient {\n    /**\n     * Store or update an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item within the namespace.\n     * @param value A dictionary containing the item's data.\n     * @param options.index Controls search indexing - null (use defaults), false (disable), or list of field paths to index.\n     * @param options.ttl Optional time-to-live in minutes for the item, or null for no expiration.\n     * @returns Promise<void>\n     *\n     * @example\n     * ```typescript\n     * await client.store.putItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { title: \"My Document\", content: \"Hello World\" },\n     *   { ttl: 60 } // expires in 60 minutes\n     * );\n     * ```\n     */\n    async putItem(namespace, key, value, options) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        const payload = {\n            namespace,\n            key,\n            value,\n            index: options?.index,\n            ttl: options?.ttl,\n        };\n        return this.fetch(\"/store/items\", {\n            method: \"PUT\",\n            json: payload,\n        });\n    }\n    /**\n     * Retrieve a single item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @param options.refreshTtl Whether to refresh the TTL on this read operation. If null, uses the store's default behavior.\n     * @returns Promise<Item>\n     *\n     * @example\n     * ```typescript\n     * const item = await client.store.getItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { refreshTtl: true }\n     * );\n     * console.log(item);\n     * // {\n     * //   namespace: [\"documents\", \"user123\"],\n     * //   key: \"item456\",\n     * //   value: { title: \"My Document\", content: \"Hello World\" },\n     * //   createdAt: \"2024-07-30T12:00:00Z\",\n     * //   updatedAt: \"2024-07-30T12:00:00Z\"\n     * // }\n     * ```\n     */\n    async getItem(namespace, key, options) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        const params = {\n            namespace: namespace.join(\".\"),\n            key,\n        };\n        if (options?.refreshTtl !== undefined) {\n            params.refresh_ttl = options.refreshTtl;\n        }\n        const response = await this.fetch(\"/store/items\", {\n            params,\n        });\n        return response\n            ? {\n                ...response,\n                createdAt: response.created_at,\n                updatedAt: response.updated_at,\n            }\n            : null;\n    }\n    /**\n     * Delete an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @returns Promise<void>\n     */\n    async deleteItem(namespace, key) {\n        namespace.forEach((label) => {\n            if (label.includes(\".\")) {\n                throw new Error(`Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`);\n            }\n        });\n        return this.fetch(\"/store/items\", {\n            method: \"DELETE\",\n            json: { namespace, key },\n        });\n    }\n    /**\n     * Search for items within a namespace prefix.\n     *\n     * @param namespacePrefix List of strings representing the namespace prefix.\n     * @param options.filter Optional dictionary of key-value pairs to filter results.\n     * @param options.limit Maximum number of items to return (default is 10).\n     * @param options.offset Number of items to skip before returning results (default is 0).\n     * @param options.query Optional search query.\n     * @param options.refreshTtl Whether to refresh the TTL on items returned by this search. If null, uses the store's default behavior.\n     * @returns Promise<SearchItemsResponse>\n     *\n     * @example\n     * ```typescript\n     * const results = await client.store.searchItems(\n     *   [\"documents\"],\n     *   {\n     *     filter: { author: \"John Doe\" },\n     *     limit: 5,\n     *     refreshTtl: true\n     *   }\n     * );\n     * console.log(results);\n     * // {\n     * //   items: [\n     * //     {\n     * //       namespace: [\"documents\", \"user123\"],\n     * //       key: \"item789\",\n     * //       value: { title: \"Another Document\", author: \"John Doe\" },\n     * //       createdAt: \"2024-07-30T12:00:00Z\",\n     * //       updatedAt: \"2024-07-30T12:00:00Z\"\n     * //     },\n     * //     // ... additional items ...\n     * //   ]\n     * // }\n     * ```\n     */\n    async searchItems(namespacePrefix, options) {\n        const payload = {\n            namespace_prefix: namespacePrefix,\n            filter: options?.filter,\n            limit: options?.limit ?? 10,\n            offset: options?.offset ?? 0,\n            query: options?.query,\n            refresh_ttl: options?.refreshTtl,\n        };\n        const response = await this.fetch(\"/store/items/search\", {\n            method: \"POST\",\n            json: payload,\n        });\n        return {\n            items: response.items.map((item) => ({\n                ...item,\n                createdAt: item.created_at,\n                updatedAt: item.updated_at,\n            })),\n        };\n    }\n    /**\n     * List namespaces with optional match conditions.\n     *\n     * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n     * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n     * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n     * @param options.limit Maximum number of namespaces to return (default is 100).\n     * @param options.offset Number of namespaces to skip before returning results (default is 0).\n     * @returns Promise<ListNamespaceResponse>\n     */\n    async listNamespaces(options) {\n        const payload = {\n            prefix: options?.prefix,\n            suffix: options?.suffix,\n            max_depth: options?.maxDepth,\n            limit: options?.limit ?? 100,\n            offset: options?.offset ?? 0,\n        };\n        return this.fetch(\"/store/namespaces\", {\n            method: \"POST\",\n            json: payload,\n        });\n    }\n}\nclass UiClient extends BaseClient {\n    static getOrCached(key, fn) {\n        if (UiClient.promiseCache[key] != null) {\n            return UiClient.promiseCache[key];\n        }\n        const promise = fn();\n        UiClient.promiseCache[key] = promise;\n        return promise;\n    }\n    async getComponent(assistantId, agentName) {\n        return UiClient.getOrCached(`${this.apiUrl}-${assistantId}-${agentName}`, async () => {\n            const response = await this.asyncCaller.fetch(...this.prepareFetchOptions(`/ui/${assistantId}`, {\n                headers: {\n                    Accept: \"text/html\",\n                    \"Content-Type\": \"application/json\",\n                },\n                method: \"POST\",\n                json: { name: agentName },\n            }));\n            return response.text();\n        });\n    }\n}\nObject.defineProperty(UiClient, \"promiseCache\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {}\n});\nexport class Client {\n    constructor(config) {\n        /**\n         * The client for interacting with assistants.\n         */\n        Object.defineProperty(this, \"assistants\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with threads.\n         */\n        Object.defineProperty(this, \"threads\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with runs.\n         */\n        Object.defineProperty(this, \"runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with cron runs.\n         */\n        Object.defineProperty(this, \"crons\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with the KV store.\n         */\n        Object.defineProperty(this, \"store\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * The client for interacting with the UI.\n         * @internal Used by LoadExternalComponent and the API might change in the future.\n         */\n        Object.defineProperty(this, \"~ui\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * @internal Used to obtain a stable key representing the client.\n         */\n        Object.defineProperty(this, \"~configHash\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this[\"~configHash\"] = (() => JSON.stringify({\n            apiUrl: config?.apiUrl,\n            apiKey: config?.apiKey,\n            timeoutMs: config?.timeoutMs,\n            defaultHeaders: config?.defaultHeaders,\n            maxConcurrency: config?.callerOptions?.maxConcurrency,\n            maxRetries: config?.callerOptions?.maxRetries,\n            callbacks: {\n                onFailedResponseHook: config?.callerOptions?.onFailedResponseHook != null,\n                onRequest: config?.onRequest != null,\n                fetch: config?.callerOptions?.fetch != null,\n            },\n        }))();\n        this.assistants = new AssistantsClient(config);\n        this.threads = new ThreadsClient(config);\n        this.runs = new RunsClient(config);\n        this.crons = new CronsClient(config);\n        this.store = new StoreClient(config);\n        this[\"~ui\"] = new UiClient(config);\n    }\n}\n/**\n * @internal Used to obtain a stable key representing the client.\n */\nexport function getClientConfigHash(client) {\n    return client[\"~configHash\"];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}