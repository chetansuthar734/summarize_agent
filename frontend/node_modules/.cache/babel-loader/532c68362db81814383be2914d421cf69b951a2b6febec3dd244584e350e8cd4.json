{"ast":null,"code":"import { RunTree, convertToDottedOrderFormat } from \"langsmith/run_trees\";\nimport { BaseCallbackHandler } from \"../callbacks/base.js\";\nimport { getRuntimeEnvironmentSync } from \"../utils/env.js\";\n// TODO: Remove and just use base LangSmith Run type\nconst convertRunTreeToRun = runTree => {\n  if (!runTree) {\n    return undefined;\n  }\n  // Important that we return the raw run tree object since the reference\n  // is mutated in other places.\n  // TODO: Remove places where this is being done.\n  // eslint-disable-next-line no-param-reassign\n  runTree.events = runTree.events ?? [];\n  // eslint-disable-next-line no-param-reassign\n  runTree.child_runs = runTree.child_runs ?? [];\n  // TODO: Remove this cast and just use the LangSmith RunTree type.\n  return runTree;\n};\nfunction convertRunToRunTree(run, parentRun) {\n  if (!run) {\n    return undefined;\n  }\n  return new RunTree({\n    ...run,\n    start_time: run._serialized_start_time ?? run.start_time,\n    parent_run: convertRunToRunTree(parentRun),\n    child_runs: run.child_runs.map(r => convertRunToRunTree(r)).filter(r => r !== undefined),\n    extra: {\n      ...run.extra,\n      runtime: getRuntimeEnvironmentSync()\n    },\n    tracingEnabled: false\n  });\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n  return value && !Array.isArray(value) && typeof value === \"object\" ? value : {\n    [defaultKey]: value\n  };\n}\nexport function isBaseTracer(x) {\n  return typeof x._addRunToRunMap === \"function\";\n}\nexport class BaseTracer extends BaseCallbackHandler {\n  constructor(_fields) {\n    super(...arguments);\n    /** @deprecated Use `runTreeMap` instead. */\n    Object.defineProperty(this, \"runMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, \"runTreeMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, \"usesRunTreeMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n  copy() {\n    return this;\n  }\n  getRunById(runId) {\n    if (runId === undefined) {\n      return undefined;\n    }\n    return this.usesRunTreeMap ? convertRunTreeToRun(this.runTreeMap.get(runId)) : this.runMap.get(runId);\n  }\n  stringifyError(error) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (error instanceof Error) {\n      return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n    }\n    if (typeof error === \"string\") {\n      return error;\n    }\n    return `${error}`;\n  }\n  _addChildRun(parentRun, childRun) {\n    parentRun.child_runs.push(childRun);\n  }\n  _addRunToRunMap(run) {\n    const {\n      dottedOrder: currentDottedOrder,\n      microsecondPrecisionDatestring\n    } = convertToDottedOrderFormat(new Date(run.start_time).getTime(), run.id, run.execution_order);\n    const storedRun = {\n      ...run\n    };\n    const parentRun = this.getRunById(storedRun.parent_run_id);\n    if (storedRun.parent_run_id !== undefined) {\n      if (parentRun) {\n        this._addChildRun(parentRun, storedRun);\n        parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);\n        storedRun.trace_id = parentRun.trace_id;\n        if (parentRun.dotted_order !== undefined) {\n          storedRun.dotted_order = [parentRun.dotted_order, currentDottedOrder].join(\".\");\n          storedRun._serialized_start_time = microsecondPrecisionDatestring;\n        } else {\n          // This can happen naturally for callbacks added within a run\n          // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n        }\n      } else {\n        // This can happen naturally for callbacks added within a run\n        // console.debug(\n        //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n        // );\n      }\n    } else {\n      storedRun.trace_id = storedRun.id;\n      storedRun.dotted_order = currentDottedOrder;\n      storedRun._serialized_start_time = microsecondPrecisionDatestring;\n    }\n    if (this.usesRunTreeMap) {\n      const runTree = convertRunToRunTree(storedRun, parentRun);\n      if (runTree !== undefined) {\n        this.runTreeMap.set(storedRun.id, runTree);\n      }\n    } else {\n      this.runMap.set(storedRun.id, storedRun);\n    }\n    return storedRun;\n  }\n  async _endTrace(run) {\n    const parentRun = run.parent_run_id !== undefined && this.getRunById(run.parent_run_id);\n    if (parentRun) {\n      parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n    } else {\n      await this.persistRun(run);\n    }\n    await this.onRunUpdate?.(run);\n    if (this.usesRunTreeMap) {\n      this.runTreeMap.delete(run.id);\n    } else {\n      this.runMap.delete(run.id);\n    }\n  }\n  _getExecutionOrder(parentRunId) {\n    const parentRun = parentRunId !== undefined && this.getRunById(parentRunId);\n    // If a run has no parent then execution order is 1\n    if (!parentRun) {\n      return 1;\n    }\n    return parentRun.child_execution_order + 1;\n  }\n  /**\n   * Create and add a run to the run map for LLM start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata ? {\n      ...extraParams,\n      metadata\n    } : extraParams;\n    const run = {\n      id: runId,\n      name: name ?? llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [{\n        name: \"start\",\n        time: new Date(start_time).toISOString()\n      }],\n      inputs: {\n        prompts\n      },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams ?? {},\n      tags: tags || []\n    };\n    return this._addRunToRunMap(run);\n  }\n  async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n    const run = this.getRunById(runId) ?? this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);\n    await this.onRunCreate?.(run);\n    await this.onLLMStart?.(run);\n    return run;\n  }\n  /**\n   * Create and add a run to the run map for chat model start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata ? {\n      ...extraParams,\n      metadata\n    } : extraParams;\n    const run = {\n      id: runId,\n      name: name ?? llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [{\n        name: \"start\",\n        time: new Date(start_time).toISOString()\n      }],\n      inputs: {\n        messages\n      },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams ?? {},\n      tags: tags || []\n    };\n    return this._addRunToRunMap(run);\n  }\n  async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n    const run = this.getRunById(runId) ?? this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);\n    await this.onRunCreate?.(run);\n    await this.onLLMStart?.(run);\n    return run;\n  }\n  async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = output;\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString()\n    });\n    run.extra = {\n      ...run.extra,\n      ...extraParams\n    };\n    await this.onLLMEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n  async handleLLMError(error, runId, _parentRunId, _tags, extraParams) {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString()\n    });\n    run.extra = {\n      ...run.extra,\n      ...extraParams\n    };\n    await this.onLLMError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n  /**\n   * Create and add a run to the run map for chain start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run = {\n      id: runId,\n      name: name ?? chain.id[chain.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: chain,\n      events: [{\n        name: \"start\",\n        time: new Date(start_time).toISOString()\n      }],\n      inputs,\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: runType ?? \"chain\",\n      child_runs: [],\n      extra: metadata ? {\n        metadata\n      } : {},\n      tags: tags || []\n    };\n    return this._addRunToRunMap(run);\n  }\n  async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n    const run = this.getRunById(runId) ?? this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);\n    await this.onRunCreate?.(run);\n    await this.onChainStart?.(run);\n    return run;\n  }\n  async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {\n    const run = this.getRunById(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = _coerceToDict(outputs, \"output\");\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString()\n    });\n    if (kwargs?.inputs !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await this.onChainEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n  async handleChainError(error, runId, _parentRunId, _tags, kwargs) {\n    const run = this.getRunById(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString()\n    });\n    if (kwargs?.inputs !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await this.onChainError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n  /**\n   * Create and add a run to the run map for tool start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run = {\n      id: runId,\n      name: name ?? tool.id[tool.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: tool,\n      events: [{\n        name: \"start\",\n        time: new Date(start_time).toISOString()\n      }],\n      inputs: {\n        input\n      },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"tool\",\n      child_runs: [],\n      extra: metadata ? {\n        metadata\n      } : {},\n      tags: tags || []\n    };\n    return this._addRunToRunMap(run);\n  }\n  async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n    const run = this.getRunById(runId) ?? this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);\n    await this.onRunCreate?.(run);\n    await this.onToolStart?.(run);\n    return run;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleToolEnd(output, runId) {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = {\n      output\n    };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString()\n    });\n    await this.onToolEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n  async handleToolError(error, runId) {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString()\n    });\n    await this.onToolError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n  async handleAgentAction(action, runId) {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    const agentRun = run;\n    agentRun.actions = agentRun.actions || [];\n    agentRun.actions.push(action);\n    agentRun.events.push({\n      name: \"agent_action\",\n      time: new Date().toISOString(),\n      kwargs: {\n        action\n      }\n    });\n    await this.onAgentAction?.(run);\n  }\n  async handleAgentEnd(action, runId) {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"agent_end\",\n      time: new Date().toISOString(),\n      kwargs: {\n        action\n      }\n    });\n    await this.onAgentEnd?.(run);\n  }\n  /**\n   * Create and add a run to the run map for retriever start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run = {\n      id: runId,\n      name: name ?? retriever.id[retriever.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: retriever,\n      events: [{\n        name: \"start\",\n        time: new Date(start_time).toISOString()\n      }],\n      inputs: {\n        query\n      },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"retriever\",\n      child_runs: [],\n      extra: metadata ? {\n        metadata\n      } : {},\n      tags: tags || []\n    };\n    return this._addRunToRunMap(run);\n  }\n  async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n    const run = this.getRunById(runId) ?? this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);\n    await this.onRunCreate?.(run);\n    await this.onRetrieverStart?.(run);\n    return run;\n  }\n  async handleRetrieverEnd(documents, runId) {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = {\n      documents\n    };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString()\n    });\n    await this.onRetrieverEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n  async handleRetrieverError(error, runId) {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString()\n    });\n    await this.onRetrieverError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n  async handleText(text, runId) {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"text\",\n      time: new Date().toISOString(),\n      kwargs: {\n        text\n      }\n    });\n    await this.onText?.(run);\n  }\n  async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(`Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`);\n    }\n    run.events.push({\n      name: \"new_token\",\n      time: new Date().toISOString(),\n      kwargs: {\n        token,\n        idx,\n        chunk: fields?.chunk\n      }\n    });\n    await this.onLLMNewToken?.(run, token, {\n      chunk: fields?.chunk\n    });\n    return run;\n  }\n}","map":{"version":3,"names":["RunTree","convertToDottedOrderFormat","BaseCallbackHandler","getRuntimeEnvironmentSync","convertRunTreeToRun","runTree","undefined","events","child_runs","convertRunToRunTree","run","parentRun","start_time","_serialized_start_time","parent_run","map","r","filter","extra","runtime","tracingEnabled","_coerceToDict","value","defaultKey","Array","isArray","isBaseTracer","x","_addRunToRunMap","BaseTracer","constructor","_fields","arguments","Object","defineProperty","enumerable","configurable","writable","Map","copy","getRunById","runId","usesRunTreeMap","runTreeMap","get","runMap","stringifyError","error","Error","message","stack","_addChildRun","childRun","push","dottedOrder","currentDottedOrder","microsecondPrecisionDatestring","Date","getTime","id","execution_order","storedRun","parent_run_id","child_execution_order","Math","max","trace_id","dotted_order","join","set","_endTrace","persistRun","onRunUpdate","delete","_getExecutionOrder","parentRunId","_createRunForLLMStart","llm","prompts","extraParams","tags","metadata","name","now","finalExtraParams","length","serialized","time","toISOString","inputs","run_type","handleLLMStart","onRunCreate","onLLMStart","_createRunForChatModelStart","messages","handleChatModelStart","handleLLMEnd","output","_parentRunId","_tags","end_time","outputs","onLLMEnd","handleLLMError","onLLMError","_createRunForChainStart","chain","runType","handleChainStart","onChainStart","handleChainEnd","kwargs","onChainEnd","handleChainError","onChainError","_createRunForToolStart","tool","input","handleToolStart","onToolStart","handleToolEnd","onToolEnd","handleToolError","onToolError","handleAgentAction","action","agentRun","actions","onAgentAction","handleAgentEnd","onAgentEnd","_createRunForRetrieverStart","retriever","query","handleRetrieverStart","onRetrieverStart","handleRetrieverEnd","documents","onRetrieverEnd","handleRetrieverError","onRetrieverError","handleText","text","onText","handleLLMNewToken","token","idx","fields","chunk","onLLMNewToken"],"sources":["/Users/chetan/Desktop/summarize_agent/frontend/node_modules/@langchain/core/dist/tracers/base.js"],"sourcesContent":["import { RunTree, convertToDottedOrderFormat } from \"langsmith/run_trees\";\nimport { BaseCallbackHandler, } from \"../callbacks/base.js\";\nimport { getRuntimeEnvironmentSync } from \"../utils/env.js\";\n// TODO: Remove and just use base LangSmith Run type\nconst convertRunTreeToRun = (runTree) => {\n    if (!runTree) {\n        return undefined;\n    }\n    // Important that we return the raw run tree object since the reference\n    // is mutated in other places.\n    // TODO: Remove places where this is being done.\n    // eslint-disable-next-line no-param-reassign\n    runTree.events = runTree.events ?? [];\n    // eslint-disable-next-line no-param-reassign\n    runTree.child_runs = runTree.child_runs ?? [];\n    // TODO: Remove this cast and just use the LangSmith RunTree type.\n    return runTree;\n};\nfunction convertRunToRunTree(run, parentRun) {\n    if (!run) {\n        return undefined;\n    }\n    return new RunTree({\n        ...run,\n        start_time: run._serialized_start_time ?? run.start_time,\n        parent_run: convertRunToRunTree(parentRun),\n        child_runs: run.child_runs\n            .map((r) => convertRunToRunTree(r))\n            .filter((r) => r !== undefined),\n        extra: {\n            ...run.extra,\n            runtime: getRuntimeEnvironmentSync(),\n        },\n        tracingEnabled: false,\n    });\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\nexport function isBaseTracer(x) {\n    return typeof x._addRunToRunMap === \"function\";\n}\nexport class BaseTracer extends BaseCallbackHandler {\n    constructor(_fields) {\n        super(...arguments);\n        /** @deprecated Use `runTreeMap` instead. */\n        Object.defineProperty(this, \"runMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"runTreeMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"usesRunTreeMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    copy() {\n        return this;\n    }\n    getRunById(runId) {\n        if (runId === undefined) {\n            return undefined;\n        }\n        return this.usesRunTreeMap\n            ? convertRunTreeToRun(this.runTreeMap.get(runId))\n            : this.runMap.get(runId);\n    }\n    stringifyError(error) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (error instanceof Error) {\n            return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n        }\n        if (typeof error === \"string\") {\n            return error;\n        }\n        return `${error}`;\n    }\n    _addChildRun(parentRun, childRun) {\n        parentRun.child_runs.push(childRun);\n    }\n    _addRunToRunMap(run) {\n        const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } = convertToDottedOrderFormat(new Date(run.start_time).getTime(), run.id, run.execution_order);\n        const storedRun = { ...run };\n        const parentRun = this.getRunById(storedRun.parent_run_id);\n        if (storedRun.parent_run_id !== undefined) {\n            if (parentRun) {\n                this._addChildRun(parentRun, storedRun);\n                parentRun.child_execution_order = Math.max(parentRun.child_execution_order, storedRun.child_execution_order);\n                storedRun.trace_id = parentRun.trace_id;\n                if (parentRun.dotted_order !== undefined) {\n                    storedRun.dotted_order = [\n                        parentRun.dotted_order,\n                        currentDottedOrder,\n                    ].join(\".\");\n                    storedRun._serialized_start_time = microsecondPrecisionDatestring;\n                }\n                else {\n                    // This can happen naturally for callbacks added within a run\n                    // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n                }\n            }\n            else {\n                // This can happen naturally for callbacks added within a run\n                // console.debug(\n                //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n                // );\n            }\n        }\n        else {\n            storedRun.trace_id = storedRun.id;\n            storedRun.dotted_order = currentDottedOrder;\n            storedRun._serialized_start_time = microsecondPrecisionDatestring;\n        }\n        if (this.usesRunTreeMap) {\n            const runTree = convertRunToRunTree(storedRun, parentRun);\n            if (runTree !== undefined) {\n                this.runTreeMap.set(storedRun.id, runTree);\n            }\n        }\n        else {\n            this.runMap.set(storedRun.id, storedRun);\n        }\n        return storedRun;\n    }\n    async _endTrace(run) {\n        const parentRun = run.parent_run_id !== undefined && this.getRunById(run.parent_run_id);\n        if (parentRun) {\n            parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n        }\n        else {\n            await this.persistRun(run);\n        }\n        await this.onRunUpdate?.(run);\n        if (this.usesRunTreeMap) {\n            this.runTreeMap.delete(run.id);\n        }\n        else {\n            this.runMap.delete(run.id);\n        }\n    }\n    _getExecutionOrder(parentRunId) {\n        const parentRun = parentRunId !== undefined && this.getRunById(parentRunId);\n        // If a run has no parent then execution order is 1\n        if (!parentRun) {\n            return 1;\n        }\n        return parentRun.child_execution_order + 1;\n    }\n    /**\n     * Create and add a run to the run map for LLM start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { prompts },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for chat model start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: name ?? llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { messages },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onLLMStart?.(run);\n        return run;\n    }\n    async handleLLMEnd(output, runId, _parentRunId, _tags, extraParams) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = output;\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        run.extra = { ...run.extra, ...extraParams };\n        await this.onLLMEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleLLMError(error, runId, _parentRunId, _tags, extraParams) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        run.extra = { ...run.extra, ...extraParams };\n        await this.onLLMError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for chain start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? chain.id[chain.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: chain,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs,\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: runType ?? \"chain\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name);\n        await this.onRunCreate?.(run);\n        await this.onChainStart?.(run);\n        return run;\n    }\n    async handleChainEnd(outputs, runId, _parentRunId, _tags, kwargs) {\n        const run = this.getRunById(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = _coerceToDict(outputs, \"output\");\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleChainError(error, runId, _parentRunId, _tags, kwargs) {\n        const run = this.getRunById(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        if (kwargs?.inputs !== undefined) {\n            run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n        }\n        await this.onChainError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    /**\n     * Create and add a run to the run map for tool start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? tool.id[tool.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: tool,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { input },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"tool\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForToolStart(tool, input, runId, parentRunId, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onToolStart?.(run);\n        return run;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleToolEnd(output, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { output };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleToolError(error, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onToolError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleAgentAction(action, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        const agentRun = run;\n        agentRun.actions = agentRun.actions || [];\n        agentRun.actions.push(action);\n        agentRun.events.push({\n            name: \"agent_action\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentAction?.(run);\n    }\n    async handleAgentEnd(action, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"agent_end\",\n            time: new Date().toISOString(),\n            kwargs: { action },\n        });\n        await this.onAgentEnd?.(run);\n    }\n    /**\n     * Create and add a run to the run map for retriever start events.\n     * This must sometimes be done synchronously to avoid race conditions\n     * when callbacks are backgrounded, so we expose it as a separate method here.\n     */\n    _createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: name ?? retriever.id[retriever.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: retriever,\n            events: [\n                {\n                    name: \"start\",\n                    time: new Date(start_time).toISOString(),\n                },\n            ],\n            inputs: { query },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"retriever\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        return this._addRunToRunMap(run);\n    }\n    async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {\n        const run = this.getRunById(runId) ??\n            this._createRunForRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name);\n        await this.onRunCreate?.(run);\n        await this.onRetrieverStart?.(run);\n        return run;\n    }\n    async handleRetrieverEnd(documents, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { documents };\n        run.events.push({\n            name: \"end\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverEnd?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleRetrieverError(error, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = this.stringifyError(error);\n        run.events.push({\n            name: \"error\",\n            time: new Date(run.end_time).toISOString(),\n        });\n        await this.onRetrieverError?.(run);\n        await this._endTrace(run);\n        return run;\n    }\n    async handleText(text, runId) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"text\",\n            time: new Date().toISOString(),\n            kwargs: { text },\n        });\n        await this.onText?.(run);\n    }\n    async handleLLMNewToken(token, idx, runId, _parentRunId, _tags, fields) {\n        const run = this.getRunById(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(`Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`);\n        }\n        run.events.push({\n            name: \"new_token\",\n            time: new Date().toISOString(),\n            kwargs: { token, idx, chunk: fields?.chunk },\n        });\n        await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n        return run;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}