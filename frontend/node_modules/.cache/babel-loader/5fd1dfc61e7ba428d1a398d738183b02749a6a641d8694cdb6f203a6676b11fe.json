{"ast":null,"code":"/* __LC_ALLOW_ENTRYPOINT_SIDE_EFFECTS__ */\n\"use client\";\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { coerceMessageLikeToMessage, convertToChunk, isBaseMessageChunk } from \"@langchain/core/messages\";\nimport { Client, getClientConfigHash } from \"../client.js\";\nclass StreamError extends Error {\n  constructor(data) {\n    super(data.message);\n    this.name = data.name ?? data.error ?? \"StreamError\";\n  }\n  static isStructuredError(error) {\n    return typeof error === \"object\" && error != null && \"message\" in error;\n  }\n}\nfunction tryConvertToChunk(message) {\n  try {\n    return convertToChunk(message);\n  } catch {\n    return null;\n  }\n}\nclass MessageTupleManager {\n  constructor() {\n    Object.defineProperty(this, \"chunks\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    this.chunks = {};\n  }\n  add(serialized, metadata) {\n    // TODO: this is sometimes sent from the API\n    // figure out how to prevent this or move this to LC.js\n    if (serialized.type.endsWith(\"MessageChunk\")) {\n      // eslint-disable-next-line no-param-reassign\n      serialized.type = serialized.type.slice(0, -\"MessageChunk\".length).toLowerCase();\n    }\n    const message = coerceMessageLikeToMessage(serialized);\n    const chunk = tryConvertToChunk(message);\n    const {\n      id\n    } = chunk ?? message;\n    if (!id) {\n      console.warn(\"No message ID found for chunk, ignoring in state\", serialized);\n      return null;\n    }\n    this.chunks[id] ??= {};\n    this.chunks[id].metadata = metadata ?? this.chunks[id].metadata;\n    if (chunk) {\n      const prev = this.chunks[id].chunk;\n      this.chunks[id].chunk = (isBaseMessageChunk(prev) ? prev : null)?.concat(chunk) ?? chunk;\n    } else {\n      this.chunks[id].chunk = message;\n    }\n    return id;\n  }\n  clear() {\n    this.chunks = {};\n  }\n  get(id, defaultIndex) {\n    if (this.chunks[id] == null) return null;\n    if (defaultIndex != null) this.chunks[id].index ??= defaultIndex;\n    return this.chunks[id];\n  }\n}\nconst toMessageDict = chunk => {\n  const {\n    type,\n    data\n  } = chunk.toDict();\n  return {\n    ...data,\n    type\n  };\n};\nfunction unique(array) {\n  return [...new Set(array)];\n}\nfunction findLastIndex(array, predicate) {\n  for (let i = array.length - 1; i >= 0; i -= 1) {\n    if (predicate(array[i])) return i;\n  }\n  return -1;\n}\nfunction getBranchSequence(history) {\n  const childrenMap = {};\n  // Short circuit if there's only a singular one state\n  // TODO: I think we can make this more generalizable for all `fetchStateHistory` values.\n  if (history.length <= 1) {\n    return {\n      rootSequence: {\n        type: \"sequence\",\n        items: history.map(value => ({\n          type: \"node\",\n          value,\n          path: []\n        }))\n      },\n      paths: []\n    };\n  }\n  // First pass - collect nodes for each checkpoint\n  history.forEach(state => {\n    const checkpointId = state.parent_checkpoint?.checkpoint_id ?? \"$\";\n    childrenMap[checkpointId] ??= [];\n    childrenMap[checkpointId].push(state);\n  });\n  const rootSequence = {\n    type: \"sequence\",\n    items: []\n  };\n  const queue = [{\n    id: \"$\",\n    sequence: rootSequence,\n    path: []\n  }];\n  const paths = [];\n  const visited = new Set();\n  while (queue.length > 0) {\n    const task = queue.shift();\n    if (visited.has(task.id)) continue;\n    visited.add(task.id);\n    const children = childrenMap[task.id];\n    if (children == null || children.length === 0) continue;\n    // If we've encountered a fork (2+ children), push the fork\n    // to the sequence and add a new sequence for each child\n    let fork;\n    if (children.length > 1) {\n      fork = {\n        type: \"fork\",\n        items: []\n      };\n      task.sequence.items.push(fork);\n    }\n    for (const value of children) {\n      const id = value.checkpoint?.checkpoint_id;\n      if (id == null) continue;\n      let {\n        sequence\n      } = task;\n      let {\n        path\n      } = task;\n      if (fork != null) {\n        sequence = {\n          type: \"sequence\",\n          items: []\n        };\n        fork.items.unshift(sequence);\n        path = path.slice();\n        path.push(id);\n        paths.push(path);\n      }\n      sequence.items.push({\n        type: \"node\",\n        value,\n        path\n      });\n      queue.push({\n        id,\n        sequence,\n        path\n      });\n    }\n  }\n  return {\n    rootSequence,\n    paths\n  };\n}\nconst PATH_SEP = \">\";\nconst ROOT_ID = \"$\";\n// Get flat view\nfunction getBranchView(sequence, paths, branch) {\n  const path = branch.split(PATH_SEP);\n  const pathMap = {};\n  for (const path of paths) {\n    const parent = path.at(-2) ?? ROOT_ID;\n    pathMap[parent] ??= [];\n    pathMap[parent].unshift(path);\n  }\n  const history = [];\n  const branchByCheckpoint = {};\n  const forkStack = path.slice();\n  const queue = [...sequence.items];\n  while (queue.length > 0) {\n    const item = queue.shift();\n    if (item.type === \"node\") {\n      history.push(item.value);\n      const checkpointId = item.value.checkpoint?.checkpoint_id;\n      if (checkpointId == null) continue;\n      branchByCheckpoint[checkpointId] = {\n        branch: item.path.join(PATH_SEP),\n        branchOptions: (item.path.length > 0 ? pathMap[item.path.at(-2) ?? ROOT_ID] ?? [] : []).map(p => p.join(PATH_SEP))\n      };\n    }\n    if (item.type === \"fork\") {\n      const forkId = forkStack.shift();\n      const index = forkId != null ? item.items.findIndex(value => {\n        const firstItem = value.items.at(0);\n        if (!firstItem || firstItem.type !== \"node\") return false;\n        return firstItem.value.checkpoint?.checkpoint_id === forkId;\n      }) : -1;\n      const nextItems = item.items.at(index)?.items ?? [];\n      queue.push(...nextItems);\n    }\n  }\n  return {\n    history,\n    branchByCheckpoint\n  };\n}\nfunction fetchHistory(client, threadId, options) {\n  if (options?.limit === false) {\n    return client.threads.getState(threadId).then(state => {\n      if (state.checkpoint == null) return [];\n      return [state];\n    });\n  }\n  const limit = typeof options?.limit === \"number\" ? options.limit : 1000;\n  return client.threads.getHistory(threadId, {\n    limit\n  });\n}\nfunction useThreadHistory(threadId, client, limit, clearCallbackRef, submittingRef, onErrorRef) {\n  const [history, setHistory] = useState(undefined);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(undefined);\n  const clientHash = getClientConfigHash(client);\n  const clientRef = useRef(client);\n  clientRef.current = client;\n  const fetcher = useCallback(threadId => {\n    if (threadId != null) {\n      const client = clientRef.current;\n      setIsLoading(true);\n      return fetchHistory(client, threadId, {\n        limit\n      }).then(history => {\n        setHistory(history);\n        return history;\n      }, error => {\n        setError(error);\n        onErrorRef.current?.(error);\n        return Promise.reject(error);\n      }).finally(() => {\n        setIsLoading(false);\n      });\n    }\n    setHistory(undefined);\n    setError(undefined);\n    setIsLoading(false);\n    clearCallbackRef.current?.();\n    return Promise.resolve([]);\n  }, [clearCallbackRef, onErrorRef, limit]);\n  useEffect(() => {\n    if (submittingRef.current) return;\n    void fetcher(threadId);\n  }, [fetcher, clientHash, limit, submittingRef, threadId]);\n  return {\n    data: history,\n    isLoading,\n    error,\n    mutate: mutateId => fetcher(mutateId ?? threadId)\n  };\n}\nconst useControllableThreadId = options => {\n  const [localThreadId, _setLocalThreadId] = useState(options?.threadId ?? null);\n  const onThreadIdRef = useRef(options?.onThreadId);\n  onThreadIdRef.current = options?.onThreadId;\n  const onThreadId = useCallback(threadId => {\n    _setLocalThreadId(threadId);\n    onThreadIdRef.current?.(threadId);\n  }, []);\n  if (!options || !(\"threadId\" in options)) {\n    return [localThreadId, onThreadId];\n  }\n  return [options.threadId ?? null, onThreadId];\n};\nfunction useStreamValuesState() {\n  const [values, setValues] = useState(null);\n  const setStreamValues = useCallback((values, kind = \"stream\") => {\n    if (typeof values === \"function\") {\n      setValues(prevTuple => {\n        const [prevValues, prevKind] = prevTuple ?? [null, \"stream\"];\n        const next = values(prevValues, prevKind);\n        if (next == null) return null;\n        return [next, kind];\n      });\n      return;\n    }\n    if (values == null) setValues(null);\n    setValues([values, kind]);\n  }, []);\n  const mutate = useCallback((kind, serverValues) => update => {\n    setStreamValues(clientValues => {\n      const prev = {\n        ...serverValues,\n        ...clientValues\n      };\n      const next = typeof update === \"function\" ? update(prev) : update;\n      return {\n        ...prev,\n        ...next\n      };\n    }, kind);\n  }, [setStreamValues]);\n  return [values?.[0] ?? null, setStreamValues, mutate];\n}\nexport function useStream(options) {\n  let {\n    messagesKey\n  } = options;\n  const {\n    assistantId,\n    fetchStateHistory\n  } = options;\n  const {\n    onCreated,\n    onError,\n    onFinish\n  } = options;\n  const reconnectOnMountRef = useRef(options.reconnectOnMount);\n  const runMetadataStorage = useMemo(() => {\n    if (typeof window === \"undefined\") return null;\n    const storage = reconnectOnMountRef.current;\n    if (storage === true) return window.sessionStorage;\n    if (typeof storage === \"function\") return storage();\n    return null;\n  }, []);\n  messagesKey ??= \"messages\";\n  const client = useMemo(() => options.client ?? new Client({\n    apiUrl: options.apiUrl,\n    apiKey: options.apiKey,\n    callerOptions: options.callerOptions,\n    defaultHeaders: options.defaultHeaders\n  }), [options.client, options.apiKey, options.apiUrl, options.callerOptions, options.defaultHeaders]);\n  const [threadId, onThreadId] = useControllableThreadId(options);\n  const [branch, setBranch] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [streamError, setStreamError] = useState(undefined);\n  const [streamValues, setStreamValues, getMutateFn] = useStreamValuesState();\n  const messageManagerRef = useRef(new MessageTupleManager());\n  const submittingRef = useRef(false);\n  const abortRef = useRef(null);\n  const trackStreamModeRef = useRef([]);\n  const trackStreamMode = useCallback((...mode) => {\n    for (const m of mode) {\n      if (!trackStreamModeRef.current.includes(m)) {\n        trackStreamModeRef.current.push(m);\n      }\n    }\n  }, []);\n  const hasUpdateListener = options.onUpdateEvent != null;\n  const hasCustomListener = options.onCustomEvent != null;\n  const hasLangChainListener = options.onLangChainEvent != null;\n  const hasDebugListener = options.onDebugEvent != null;\n  const hasCheckpointListener = options.onCheckpointEvent != null;\n  const hasTaskListener = options.onTaskEvent != null;\n  const callbackStreamMode = useMemo(() => {\n    const modes = [];\n    if (hasUpdateListener) modes.push(\"updates\");\n    if (hasCustomListener) modes.push(\"custom\");\n    if (hasLangChainListener) modes.push(\"events\");\n    if (hasDebugListener) modes.push(\"debug\");\n    if (hasCheckpointListener) modes.push(\"checkpoints\");\n    if (hasTaskListener) modes.push(\"tasks\");\n    return modes;\n  }, [hasUpdateListener, hasCustomListener, hasLangChainListener, hasDebugListener, hasCheckpointListener, hasTaskListener]);\n  const clearCallbackRef = useRef(null);\n  clearCallbackRef.current = () => {\n    setStreamError(undefined);\n    setStreamValues(null);\n    messageManagerRef.current.clear();\n  };\n  const onErrorRef = useRef(undefined);\n  onErrorRef.current = options.onError;\n  const historyLimit = typeof fetchStateHistory === \"object\" && fetchStateHistory != null ? fetchStateHistory.limit ?? true : fetchStateHistory ?? true;\n  const history = useThreadHistory(threadId, client, historyLimit, clearCallbackRef, submittingRef, onErrorRef);\n  const getMessages = useMemo(() => {\n    return value => Array.isArray(value[messagesKey]) ? value[messagesKey] : [];\n  }, [messagesKey]);\n  const {\n    rootSequence,\n    paths\n  } = getBranchSequence(history.data ?? []);\n  const {\n    history: flatHistory,\n    branchByCheckpoint\n  } = getBranchView(rootSequence, paths, branch);\n  const threadHead = flatHistory.at(-1);\n  const historyValues = threadHead?.values ?? options.initialValues ?? {};\n  const historyValueError = (() => {\n    const error = threadHead?.tasks?.at(-1)?.error;\n    if (error == null) return undefined;\n    try {\n      const parsed = JSON.parse(error);\n      if (StreamError.isStructuredError(parsed)) {\n        return new StreamError(parsed);\n      }\n      return parsed;\n    } catch {\n      // do nothing\n    }\n    return error;\n  })();\n  const messageMetadata = (() => {\n    const alreadyShown = new Set();\n    return getMessages(historyValues).map((message, idx) => {\n      const messageId = message.id ?? idx;\n      const streamMetadata = message.id != null ? messageManagerRef.current.get(message.id)?.metadata ?? undefined : undefined;\n      const firstSeenIdx = findLastIndex(history.data ?? [], state => getMessages(state.values).map((m, idx) => m.id ?? idx).includes(messageId));\n      const firstSeen = history.data?.[firstSeenIdx];\n      const checkpointId = firstSeen?.checkpoint?.checkpoint_id;\n      let branch = firstSeen && checkpointId != null ? branchByCheckpoint[checkpointId] : undefined;\n      if (!branch?.branch?.length) branch = undefined;\n      // serialize branches\n      const optionsShown = branch?.branchOptions?.flat(2).join(\",\");\n      if (optionsShown) {\n        if (alreadyShown.has(optionsShown)) branch = undefined;\n        alreadyShown.add(optionsShown);\n      }\n      return {\n        messageId: messageId.toString(),\n        firstSeenState: firstSeen,\n        branch: branch?.branch,\n        branchOptions: branch?.branchOptions,\n        streamMetadata\n      };\n    });\n  })();\n  const stop = () => {\n    if (abortRef.current != null) abortRef.current.abort();\n    abortRef.current = null;\n    if (runMetadataStorage && threadId) {\n      const runId = runMetadataStorage.getItem(`lg:stream:${threadId}`);\n      if (runId) void client.runs.cancel(threadId, runId);\n      runMetadataStorage.removeItem(`lg:stream:${threadId}`);\n    }\n    options?.onStop?.({\n      mutate: getMutateFn(\"stop\", historyValues)\n    });\n  };\n  async function consumeStream(action) {\n    let getCallbackMeta;\n    try {\n      setIsLoading(true);\n      setStreamError(undefined);\n      submittingRef.current = true;\n      abortRef.current = new AbortController();\n      const run = await action(abortRef.current.signal);\n      getCallbackMeta = run.getCallbackMeta;\n      let streamError;\n      for await (const {\n        event,\n        data\n      } of run.stream) {\n        if (event === \"error\") {\n          streamError = new StreamError(data);\n          break;\n        }\n        if (event === \"updates\") options.onUpdateEvent?.(data);\n        if (event === \"custom\" ||\n        // if `streamSubgraphs: true`, then we also want\n        // to also receive custom events from subgraphs\n        event.startsWith(\"custom|\")) options.onCustomEvent?.(data, {\n          mutate: getMutateFn(\"stream\", historyValues)\n        });\n        if (event === \"metadata\") options.onMetadataEvent?.(data);\n        if (event === \"events\") options.onLangChainEvent?.(data);\n        if (event === \"debug\") options.onDebugEvent?.(data);\n        if (event === \"checkpoints\") options.onCheckpointEvent?.(data);\n        if (event === \"tasks\") options.onTaskEvent?.(data);\n        if (event === \"values\") {\n          if (\"__interrupt__\" in data) {\n            // don't update values on interrupt values event\n            continue;\n          }\n          setStreamValues(data);\n        }\n        if (event === \"messages\" ||\n        // if `streamSubgraphs: true`, then we also want\n        // to also receive messages from subgraphs\n        event.startsWith(\"messages|\")) {\n          const [serialized, metadata] = data;\n          const messageId = messageManagerRef.current.add(serialized, metadata);\n          if (!messageId) {\n            console.warn(\"Failed to add message to manager, no message ID found\");\n            continue;\n          }\n          setStreamValues(streamValues => {\n            const values = {\n              ...historyValues,\n              ...streamValues\n            };\n            // Assumption: we're concatenating the message\n            const messages = getMessages(values).slice();\n            const {\n              chunk,\n              index\n            } = messageManagerRef.current.get(messageId, messages.length) ?? {};\n            if (!chunk || index == null) return values;\n            messages[index] = toMessageDict(chunk);\n            return {\n              ...values,\n              [messagesKey]: messages\n            };\n          });\n        }\n      }\n      // TODO: stream created checkpoints to avoid an unnecessary network request\n      const result = await run.onSuccess();\n      setStreamValues((values, kind) => {\n        // Do not clear out the user values set on `stop`.\n        if (kind === \"stop\") return values;\n        return null;\n      });\n      if (streamError != null) throw streamError;\n      const lastHead = result.at(0);\n      if (lastHead) onFinish?.(lastHead, getCallbackMeta?.());\n    } catch (error) {\n      if (!(error instanceof Error && (\n      // eslint-disable-line no-instanceof/no-instanceof\n      error.name === \"AbortError\" || error.name === \"TimeoutError\"))) {\n        console.error(error);\n        setStreamError(error);\n        onError?.(error, getCallbackMeta?.());\n      }\n    } finally {\n      setIsLoading(false);\n      submittingRef.current = false;\n      abortRef.current = null;\n    }\n  }\n  const joinStream = async (runId, lastEventId, options) => {\n    // eslint-disable-next-line no-param-reassign\n    lastEventId ??= \"-1\";\n    if (!threadId) return;\n    await consumeStream(async signal => {\n      const stream = client.runs.joinStream(threadId, runId, {\n        signal,\n        lastEventId,\n        streamMode: options?.streamMode\n      });\n      return {\n        onSuccess: () => {\n          runMetadataStorage?.removeItem(`lg:stream:${threadId}`);\n          return history.mutate(threadId);\n        },\n        stream,\n        getCallbackMeta: () => ({\n          thread_id: threadId,\n          run_id: runId\n        })\n      };\n    });\n  };\n  const submit = async (values, submitOptions) => {\n    await consumeStream(async signal => {\n      // Unbranch things\n      const newPath = submitOptions?.checkpoint?.checkpoint_id ? branchByCheckpoint[submitOptions?.checkpoint?.checkpoint_id]?.branch : undefined;\n      if (newPath != null) setBranch(newPath ?? \"\");\n      setStreamValues(() => {\n        if (submitOptions?.optimisticValues != null) {\n          return {\n            ...historyValues,\n            ...(typeof submitOptions.optimisticValues === \"function\" ? submitOptions.optimisticValues(historyValues) : submitOptions.optimisticValues)\n          };\n        }\n        return {\n          ...historyValues\n        };\n      });\n      let usableThreadId = threadId;\n      if (!usableThreadId) {\n        const thread = await client.threads.create({\n          threadId: submitOptions?.threadId,\n          metadata: submitOptions?.metadata\n        });\n        onThreadId(thread.thread_id);\n        usableThreadId = thread.thread_id;\n      }\n      if (!usableThreadId) throw new Error(\"Failed to obtain valid thread ID.\");\n      const streamMode = unique([...(submitOptions?.streamMode ?? []), ...trackStreamModeRef.current, ...callbackStreamMode]);\n      let checkpoint = submitOptions?.checkpoint ?? threadHead?.checkpoint ?? undefined;\n      // Avoid specifying a checkpoint if user explicitly set it to null\n      if (submitOptions?.checkpoint === null) {\n        checkpoint = undefined;\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-expect-error\n      if (checkpoint != null) delete checkpoint.thread_id;\n      let rejoinKey;\n      let callbackMeta;\n      const streamResumable = submitOptions?.streamResumable ?? !!runMetadataStorage;\n      const stream = client.runs.stream(usableThreadId, assistantId, {\n        input: values,\n        config: submitOptions?.config,\n        context: submitOptions?.context,\n        command: submitOptions?.command,\n        interruptBefore: submitOptions?.interruptBefore,\n        interruptAfter: submitOptions?.interruptAfter,\n        metadata: submitOptions?.metadata,\n        multitaskStrategy: submitOptions?.multitaskStrategy,\n        onCompletion: submitOptions?.onCompletion,\n        onDisconnect: submitOptions?.onDisconnect ?? (streamResumable ? \"continue\" : \"cancel\"),\n        signal,\n        checkpoint,\n        streamMode,\n        streamSubgraphs: submitOptions?.streamSubgraphs,\n        streamResumable,\n        onRunCreated(params) {\n          callbackMeta = {\n            run_id: params.run_id,\n            thread_id: params.thread_id ?? usableThreadId\n          };\n          if (runMetadataStorage) {\n            rejoinKey = `lg:stream:${callbackMeta.thread_id}`;\n            runMetadataStorage.setItem(rejoinKey, callbackMeta.run_id);\n          }\n          onCreated?.(callbackMeta);\n        }\n      });\n      return {\n        stream,\n        getCallbackMeta: () => callbackMeta,\n        onSuccess: () => {\n          if (rejoinKey) runMetadataStorage?.removeItem(rejoinKey);\n          return history.mutate(usableThreadId);\n        }\n      };\n    });\n  };\n  const reconnectKey = useMemo(() => {\n    if (!runMetadataStorage || isLoading) return undefined;\n    if (typeof window === \"undefined\") return undefined;\n    const runId = runMetadataStorage?.getItem(`lg:stream:${threadId}`);\n    if (!runId) return undefined;\n    return {\n      runId,\n      threadId\n    };\n  }, [runMetadataStorage, isLoading, threadId]);\n  const shouldReconnect = !!runMetadataStorage;\n  const reconnectRef = useRef({\n    threadId,\n    shouldReconnect\n  });\n  const joinStreamRef = useRef(joinStream);\n  joinStreamRef.current = joinStream;\n  useEffect(() => {\n    // reset shouldReconnect when switching threads\n    if (reconnectRef.current.threadId !== threadId) {\n      reconnectRef.current = {\n        threadId,\n        shouldReconnect\n      };\n    }\n  }, [threadId, shouldReconnect]);\n  useEffect(() => {\n    if (reconnectKey && reconnectRef.current.shouldReconnect) {\n      reconnectRef.current.shouldReconnect = false;\n      void joinStreamRef.current?.(reconnectKey.runId);\n    }\n  }, [reconnectKey]);\n  const error = streamError ?? historyValueError ?? history.error;\n  const values = streamValues ?? historyValues;\n  return {\n    get values() {\n      trackStreamMode(\"values\");\n      return values;\n    },\n    client,\n    assistantId,\n    error,\n    isLoading,\n    stop,\n    submit,\n    // eslint-disable-line @typescript-eslint/no-misused-promises\n    joinStream,\n    branch,\n    setBranch,\n    history: flatHistory,\n    isThreadLoading: history.isLoading && history.data == null,\n    get experimental_branchTree() {\n      if (historyLimit === false) {\n        throw new Error(\"`experimental_branchTree` is not available when `fetchStateHistory` is set to `false`\");\n      }\n      return rootSequence;\n    },\n    get interrupt() {\n      // Don't show the interrupt if the stream is loading\n      if (isLoading) return undefined;\n      const interrupts = threadHead?.tasks?.at(-1)?.interrupts;\n      if (interrupts == null || interrupts.length === 0) {\n        // check if there's a next task present\n        const next = threadHead?.next ?? [];\n        if (!next.length || error != null) return undefined;\n        return {\n          when: \"breakpoint\"\n        };\n      }\n      // Return only the current interrupt\n      return interrupts.at(-1);\n    },\n    get messages() {\n      trackStreamMode(\"messages-tuple\", \"values\");\n      return getMessages(values);\n    },\n    getMessagesMetadata(message, index) {\n      trackStreamMode(\"values\");\n      return messageMetadata?.find(m => m.messageId === (message.id ?? index));\n    }\n  };\n}","map":{"version":3,"names":["useCallback","useEffect","useMemo","useRef","useState","coerceMessageLikeToMessage","convertToChunk","isBaseMessageChunk","Client","getClientConfigHash","StreamError","Error","constructor","data","message","name","error","isStructuredError","tryConvertToChunk","MessageTupleManager","Object","defineProperty","enumerable","configurable","writable","value","chunks","add","serialized","metadata","type","endsWith","slice","length","toLowerCase","chunk","id","console","warn","prev","concat","clear","get","defaultIndex","index","toMessageDict","toDict","unique","array","Set","findLastIndex","predicate","i","getBranchSequence","history","childrenMap","rootSequence","items","map","path","paths","forEach","state","checkpointId","parent_checkpoint","checkpoint_id","push","queue","sequence","visited","task","shift","has","children","fork","checkpoint","unshift","PATH_SEP","ROOT_ID","getBranchView","branch","split","pathMap","parent","at","branchByCheckpoint","forkStack","item","join","branchOptions","p","forkId","findIndex","firstItem","nextItems","fetchHistory","client","threadId","options","limit","threads","getState","then","getHistory","useThreadHistory","clearCallbackRef","submittingRef","onErrorRef","setHistory","undefined","isLoading","setIsLoading","setError","clientHash","clientRef","current","fetcher","Promise","reject","finally","resolve","mutate","mutateId","useControllableThreadId","localThreadId","_setLocalThreadId","onThreadIdRef","onThreadId","useStreamValuesState","values","setValues","setStreamValues","kind","prevTuple","prevValues","prevKind","next","serverValues","update","clientValues","useStream","messagesKey","assistantId","fetchStateHistory","onCreated","onError","onFinish","reconnectOnMountRef","reconnectOnMount","runMetadataStorage","window","storage","sessionStorage","apiUrl","apiKey","callerOptions","defaultHeaders","setBranch","streamError","setStreamError","streamValues","getMutateFn","messageManagerRef","abortRef","trackStreamModeRef","trackStreamMode","mode","m","includes","hasUpdateListener","onUpdateEvent","hasCustomListener","onCustomEvent","hasLangChainListener","onLangChainEvent","hasDebugListener","onDebugEvent","hasCheckpointListener","onCheckpointEvent","hasTaskListener","onTaskEvent","callbackStreamMode","modes","historyLimit","getMessages","Array","isArray","flatHistory","threadHead","historyValues","initialValues","historyValueError","tasks","parsed","JSON","parse","messageMetadata","alreadyShown","idx","messageId","streamMetadata","firstSeenIdx","firstSeen","optionsShown","flat","toString","firstSeenState","stop","abort","runId","getItem","runs","cancel","removeItem","onStop","consumeStream","action","getCallbackMeta","AbortController","run","signal","event","stream","startsWith","onMetadataEvent","messages","result","onSuccess","lastHead","joinStream","lastEventId","streamMode","thread_id","run_id","submit","submitOptions","newPath","optimisticValues","usableThreadId","thread","create","rejoinKey","callbackMeta","streamResumable","input","config","context","command","interruptBefore","interruptAfter","multitaskStrategy","onCompletion","onDisconnect","streamSubgraphs","onRunCreated","params","setItem","reconnectKey","shouldReconnect","reconnectRef","joinStreamRef","isThreadLoading","experimental_branchTree","interrupt","interrupts","when","getMessagesMetadata","find"],"sources":["/Users/chetan/Desktop/summarize_agent/frontend/node_modules/@langchain/langgraph-sdk/dist/react/stream.js"],"sourcesContent":["/* __LC_ALLOW_ENTRYPOINT_SIDE_EFFECTS__ */\n\"use client\";\nimport { useCallback, useEffect, useMemo, useRef, useState, } from \"react\";\nimport { coerceMessageLikeToMessage, convertToChunk, isBaseMessageChunk, } from \"@langchain/core/messages\";\nimport { Client, getClientConfigHash } from \"../client.js\";\nclass StreamError extends Error {\n    constructor(data) {\n        super(data.message);\n        this.name = data.name ?? data.error ?? \"StreamError\";\n    }\n    static isStructuredError(error) {\n        return typeof error === \"object\" && error != null && \"message\" in error;\n    }\n}\nfunction tryConvertToChunk(message) {\n    try {\n        return convertToChunk(message);\n    }\n    catch {\n        return null;\n    }\n}\nclass MessageTupleManager {\n    constructor() {\n        Object.defineProperty(this, \"chunks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        this.chunks = {};\n    }\n    add(serialized, metadata) {\n        // TODO: this is sometimes sent from the API\n        // figure out how to prevent this or move this to LC.js\n        if (serialized.type.endsWith(\"MessageChunk\")) {\n            // eslint-disable-next-line no-param-reassign\n            serialized.type = serialized.type\n                .slice(0, -\"MessageChunk\".length)\n                .toLowerCase();\n        }\n        const message = coerceMessageLikeToMessage(serialized);\n        const chunk = tryConvertToChunk(message);\n        const { id } = chunk ?? message;\n        if (!id) {\n            console.warn(\"No message ID found for chunk, ignoring in state\", serialized);\n            return null;\n        }\n        this.chunks[id] ??= {};\n        this.chunks[id].metadata = metadata ?? this.chunks[id].metadata;\n        if (chunk) {\n            const prev = this.chunks[id].chunk;\n            this.chunks[id].chunk =\n                (isBaseMessageChunk(prev) ? prev : null)?.concat(chunk) ?? chunk;\n        }\n        else {\n            this.chunks[id].chunk = message;\n        }\n        return id;\n    }\n    clear() {\n        this.chunks = {};\n    }\n    get(id, defaultIndex) {\n        if (this.chunks[id] == null)\n            return null;\n        if (defaultIndex != null)\n            this.chunks[id].index ??= defaultIndex;\n        return this.chunks[id];\n    }\n}\nconst toMessageDict = (chunk) => {\n    const { type, data } = chunk.toDict();\n    return { ...data, type };\n};\nfunction unique(array) {\n    return [...new Set(array)];\n}\nfunction findLastIndex(array, predicate) {\n    for (let i = array.length - 1; i >= 0; i -= 1) {\n        if (predicate(array[i]))\n            return i;\n    }\n    return -1;\n}\nfunction getBranchSequence(history) {\n    const childrenMap = {};\n    // Short circuit if there's only a singular one state\n    // TODO: I think we can make this more generalizable for all `fetchStateHistory` values.\n    if (history.length <= 1) {\n        return {\n            rootSequence: {\n                type: \"sequence\",\n                items: history.map((value) => ({ type: \"node\", value, path: [] })),\n            },\n            paths: [],\n        };\n    }\n    // First pass - collect nodes for each checkpoint\n    history.forEach((state) => {\n        const checkpointId = state.parent_checkpoint?.checkpoint_id ?? \"$\";\n        childrenMap[checkpointId] ??= [];\n        childrenMap[checkpointId].push(state);\n    });\n    const rootSequence = { type: \"sequence\", items: [] };\n    const queue = [{ id: \"$\", sequence: rootSequence, path: [] }];\n    const paths = [];\n    const visited = new Set();\n    while (queue.length > 0) {\n        const task = queue.shift();\n        if (visited.has(task.id))\n            continue;\n        visited.add(task.id);\n        const children = childrenMap[task.id];\n        if (children == null || children.length === 0)\n            continue;\n        // If we've encountered a fork (2+ children), push the fork\n        // to the sequence and add a new sequence for each child\n        let fork;\n        if (children.length > 1) {\n            fork = { type: \"fork\", items: [] };\n            task.sequence.items.push(fork);\n        }\n        for (const value of children) {\n            const id = value.checkpoint?.checkpoint_id;\n            if (id == null)\n                continue;\n            let { sequence } = task;\n            let { path } = task;\n            if (fork != null) {\n                sequence = { type: \"sequence\", items: [] };\n                fork.items.unshift(sequence);\n                path = path.slice();\n                path.push(id);\n                paths.push(path);\n            }\n            sequence.items.push({ type: \"node\", value, path });\n            queue.push({ id, sequence, path });\n        }\n    }\n    return { rootSequence, paths };\n}\nconst PATH_SEP = \">\";\nconst ROOT_ID = \"$\";\n// Get flat view\nfunction getBranchView(sequence, paths, branch) {\n    const path = branch.split(PATH_SEP);\n    const pathMap = {};\n    for (const path of paths) {\n        const parent = path.at(-2) ?? ROOT_ID;\n        pathMap[parent] ??= [];\n        pathMap[parent].unshift(path);\n    }\n    const history = [];\n    const branchByCheckpoint = {};\n    const forkStack = path.slice();\n    const queue = [...sequence.items];\n    while (queue.length > 0) {\n        const item = queue.shift();\n        if (item.type === \"node\") {\n            history.push(item.value);\n            const checkpointId = item.value.checkpoint?.checkpoint_id;\n            if (checkpointId == null)\n                continue;\n            branchByCheckpoint[checkpointId] = {\n                branch: item.path.join(PATH_SEP),\n                branchOptions: (item.path.length > 0\n                    ? pathMap[item.path.at(-2) ?? ROOT_ID] ?? []\n                    : []).map((p) => p.join(PATH_SEP)),\n            };\n        }\n        if (item.type === \"fork\") {\n            const forkId = forkStack.shift();\n            const index = forkId != null\n                ? item.items.findIndex((value) => {\n                    const firstItem = value.items.at(0);\n                    if (!firstItem || firstItem.type !== \"node\")\n                        return false;\n                    return firstItem.value.checkpoint?.checkpoint_id === forkId;\n                })\n                : -1;\n            const nextItems = item.items.at(index)?.items ?? [];\n            queue.push(...nextItems);\n        }\n    }\n    return { history, branchByCheckpoint };\n}\nfunction fetchHistory(client, threadId, options) {\n    if (options?.limit === false) {\n        return client.threads.getState(threadId).then((state) => {\n            if (state.checkpoint == null)\n                return [];\n            return [state];\n        });\n    }\n    const limit = typeof options?.limit === \"number\" ? options.limit : 1000;\n    return client.threads.getHistory(threadId, { limit });\n}\nfunction useThreadHistory(threadId, client, limit, clearCallbackRef, submittingRef, onErrorRef) {\n    const [history, setHistory] = useState(undefined);\n    const [isLoading, setIsLoading] = useState(false);\n    const [error, setError] = useState(undefined);\n    const clientHash = getClientConfigHash(client);\n    const clientRef = useRef(client);\n    clientRef.current = client;\n    const fetcher = useCallback((threadId) => {\n        if (threadId != null) {\n            const client = clientRef.current;\n            setIsLoading(true);\n            return fetchHistory(client, threadId, {\n                limit,\n            })\n                .then((history) => {\n                setHistory(history);\n                return history;\n            }, (error) => {\n                setError(error);\n                onErrorRef.current?.(error);\n                return Promise.reject(error);\n            })\n                .finally(() => {\n                setIsLoading(false);\n            });\n        }\n        setHistory(undefined);\n        setError(undefined);\n        setIsLoading(false);\n        clearCallbackRef.current?.();\n        return Promise.resolve([]);\n    }, [clearCallbackRef, onErrorRef, limit]);\n    useEffect(() => {\n        if (submittingRef.current)\n            return;\n        void fetcher(threadId);\n    }, [fetcher, clientHash, limit, submittingRef, threadId]);\n    return {\n        data: history,\n        isLoading,\n        error,\n        mutate: (mutateId) => fetcher(mutateId ?? threadId),\n    };\n}\nconst useControllableThreadId = (options) => {\n    const [localThreadId, _setLocalThreadId] = useState(options?.threadId ?? null);\n    const onThreadIdRef = useRef(options?.onThreadId);\n    onThreadIdRef.current = options?.onThreadId;\n    const onThreadId = useCallback((threadId) => {\n        _setLocalThreadId(threadId);\n        onThreadIdRef.current?.(threadId);\n    }, []);\n    if (!options || !(\"threadId\" in options)) {\n        return [localThreadId, onThreadId];\n    }\n    return [options.threadId ?? null, onThreadId];\n};\nfunction useStreamValuesState() {\n    const [values, setValues] = useState(null);\n    const setStreamValues = useCallback((values, kind = \"stream\") => {\n        if (typeof values === \"function\") {\n            setValues((prevTuple) => {\n                const [prevValues, prevKind] = prevTuple ?? [null, \"stream\"];\n                const next = values(prevValues, prevKind);\n                if (next == null)\n                    return null;\n                return [next, kind];\n            });\n            return;\n        }\n        if (values == null)\n            setValues(null);\n        setValues([values, kind]);\n    }, []);\n    const mutate = useCallback((kind, serverValues) => (update) => {\n        setStreamValues((clientValues) => {\n            const prev = { ...serverValues, ...clientValues };\n            const next = typeof update === \"function\" ? update(prev) : update;\n            return { ...prev, ...next };\n        }, kind);\n    }, [setStreamValues]);\n    return [values?.[0] ?? null, setStreamValues, mutate];\n}\nexport function useStream(options) {\n    let { messagesKey } = options;\n    const { assistantId, fetchStateHistory } = options;\n    const { onCreated, onError, onFinish } = options;\n    const reconnectOnMountRef = useRef(options.reconnectOnMount);\n    const runMetadataStorage = useMemo(() => {\n        if (typeof window === \"undefined\")\n            return null;\n        const storage = reconnectOnMountRef.current;\n        if (storage === true)\n            return window.sessionStorage;\n        if (typeof storage === \"function\")\n            return storage();\n        return null;\n    }, []);\n    messagesKey ??= \"messages\";\n    const client = useMemo(() => options.client ??\n        new Client({\n            apiUrl: options.apiUrl,\n            apiKey: options.apiKey,\n            callerOptions: options.callerOptions,\n            defaultHeaders: options.defaultHeaders,\n        }), [\n        options.client,\n        options.apiKey,\n        options.apiUrl,\n        options.callerOptions,\n        options.defaultHeaders,\n    ]);\n    const [threadId, onThreadId] = useControllableThreadId(options);\n    const [branch, setBranch] = useState(\"\");\n    const [isLoading, setIsLoading] = useState(false);\n    const [streamError, setStreamError] = useState(undefined);\n    const [streamValues, setStreamValues, getMutateFn] = useStreamValuesState();\n    const messageManagerRef = useRef(new MessageTupleManager());\n    const submittingRef = useRef(false);\n    const abortRef = useRef(null);\n    const trackStreamModeRef = useRef([]);\n    const trackStreamMode = useCallback((...mode) => {\n        for (const m of mode) {\n            if (!trackStreamModeRef.current.includes(m)) {\n                trackStreamModeRef.current.push(m);\n            }\n        }\n    }, []);\n    const hasUpdateListener = options.onUpdateEvent != null;\n    const hasCustomListener = options.onCustomEvent != null;\n    const hasLangChainListener = options.onLangChainEvent != null;\n    const hasDebugListener = options.onDebugEvent != null;\n    const hasCheckpointListener = options.onCheckpointEvent != null;\n    const hasTaskListener = options.onTaskEvent != null;\n    const callbackStreamMode = useMemo(() => {\n        const modes = [];\n        if (hasUpdateListener)\n            modes.push(\"updates\");\n        if (hasCustomListener)\n            modes.push(\"custom\");\n        if (hasLangChainListener)\n            modes.push(\"events\");\n        if (hasDebugListener)\n            modes.push(\"debug\");\n        if (hasCheckpointListener)\n            modes.push(\"checkpoints\");\n        if (hasTaskListener)\n            modes.push(\"tasks\");\n        return modes;\n    }, [\n        hasUpdateListener,\n        hasCustomListener,\n        hasLangChainListener,\n        hasDebugListener,\n        hasCheckpointListener,\n        hasTaskListener,\n    ]);\n    const clearCallbackRef = useRef(null);\n    clearCallbackRef.current = () => {\n        setStreamError(undefined);\n        setStreamValues(null);\n        messageManagerRef.current.clear();\n    };\n    const onErrorRef = useRef(undefined);\n    onErrorRef.current = options.onError;\n    const historyLimit = typeof fetchStateHistory === \"object\" && fetchStateHistory != null\n        ? fetchStateHistory.limit ?? true\n        : fetchStateHistory ?? true;\n    const history = useThreadHistory(threadId, client, historyLimit, clearCallbackRef, submittingRef, onErrorRef);\n    const getMessages = useMemo(() => {\n        return (value) => Array.isArray(value[messagesKey])\n            ? value[messagesKey]\n            : [];\n    }, [messagesKey]);\n    const { rootSequence, paths } = getBranchSequence(history.data ?? []);\n    const { history: flatHistory, branchByCheckpoint } = getBranchView(rootSequence, paths, branch);\n    const threadHead = flatHistory.at(-1);\n    const historyValues = threadHead?.values ?? options.initialValues ?? {};\n    const historyValueError = (() => {\n        const error = threadHead?.tasks?.at(-1)?.error;\n        if (error == null)\n            return undefined;\n        try {\n            const parsed = JSON.parse(error);\n            if (StreamError.isStructuredError(parsed)) {\n                return new StreamError(parsed);\n            }\n            return parsed;\n        }\n        catch {\n            // do nothing\n        }\n        return error;\n    })();\n    const messageMetadata = (() => {\n        const alreadyShown = new Set();\n        return getMessages(historyValues).map((message, idx) => {\n            const messageId = message.id ?? idx;\n            const streamMetadata = message.id != null\n                ? messageManagerRef.current.get(message.id)?.metadata ?? undefined\n                : undefined;\n            const firstSeenIdx = findLastIndex(history.data ?? [], (state) => getMessages(state.values)\n                .map((m, idx) => m.id ?? idx)\n                .includes(messageId));\n            const firstSeen = history.data?.[firstSeenIdx];\n            const checkpointId = firstSeen?.checkpoint?.checkpoint_id;\n            let branch = firstSeen && checkpointId != null\n                ? branchByCheckpoint[checkpointId]\n                : undefined;\n            if (!branch?.branch?.length)\n                branch = undefined;\n            // serialize branches\n            const optionsShown = branch?.branchOptions?.flat(2).join(\",\");\n            if (optionsShown) {\n                if (alreadyShown.has(optionsShown))\n                    branch = undefined;\n                alreadyShown.add(optionsShown);\n            }\n            return {\n                messageId: messageId.toString(),\n                firstSeenState: firstSeen,\n                branch: branch?.branch,\n                branchOptions: branch?.branchOptions,\n                streamMetadata,\n            };\n        });\n    })();\n    const stop = () => {\n        if (abortRef.current != null)\n            abortRef.current.abort();\n        abortRef.current = null;\n        if (runMetadataStorage && threadId) {\n            const runId = runMetadataStorage.getItem(`lg:stream:${threadId}`);\n            if (runId)\n                void client.runs.cancel(threadId, runId);\n            runMetadataStorage.removeItem(`lg:stream:${threadId}`);\n        }\n        options?.onStop?.({ mutate: getMutateFn(\"stop\", historyValues) });\n    };\n    async function consumeStream(action) {\n        let getCallbackMeta;\n        try {\n            setIsLoading(true);\n            setStreamError(undefined);\n            submittingRef.current = true;\n            abortRef.current = new AbortController();\n            const run = await action(abortRef.current.signal);\n            getCallbackMeta = run.getCallbackMeta;\n            let streamError;\n            for await (const { event, data } of run.stream) {\n                if (event === \"error\") {\n                    streamError = new StreamError(data);\n                    break;\n                }\n                if (event === \"updates\")\n                    options.onUpdateEvent?.(data);\n                if (event === \"custom\" ||\n                    // if `streamSubgraphs: true`, then we also want\n                    // to also receive custom events from subgraphs\n                    event.startsWith(\"custom|\"))\n                    options.onCustomEvent?.(data, {\n                        mutate: getMutateFn(\"stream\", historyValues),\n                    });\n                if (event === \"metadata\")\n                    options.onMetadataEvent?.(data);\n                if (event === \"events\")\n                    options.onLangChainEvent?.(data);\n                if (event === \"debug\")\n                    options.onDebugEvent?.(data);\n                if (event === \"checkpoints\")\n                    options.onCheckpointEvent?.(data);\n                if (event === \"tasks\")\n                    options.onTaskEvent?.(data);\n                if (event === \"values\") {\n                    if (\"__interrupt__\" in data) {\n                        // don't update values on interrupt values event\n                        continue;\n                    }\n                    setStreamValues(data);\n                }\n                if (event === \"messages\" ||\n                    // if `streamSubgraphs: true`, then we also want\n                    // to also receive messages from subgraphs\n                    event.startsWith(\"messages|\")) {\n                    const [serialized, metadata] = data;\n                    const messageId = messageManagerRef.current.add(serialized, metadata);\n                    if (!messageId) {\n                        console.warn(\"Failed to add message to manager, no message ID found\");\n                        continue;\n                    }\n                    setStreamValues((streamValues) => {\n                        const values = { ...historyValues, ...streamValues };\n                        // Assumption: we're concatenating the message\n                        const messages = getMessages(values).slice();\n                        const { chunk, index } = messageManagerRef.current.get(messageId, messages.length) ?? {};\n                        if (!chunk || index == null)\n                            return values;\n                        messages[index] = toMessageDict(chunk);\n                        return { ...values, [messagesKey]: messages };\n                    });\n                }\n            }\n            // TODO: stream created checkpoints to avoid an unnecessary network request\n            const result = await run.onSuccess();\n            setStreamValues((values, kind) => {\n                // Do not clear out the user values set on `stop`.\n                if (kind === \"stop\")\n                    return values;\n                return null;\n            });\n            if (streamError != null)\n                throw streamError;\n            const lastHead = result.at(0);\n            if (lastHead)\n                onFinish?.(lastHead, getCallbackMeta?.());\n        }\n        catch (error) {\n            if (!(error instanceof Error && // eslint-disable-line no-instanceof/no-instanceof\n                (error.name === \"AbortError\" || error.name === \"TimeoutError\"))) {\n                console.error(error);\n                setStreamError(error);\n                onError?.(error, getCallbackMeta?.());\n            }\n        }\n        finally {\n            setIsLoading(false);\n            submittingRef.current = false;\n            abortRef.current = null;\n        }\n    }\n    const joinStream = async (runId, lastEventId, options) => {\n        // eslint-disable-next-line no-param-reassign\n        lastEventId ??= \"-1\";\n        if (!threadId)\n            return;\n        await consumeStream(async (signal) => {\n            const stream = client.runs.joinStream(threadId, runId, {\n                signal,\n                lastEventId,\n                streamMode: options?.streamMode,\n            });\n            return {\n                onSuccess: () => {\n                    runMetadataStorage?.removeItem(`lg:stream:${threadId}`);\n                    return history.mutate(threadId);\n                },\n                stream,\n                getCallbackMeta: () => ({ thread_id: threadId, run_id: runId }),\n            };\n        });\n    };\n    const submit = async (values, submitOptions) => {\n        await consumeStream(async (signal) => {\n            // Unbranch things\n            const newPath = submitOptions?.checkpoint?.checkpoint_id\n                ? branchByCheckpoint[submitOptions?.checkpoint?.checkpoint_id]?.branch\n                : undefined;\n            if (newPath != null)\n                setBranch(newPath ?? \"\");\n            setStreamValues(() => {\n                if (submitOptions?.optimisticValues != null) {\n                    return {\n                        ...historyValues,\n                        ...(typeof submitOptions.optimisticValues === \"function\"\n                            ? submitOptions.optimisticValues(historyValues)\n                            : submitOptions.optimisticValues),\n                    };\n                }\n                return { ...historyValues };\n            });\n            let usableThreadId = threadId;\n            if (!usableThreadId) {\n                const thread = await client.threads.create({\n                    threadId: submitOptions?.threadId,\n                    metadata: submitOptions?.metadata,\n                });\n                onThreadId(thread.thread_id);\n                usableThreadId = thread.thread_id;\n            }\n            if (!usableThreadId)\n                throw new Error(\"Failed to obtain valid thread ID.\");\n            const streamMode = unique([\n                ...(submitOptions?.streamMode ?? []),\n                ...trackStreamModeRef.current,\n                ...callbackStreamMode,\n            ]);\n            let checkpoint = submitOptions?.checkpoint ?? threadHead?.checkpoint ?? undefined;\n            // Avoid specifying a checkpoint if user explicitly set it to null\n            if (submitOptions?.checkpoint === null) {\n                checkpoint = undefined;\n            }\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-expect-error\n            if (checkpoint != null)\n                delete checkpoint.thread_id;\n            let rejoinKey;\n            let callbackMeta;\n            const streamResumable = submitOptions?.streamResumable ?? !!runMetadataStorage;\n            const stream = client.runs.stream(usableThreadId, assistantId, {\n                input: values,\n                config: submitOptions?.config,\n                context: submitOptions?.context,\n                command: submitOptions?.command,\n                interruptBefore: submitOptions?.interruptBefore,\n                interruptAfter: submitOptions?.interruptAfter,\n                metadata: submitOptions?.metadata,\n                multitaskStrategy: submitOptions?.multitaskStrategy,\n                onCompletion: submitOptions?.onCompletion,\n                onDisconnect: submitOptions?.onDisconnect ??\n                    (streamResumable ? \"continue\" : \"cancel\"),\n                signal,\n                checkpoint,\n                streamMode,\n                streamSubgraphs: submitOptions?.streamSubgraphs,\n                streamResumable,\n                onRunCreated(params) {\n                    callbackMeta = {\n                        run_id: params.run_id,\n                        thread_id: params.thread_id ?? usableThreadId,\n                    };\n                    if (runMetadataStorage) {\n                        rejoinKey = `lg:stream:${callbackMeta.thread_id}`;\n                        runMetadataStorage.setItem(rejoinKey, callbackMeta.run_id);\n                    }\n                    onCreated?.(callbackMeta);\n                },\n            });\n            return {\n                stream,\n                getCallbackMeta: () => callbackMeta,\n                onSuccess: () => {\n                    if (rejoinKey)\n                        runMetadataStorage?.removeItem(rejoinKey);\n                    return history.mutate(usableThreadId);\n                },\n            };\n        });\n    };\n    const reconnectKey = useMemo(() => {\n        if (!runMetadataStorage || isLoading)\n            return undefined;\n        if (typeof window === \"undefined\")\n            return undefined;\n        const runId = runMetadataStorage?.getItem(`lg:stream:${threadId}`);\n        if (!runId)\n            return undefined;\n        return { runId, threadId };\n    }, [runMetadataStorage, isLoading, threadId]);\n    const shouldReconnect = !!runMetadataStorage;\n    const reconnectRef = useRef({ threadId, shouldReconnect });\n    const joinStreamRef = useRef(joinStream);\n    joinStreamRef.current = joinStream;\n    useEffect(() => {\n        // reset shouldReconnect when switching threads\n        if (reconnectRef.current.threadId !== threadId) {\n            reconnectRef.current = { threadId, shouldReconnect };\n        }\n    }, [threadId, shouldReconnect]);\n    useEffect(() => {\n        if (reconnectKey && reconnectRef.current.shouldReconnect) {\n            reconnectRef.current.shouldReconnect = false;\n            void joinStreamRef.current?.(reconnectKey.runId);\n        }\n    }, [reconnectKey]);\n    const error = streamError ?? historyValueError ?? history.error;\n    const values = streamValues ?? historyValues;\n    return {\n        get values() {\n            trackStreamMode(\"values\");\n            return values;\n        },\n        client,\n        assistantId,\n        error,\n        isLoading,\n        stop,\n        submit, // eslint-disable-line @typescript-eslint/no-misused-promises\n        joinStream,\n        branch,\n        setBranch,\n        history: flatHistory,\n        isThreadLoading: history.isLoading && history.data == null,\n        get experimental_branchTree() {\n            if (historyLimit === false) {\n                throw new Error(\"`experimental_branchTree` is not available when `fetchStateHistory` is set to `false`\");\n            }\n            return rootSequence;\n        },\n        get interrupt() {\n            // Don't show the interrupt if the stream is loading\n            if (isLoading)\n                return undefined;\n            const interrupts = threadHead?.tasks?.at(-1)?.interrupts;\n            if (interrupts == null || interrupts.length === 0) {\n                // check if there's a next task present\n                const next = threadHead?.next ?? [];\n                if (!next.length || error != null)\n                    return undefined;\n                return { when: \"breakpoint\" };\n            }\n            // Return only the current interrupt\n            return interrupts.at(-1);\n        },\n        get messages() {\n            trackStreamMode(\"messages-tuple\", \"values\");\n            return getMessages(values);\n        },\n        getMessagesMetadata(message, index) {\n            trackStreamMode(\"values\");\n            return messageMetadata?.find((m) => m.messageId === (message.id ?? index));\n        },\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}