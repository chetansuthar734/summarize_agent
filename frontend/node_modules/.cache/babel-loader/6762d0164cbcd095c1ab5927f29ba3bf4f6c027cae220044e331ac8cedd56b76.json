{"ast":null,"code":"import * as uuid from \"uuid\";\nimport { LangSmithToOTELTranslator } from \"./experimental/otel/translator.js\";\nimport { getDefaultOTLPTracerComponents, getOTELTrace, getOTELContext } from \"./singletons/otel.js\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getLangSmithEnvironmentVariable, getRuntimeEnvironment, getOtelEnabled } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nimport { assertUuid } from \"./utils/_uuid.js\";\nimport { warnOnce } from \"./utils/warn.js\";\nimport { parsePromptIdentifier } from \"./utils/prompts.js\";\nimport { raiseForStatus } from \"./utils/error.js\";\nimport { _globalFetchImplementationIsNodeFetch, _getFetchImplementation } from \"./singletons/fetch.js\";\nimport { serialize as serializePayloadForTracing } from \"./utils/fast-safe-stringify/index.js\";\nexport function mergeRuntimeEnvIntoRun(run) {\n  const runtimeEnv = getRuntimeEnvironment();\n  const envVars = getLangChainEnvVarsMetadata();\n  const extra = run.extra ?? {};\n  const metadata = extra.metadata;\n  run.extra = {\n    ...extra,\n    runtime: {\n      ...runtimeEnv,\n      ...extra?.runtime\n    },\n    metadata: {\n      ...envVars,\n      ...(envVars.revision_id || \"revision_id\" in run && run.revision_id ? {\n        revision_id: (\"revision_id\" in run ? run.revision_id : undefined) ?? envVars.revision_id\n      } : {}),\n      ...metadata\n    }\n  };\n  return run;\n}\nconst getTracingSamplingRate = configRate => {\n  const samplingRateStr = configRate?.toString() ?? getLangSmithEnvironmentVariable(\"TRACING_SAMPLING_RATE\");\n  if (samplingRateStr === undefined) {\n    return undefined;\n  }\n  const samplingRate = parseFloat(samplingRateStr);\n  if (samplingRate < 0 || samplingRate > 1) {\n    throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n  }\n  return samplingRate;\n};\n// utility functions\nconst isLocalhost = url => {\n  const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n  const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n  return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nasync function toArray(iterable) {\n  const result = [];\n  for await (const item of iterable) {\n    result.push(item);\n  }\n  return result;\n}\nfunction trimQuotes(str) {\n  if (str === undefined) {\n    return undefined;\n  }\n  return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async response => {\n  if (response?.status === 429) {\n    const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n    if (retryAfter > 0) {\n      await new Promise(resolve => setTimeout(resolve, retryAfter));\n      // Return directly after calling this check\n      return true;\n    }\n  }\n  // Fall back to existing status checks\n  return false;\n};\nfunction _formatFeedbackScore(score) {\n  if (typeof score === \"number\") {\n    // Truncate at 4 decimal places\n    return Number(score.toFixed(4));\n  }\n  return score;\n}\nexport class AutoBatchQueue {\n  constructor() {\n    Object.defineProperty(this, \"items\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"sizeBytes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n  }\n  peek() {\n    return this.items[0];\n  }\n  push(item) {\n    let itemPromiseResolve;\n    const itemPromise = new Promise(resolve => {\n      // Setting itemPromiseResolve is synchronous with promise creation:\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n      itemPromiseResolve = resolve;\n    });\n    const size = serializePayloadForTracing(item.item, `Serializing run with id: ${item.item.id}`).length;\n    this.items.push({\n      action: item.action,\n      payload: item.item,\n      otelContext: item.otelContext,\n      apiKey: item.apiKey,\n      apiUrl: item.apiUrl,\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      itemPromiseResolve: itemPromiseResolve,\n      itemPromise,\n      size\n    });\n    this.sizeBytes += size;\n    return itemPromise;\n  }\n  pop(upToSizeBytes) {\n    if (upToSizeBytes < 1) {\n      throw new Error(\"Number of bytes to pop off may not be less than 1.\");\n    }\n    const popped = [];\n    let poppedSizeBytes = 0;\n    // Pop items until we reach or exceed the size limit\n    while (poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes && this.items.length > 0) {\n      const item = this.items.shift();\n      if (item) {\n        popped.push(item);\n        poppedSizeBytes += item.size;\n        this.sizeBytes -= item.size;\n      }\n    }\n    // If there is an item on the queue we were unable to pop,\n    // just return it as a single batch.\n    if (popped.length === 0 && this.items.length > 0) {\n      const item = this.items.shift();\n      popped.push(item);\n      poppedSizeBytes += item.size;\n      this.sizeBytes -= item.size;\n    }\n    return [popped.map(it => ({\n      action: it.action,\n      item: it.payload,\n      otelContext: it.otelContext,\n      apiKey: it.apiKey,\n      apiUrl: it.apiUrl\n    })), () => popped.forEach(it => it.itemPromiseResolve())];\n  }\n}\n// 20 MB\nexport const DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20_971_520;\nconst SERVER_INFO_REQUEST_TIMEOUT = 2500;\nconst DEFAULT_API_URL = \"https://api.smith.langchain.com\";\nexport class Client {\n  constructor(config = {}) {\n    Object.defineProperty(this, \"apiKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"apiUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"webUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"caller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"batchIngestCaller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"timeout_ms\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_tenantId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"hideInputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"hideOutputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tracingSampleRate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"filteredPostUuids\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, \"autoBatchTracing\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"autoBatchQueue\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new AutoBatchQueue()\n    });\n    Object.defineProperty(this, \"autoBatchTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 250\n    });\n    Object.defineProperty(this, \"batchSizeBytesLimit\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fetchOptions\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"settings\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"blockOnRootRunFinalization\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: getEnvironmentVariable(\"LANGSMITH_TRACING_BACKGROUND\") === \"false\"\n    });\n    Object.defineProperty(this, \"traceBatchConcurrency\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 5\n    });\n    Object.defineProperty(this, \"_serverInfo\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"_getServerInfoPromise\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"manualFlushMode\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"langSmithToOTELTranslator\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"multipartStreamingDisabled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"debug\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: getEnvironmentVariable(\"LANGSMITH_DEBUG\") === \"true\"\n    });\n    const defaultConfig = Client.getDefaultClientConfig();\n    this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);\n    this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n    if (this.apiUrl.endsWith(\"/\")) {\n      this.apiUrl = this.apiUrl.slice(0, -1);\n    }\n    this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n    this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n    if (this.webUrl?.endsWith(\"/\")) {\n      this.webUrl = this.webUrl.slice(0, -1);\n    }\n    this.timeout_ms = config.timeout_ms ?? 90_000;\n    this.caller = new AsyncCaller({\n      ...(config.callerOptions ?? {}),\n      debug: config.debug ?? this.debug\n    });\n    this.traceBatchConcurrency = config.traceBatchConcurrency ?? this.traceBatchConcurrency;\n    if (this.traceBatchConcurrency < 1) {\n      throw new Error(\"Trace batch concurrency must be positive.\");\n    }\n    this.debug = config.debug ?? this.debug;\n    this.batchIngestCaller = new AsyncCaller({\n      maxRetries: 2,\n      maxConcurrency: this.traceBatchConcurrency,\n      ...(config.callerOptions ?? {}),\n      onFailedResponseHook: handle429,\n      debug: config.debug ?? this.debug\n    });\n    this.hideInputs = config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;\n    this.hideOutputs = config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;\n    this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n    this.blockOnRootRunFinalization = config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;\n    this.batchSizeBytesLimit = config.batchSizeBytesLimit;\n    this.fetchOptions = config.fetchOptions || {};\n    this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;\n    if (getOtelEnabled()) {\n      this.langSmithToOTELTranslator = new LangSmithToOTELTranslator();\n    }\n  }\n  static getDefaultClientConfig() {\n    const apiKey = getLangSmithEnvironmentVariable(\"API_KEY\");\n    const apiUrl = getLangSmithEnvironmentVariable(\"ENDPOINT\") ?? DEFAULT_API_URL;\n    const hideInputs = getLangSmithEnvironmentVariable(\"HIDE_INPUTS\") === \"true\";\n    const hideOutputs = getLangSmithEnvironmentVariable(\"HIDE_OUTPUTS\") === \"true\";\n    return {\n      apiUrl: apiUrl,\n      apiKey: apiKey,\n      webUrl: undefined,\n      hideInputs: hideInputs,\n      hideOutputs: hideOutputs\n    };\n  }\n  getHostUrl() {\n    if (this.webUrl) {\n      return this.webUrl;\n    } else if (isLocalhost(this.apiUrl)) {\n      this.webUrl = \"http://localhost:3000\";\n      return this.webUrl;\n    } else if (this.apiUrl.endsWith(\"/api/v1\")) {\n      this.webUrl = this.apiUrl.replace(\"/api/v1\", \"\");\n      return this.webUrl;\n    } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n      this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n      return this.webUrl;\n    } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n      this.webUrl = \"https://dev.smith.langchain.com\";\n      return this.webUrl;\n    } else if (this.apiUrl.split(\".\", 1)[0].includes(\"eu\")) {\n      this.webUrl = \"https://eu.smith.langchain.com\";\n      return this.webUrl;\n    } else if (this.apiUrl.split(\".\", 1)[0].includes(\"beta\")) {\n      this.webUrl = \"https://beta.smith.langchain.com\";\n      return this.webUrl;\n    } else {\n      this.webUrl = \"https://smith.langchain.com\";\n      return this.webUrl;\n    }\n  }\n  get headers() {\n    const headers = {\n      \"User-Agent\": `langsmith-js/${__version__}`\n    };\n    if (this.apiKey) {\n      headers[\"x-api-key\"] = `${this.apiKey}`;\n    }\n    return headers;\n  }\n  _getPlatformEndpointPath(path) {\n    // Check if apiUrl already ends with /v1 or /v1/ to avoid double /v1/v1/ paths\n    const needsV1Prefix = this.apiUrl.slice(-3) !== \"/v1\" && this.apiUrl.slice(-4) !== \"/v1/\";\n    return needsV1Prefix ? `/v1/platform/${path}` : `/platform/${path}`;\n  }\n  async processInputs(inputs) {\n    if (this.hideInputs === false) {\n      return inputs;\n    }\n    if (this.hideInputs === true) {\n      return {};\n    }\n    if (typeof this.hideInputs === \"function\") {\n      return this.hideInputs(inputs);\n    }\n    return inputs;\n  }\n  async processOutputs(outputs) {\n    if (this.hideOutputs === false) {\n      return outputs;\n    }\n    if (this.hideOutputs === true) {\n      return {};\n    }\n    if (typeof this.hideOutputs === \"function\") {\n      return this.hideOutputs(outputs);\n    }\n    return outputs;\n  }\n  async prepareRunCreateOrUpdateInputs(run) {\n    const runParams = {\n      ...run\n    };\n    if (runParams.inputs !== undefined) {\n      runParams.inputs = await this.processInputs(runParams.inputs);\n    }\n    if (runParams.outputs !== undefined) {\n      runParams.outputs = await this.processOutputs(runParams.outputs);\n    }\n    return runParams;\n  }\n  async _getResponse(path, queryParams) {\n    const paramsString = queryParams?.toString() ?? \"\";\n    const url = `${this.apiUrl}${path}?${paramsString}`;\n    const response = await this.caller.call(_getFetchImplementation(this.debug), url, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, `Failed to fetch ${path}`);\n    return response;\n  }\n  async _get(path, queryParams) {\n    const response = await this._getResponse(path, queryParams);\n    return response.json();\n  }\n  async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {\n    let offset = Number(queryParams.get(\"offset\")) || 0;\n    const limit = Number(queryParams.get(\"limit\")) || 100;\n    while (true) {\n      queryParams.set(\"offset\", String(offset));\n      queryParams.set(\"limit\", String(limit));\n      const url = `${this.apiUrl}${path}?${queryParams}`;\n      const response = await this.caller.call(_getFetchImplementation(this.debug), url, {\n        method: \"GET\",\n        headers: this.headers,\n        signal: AbortSignal.timeout(this.timeout_ms),\n        ...this.fetchOptions\n      });\n      await raiseForStatus(response, `Failed to fetch ${path}`);\n      const items = transform ? transform(await response.json()) : await response.json();\n      if (items.length === 0) {\n        break;\n      }\n      yield items;\n      if (items.length < limit) {\n        break;\n      }\n      offset += items.length;\n    }\n  }\n  async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n    const bodyParams = body ? {\n      ...body\n    } : {};\n    while (true) {\n      const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${path}`, {\n        method: requestMethod,\n        headers: {\n          ...this.headers,\n          \"Content-Type\": \"application/json\"\n        },\n        signal: AbortSignal.timeout(this.timeout_ms),\n        ...this.fetchOptions,\n        body: JSON.stringify(bodyParams)\n      });\n      const responseBody = await response.json();\n      if (!responseBody) {\n        break;\n      }\n      if (!responseBody[dataKey]) {\n        break;\n      }\n      yield responseBody[dataKey];\n      const cursors = responseBody.cursors;\n      if (!cursors) {\n        break;\n      }\n      if (!cursors.next) {\n        break;\n      }\n      bodyParams.cursor = cursors.next;\n    }\n  }\n  // Allows mocking for tests\n  _shouldSample() {\n    if (this.tracingSampleRate === undefined) {\n      return true;\n    }\n    return Math.random() < this.tracingSampleRate;\n  }\n  _filterForSampling(runs, patch = false) {\n    if (this.tracingSampleRate === undefined) {\n      return runs;\n    }\n    if (patch) {\n      const sampled = [];\n      for (const run of runs) {\n        if (!this.filteredPostUuids.has(run.trace_id)) {\n          sampled.push(run);\n        } else if (run.id === run.trace_id) {\n          this.filteredPostUuids.delete(run.trace_id);\n        }\n      }\n      return sampled;\n    } else {\n      // For new runs, sample at trace level to maintain consistency\n      const sampled = [];\n      for (const run of runs) {\n        const traceId = run.trace_id ?? run.id;\n        // If we've already made a decision about this trace, follow it\n        if (this.filteredPostUuids.has(traceId)) {\n          continue;\n        }\n        // For new traces, apply sampling\n        if (run.id === traceId) {\n          if (this._shouldSample()) {\n            sampled.push(run);\n          } else {\n            this.filteredPostUuids.add(traceId);\n          }\n        } else {\n          // Child runs follow their trace's sampling decision\n          sampled.push(run);\n        }\n      }\n      return sampled;\n    }\n  }\n  async _getBatchSizeLimitBytes() {\n    const serverInfo = await this._ensureServerInfo();\n    return this.batchSizeBytesLimit ?? serverInfo.batch_ingest_config?.size_limit_bytes ?? DEFAULT_BATCH_SIZE_LIMIT_BYTES;\n  }\n  async _getMultiPartSupport() {\n    const serverInfo = await this._ensureServerInfo();\n    return serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false;\n  }\n  drainAutoBatchQueue(batchSizeLimit) {\n    const promises = [];\n    while (this.autoBatchQueue.items.length > 0) {\n      const [batch, done] = this.autoBatchQueue.pop(batchSizeLimit);\n      if (!batch.length) {\n        done();\n        break;\n      }\n      const batchesByDestination = batch.reduce((acc, item) => {\n        const apiUrl = item.apiUrl ?? this.apiUrl;\n        const apiKey = item.apiKey ?? this.apiKey;\n        const isDefault = item.apiKey === this.apiKey && item.apiUrl === this.apiUrl;\n        const batchKey = isDefault ? \"default\" : `${apiUrl}|${apiKey}`;\n        if (!acc[batchKey]) {\n          acc[batchKey] = [];\n        }\n        acc[batchKey].push(item);\n        return acc;\n      }, {});\n      const batchPromises = [];\n      for (const [batchKey, batch] of Object.entries(batchesByDestination)) {\n        const batchPromise = this._processBatch(batch, {\n          apiUrl: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[0],\n          apiKey: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[1]\n        });\n        batchPromises.push(batchPromise);\n      }\n      // Wait for all batches to complete, then call the overall done callback\n      const allBatchesPromise = Promise.all(batchPromises).finally(done);\n      promises.push(allBatchesPromise);\n    }\n    return Promise.all(promises);\n  }\n  async _processBatch(batch, options) {\n    if (!batch.length) {\n      return;\n    }\n    try {\n      if (this.langSmithToOTELTranslator !== undefined) {\n        this._sendBatchToOTELTranslator(batch);\n      } else {\n        const ingestParams = {\n          runCreates: batch.filter(item => item.action === \"create\").map(item => item.item),\n          runUpdates: batch.filter(item => item.action === \"update\").map(item => item.item)\n        };\n        const serverInfo = await this._ensureServerInfo();\n        if (serverInfo?.batch_ingest_config?.use_multipart_endpoint) {\n          await this.multipartIngestRuns(ingestParams, options);\n        } else {\n          await this.batchIngestRuns(ingestParams, options);\n        }\n      }\n    } catch (e) {\n      console.error(\"Error exporting batch:\", e);\n    }\n  }\n  _sendBatchToOTELTranslator(batch) {\n    if (this.langSmithToOTELTranslator !== undefined) {\n      const otelContextMap = new Map();\n      const operations = [];\n      for (const item of batch) {\n        if (item.item.id && item.otelContext) {\n          otelContextMap.set(item.item.id, item.otelContext);\n          if (item.action === \"create\") {\n            operations.push({\n              operation: \"post\",\n              id: item.item.id,\n              trace_id: item.item.trace_id ?? item.item.id,\n              run: item.item\n            });\n          } else {\n            operations.push({\n              operation: \"patch\",\n              id: item.item.id,\n              trace_id: item.item.trace_id ?? item.item.id,\n              run: item.item\n            });\n          }\n        }\n      }\n      this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);\n    }\n  }\n  async processRunOperation(item) {\n    clearTimeout(this.autoBatchTimeout);\n    this.autoBatchTimeout = undefined;\n    item.item = mergeRuntimeEnvIntoRun(item.item);\n    const itemPromise = this.autoBatchQueue.push(item);\n    if (this.manualFlushMode) {\n      // Rely on manual flushing in serverless environments\n      return itemPromise;\n    }\n    const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n    if (this.autoBatchQueue.sizeBytes > sizeLimitBytes) {\n      void this.drainAutoBatchQueue(sizeLimitBytes);\n    }\n    if (this.autoBatchQueue.items.length > 0) {\n      this.autoBatchTimeout = setTimeout(() => {\n        this.autoBatchTimeout = undefined;\n        void this.drainAutoBatchQueue(sizeLimitBytes);\n      }, this.autoBatchAggregationDelayMs);\n    }\n    return itemPromise;\n  }\n  async _getServerInfo() {\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/info`, {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\"\n      },\n      signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"get server info\");\n    const json = await response.json();\n    if (this.debug) {\n      console.log(\"\\n=== LangSmith Server Configuration ===\\n\" + JSON.stringify(json, null, 2) + \"\\n\");\n    }\n    return json;\n  }\n  async _ensureServerInfo() {\n    if (this._getServerInfoPromise === undefined) {\n      this._getServerInfoPromise = (async () => {\n        if (this._serverInfo === undefined) {\n          try {\n            this._serverInfo = await this._getServerInfo();\n          } catch (e) {\n            console.warn(`[WARNING]: LangSmith failed to fetch info on supported operations with status code ${e.status}. Falling back to batch operations and default limits.`);\n          }\n        }\n        return this._serverInfo ?? {};\n      })();\n    }\n    return this._getServerInfoPromise.then(serverInfo => {\n      if (this._serverInfo === undefined) {\n        this._getServerInfoPromise = undefined;\n      }\n      return serverInfo;\n    });\n  }\n  async _getSettings() {\n    if (!this.settings) {\n      this.settings = this._get(\"/settings\");\n    }\n    return await this.settings;\n  }\n  /**\n   * Flushes current queued traces.\n   */\n  async flush() {\n    const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n    await this.drainAutoBatchQueue(sizeLimitBytes);\n  }\n  _cloneCurrentOTELContext() {\n    const otel_trace = getOTELTrace();\n    const otel_context = getOTELContext();\n    if (this.langSmithToOTELTranslator !== undefined) {\n      const currentSpan = otel_trace.getActiveSpan();\n      if (currentSpan) {\n        return otel_trace.setSpan(otel_context.active(), currentSpan);\n      }\n    }\n    return undefined;\n  }\n  async createRun(run, options) {\n    if (!this._filterForSampling([run]).length) {\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const session_name = run.project_name;\n    delete run.project_name;\n    const runCreate = await this.prepareRunCreateOrUpdateInputs({\n      session_name,\n      ...run,\n      start_time: run.start_time ?? Date.now()\n    });\n    if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n      const otelContext = this._cloneCurrentOTELContext();\n      void this.processRunOperation({\n        action: \"create\",\n        item: runCreate,\n        otelContext,\n        apiKey: options?.apiKey,\n        apiUrl: options?.apiUrl\n      }).catch(console.error);\n      return;\n    }\n    const mergedRunCreateParam = mergeRuntimeEnvIntoRun(runCreate);\n    if (options?.apiKey !== undefined) {\n      headers[\"x-api-key\"] = options.apiKey;\n    }\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${options?.apiUrl ?? this.apiUrl}/runs`, {\n      method: \"POST\",\n      headers,\n      body: serializePayloadForTracing(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"create run\", true);\n  }\n  /**\n   * Batch ingest/upsert multiple runs in the Langsmith system.\n   * @param runs\n   */\n  async batchIngestRuns({\n    runCreates,\n    runUpdates\n  }, options) {\n    if (runCreates === undefined && runUpdates === undefined) {\n      return;\n    }\n    let preparedCreateParams = await Promise.all(runCreates?.map(create => this.prepareRunCreateOrUpdateInputs(create)) ?? []);\n    let preparedUpdateParams = await Promise.all(runUpdates?.map(update => this.prepareRunCreateOrUpdateInputs(update)) ?? []);\n    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n      const createById = preparedCreateParams.reduce((params, run) => {\n        if (!run.id) {\n          return params;\n        }\n        params[run.id] = run;\n        return params;\n      }, {});\n      const standaloneUpdates = [];\n      for (const updateParam of preparedUpdateParams) {\n        if (updateParam.id !== undefined && createById[updateParam.id]) {\n          createById[updateParam.id] = {\n            ...createById[updateParam.id],\n            ...updateParam\n          };\n        } else {\n          standaloneUpdates.push(updateParam);\n        }\n      }\n      preparedCreateParams = Object.values(createById);\n      preparedUpdateParams = standaloneUpdates;\n    }\n    const rawBatch = {\n      post: preparedCreateParams,\n      patch: preparedUpdateParams\n    };\n    if (!rawBatch.post.length && !rawBatch.patch.length) {\n      return;\n    }\n    const batchChunks = {\n      post: [],\n      patch: []\n    };\n    for (const k of [\"post\", \"patch\"]) {\n      const key = k;\n      const batchItems = rawBatch[key].reverse();\n      let batchItem = batchItems.pop();\n      while (batchItem !== undefined) {\n        // Type is wrong but this is a deprecated code path anyway\n        batchChunks[key].push(batchItem);\n        batchItem = batchItems.pop();\n      }\n    }\n    if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n      const runIds = batchChunks.post.map(item => item.id).concat(batchChunks.patch.map(item => item.id)).join(\",\");\n      await this._postBatchIngestRuns(serializePayloadForTracing(batchChunks, `Ingesting runs with ids: ${runIds}`), options);\n    }\n  }\n  async _postBatchIngestRuns(body, options) {\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\"\n    };\n    if (options?.apiKey !== undefined) {\n      headers[\"x-api-key\"] = options.apiKey;\n    }\n    const response = await this.batchIngestCaller.call(_getFetchImplementation(this.debug), `${options?.apiUrl ?? this.apiUrl}/runs/batch`, {\n      method: \"POST\",\n      headers,\n      body: body,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"batch create run\", true);\n  }\n  /**\n   * Batch ingest/upsert multiple runs in the Langsmith system.\n   * @param runs\n   */\n  async multipartIngestRuns({\n    runCreates,\n    runUpdates\n  }, options) {\n    if (runCreates === undefined && runUpdates === undefined) {\n      return;\n    }\n    // transform and convert to dicts\n    const allAttachments = {};\n    let preparedCreateParams = [];\n    for (const create of runCreates ?? []) {\n      const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);\n      if (preparedCreate.id !== undefined && preparedCreate.attachments !== undefined) {\n        allAttachments[preparedCreate.id] = preparedCreate.attachments;\n      }\n      delete preparedCreate.attachments;\n      preparedCreateParams.push(preparedCreate);\n    }\n    let preparedUpdateParams = [];\n    for (const update of runUpdates ?? []) {\n      preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));\n    }\n    // require trace_id and dotted_order\n    const invalidRunCreate = preparedCreateParams.find(runCreate => {\n      return runCreate.trace_id === undefined || runCreate.dotted_order === undefined;\n    });\n    if (invalidRunCreate !== undefined) {\n      throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when creating a run`);\n    }\n    const invalidRunUpdate = preparedUpdateParams.find(runUpdate => {\n      return runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined;\n    });\n    if (invalidRunUpdate !== undefined) {\n      throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when updating a run`);\n    }\n    // combine post and patch dicts where possible\n    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n      const createById = preparedCreateParams.reduce((params, run) => {\n        if (!run.id) {\n          return params;\n        }\n        params[run.id] = run;\n        return params;\n      }, {});\n      const standaloneUpdates = [];\n      for (const updateParam of preparedUpdateParams) {\n        if (updateParam.id !== undefined && createById[updateParam.id]) {\n          createById[updateParam.id] = {\n            ...createById[updateParam.id],\n            ...updateParam\n          };\n        } else {\n          standaloneUpdates.push(updateParam);\n        }\n      }\n      preparedCreateParams = Object.values(createById);\n      preparedUpdateParams = standaloneUpdates;\n    }\n    if (preparedCreateParams.length === 0 && preparedUpdateParams.length === 0) {\n      return;\n    }\n    // send the runs in multipart requests\n    const accumulatedContext = [];\n    const accumulatedParts = [];\n    for (const [method, payloads] of [[\"post\", preparedCreateParams], [\"patch\", preparedUpdateParams]]) {\n      for (const originalPayload of payloads) {\n        // collect fields to be sent as separate parts\n        const {\n          inputs,\n          outputs,\n          events,\n          extra,\n          error,\n          serialized,\n          attachments,\n          ...payload\n        } = originalPayload;\n        const fields = {\n          inputs,\n          outputs,\n          events,\n          extra,\n          error,\n          serialized\n        };\n        // encode the main run payload\n        const stringifiedPayload = serializePayloadForTracing(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);\n        accumulatedParts.push({\n          name: `${method}.${payload.id}`,\n          payload: new Blob([stringifiedPayload], {\n            type: `application/json; length=${stringifiedPayload.length}` // encoding=gzip\n          })\n        });\n        // encode the fields we collected\n        for (const [key, value] of Object.entries(fields)) {\n          if (value === undefined) {\n            continue;\n          }\n          const stringifiedValue = serializePayloadForTracing(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);\n          accumulatedParts.push({\n            name: `${method}.${payload.id}.${key}`,\n            payload: new Blob([stringifiedValue], {\n              type: `application/json; length=${stringifiedValue.length}`\n            })\n          });\n        }\n        // encode the attachments\n        if (payload.id !== undefined) {\n          const attachments = allAttachments[payload.id];\n          if (attachments) {\n            delete allAttachments[payload.id];\n            for (const [name, attachment] of Object.entries(attachments)) {\n              let contentType;\n              let content;\n              if (Array.isArray(attachment)) {\n                [contentType, content] = attachment;\n              } else {\n                contentType = attachment.mimeType;\n                content = attachment.data;\n              }\n              // Validate that the attachment name doesn't contain a '.'\n              if (name.includes(\".\")) {\n                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. ` + `Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);\n                continue;\n              }\n              accumulatedParts.push({\n                name: `attachment.${payload.id}.${name}`,\n                payload: new Blob([content], {\n                  type: `${contentType}; length=${content.byteLength}`\n                })\n              });\n            }\n          }\n        }\n        // compute context\n        accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);\n      }\n    }\n    await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join(\"; \"), options);\n  }\n  async _createNodeFetchBody(parts, boundary) {\n    // Create multipart form data manually using Blobs\n    const chunks = [];\n    for (const part of parts) {\n      // Add field boundary\n      chunks.push(new Blob([`--${boundary}\\r\\n`]));\n      chunks.push(new Blob([`Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`, `Content-Type: ${part.payload.type}\\r\\n\\r\\n`]));\n      chunks.push(part.payload);\n      chunks.push(new Blob([\"\\r\\n\"]));\n    }\n    // Add final boundary\n    chunks.push(new Blob([`--${boundary}--\\r\\n`]));\n    // Combine all chunks into a single Blob\n    const body = new Blob(chunks);\n    // Convert Blob to ArrayBuffer for compatibility\n    const arrayBuffer = await body.arrayBuffer();\n    return arrayBuffer;\n  }\n  async _createMultipartStream(parts, boundary) {\n    const encoder = new TextEncoder();\n    // Create a ReadableStream for streaming the multipart data\n    // Only do special handling if we're using node-fetch\n    const stream = new ReadableStream({\n      async start(controller) {\n        // Helper function to write a chunk to the stream\n        const writeChunk = async chunk => {\n          if (typeof chunk === \"string\") {\n            controller.enqueue(encoder.encode(chunk));\n          } else {\n            controller.enqueue(chunk);\n          }\n        };\n        // Write each part to the stream\n        for (const part of parts) {\n          // Write boundary and headers\n          await writeChunk(`--${boundary}\\r\\n`);\n          await writeChunk(`Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`);\n          await writeChunk(`Content-Type: ${part.payload.type}\\r\\n\\r\\n`);\n          // Write the payload\n          const payloadStream = part.payload.stream();\n          const reader = payloadStream.getReader();\n          try {\n            let result;\n            while (!(result = await reader.read()).done) {\n              controller.enqueue(result.value);\n            }\n          } finally {\n            reader.releaseLock();\n          }\n          await writeChunk(\"\\r\\n\");\n        }\n        // Write final boundary\n        await writeChunk(`--${boundary}--\\r\\n`);\n        controller.close();\n      }\n    });\n    return stream;\n  }\n  async _sendMultipartRequest(parts, context, options) {\n    // Create multipart form data boundary\n    const boundary = \"----LangSmithFormBoundary\" + Math.random().toString(36).slice(2);\n    const isNodeFetch = _globalFetchImplementationIsNodeFetch();\n    const buildBuffered = () => this._createNodeFetchBody(parts, boundary);\n    const buildStream = () => this._createMultipartStream(parts, boundary);\n    const send = async body => {\n      const headers = {\n        ...this.headers,\n        \"Content-Type\": `multipart/form-data; boundary=${boundary}`\n      };\n      if (options?.apiKey !== undefined) {\n        headers[\"x-api-key\"] = options.apiKey;\n      }\n      return this.batchIngestCaller.call(_getFetchImplementation(this.debug), `${options?.apiUrl ?? this.apiUrl}/runs/multipart`, {\n        method: \"POST\",\n        headers,\n        body,\n        duplex: \"half\",\n        signal: AbortSignal.timeout(this.timeout_ms),\n        ...this.fetchOptions\n      });\n    };\n    try {\n      let res;\n      let streamedAttempt = false;\n      // attempt stream only if not disabled and not using node-fetch\n      if (!isNodeFetch && !this.multipartStreamingDisabled) {\n        streamedAttempt = true;\n        res = await send(await buildStream());\n      } else {\n        res = await send(await buildBuffered());\n      }\n      // if stream fails, fallback to buffered body\n      if ((!this.multipartStreamingDisabled || streamedAttempt) && res.status === 422 && (options?.apiUrl ?? this.apiUrl) !== DEFAULT_API_URL) {\n        console.warn(`Streaming multipart upload to ${options?.apiUrl ?? this.apiUrl}/runs/multipart failed. ` + `This usually means the host does not support chunked uploads. ` + `Retrying with a buffered upload for operation \"${context}\".`);\n        // Disable streaming for future requests\n        this.multipartStreamingDisabled = true;\n        // retry with fully-buffered body\n        res = await send(await buildBuffered());\n      }\n      // raise if still failing\n      await raiseForStatus(res, \"ingest multipart runs\", true);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e) {\n      console.warn(`${e.message.trim()}\\n\\nContext: ${context}`);\n    }\n  }\n  async updateRun(runId, run, options) {\n    assertUuid(runId);\n    if (run.inputs) {\n      run.inputs = await this.processInputs(run.inputs);\n    }\n    if (run.outputs) {\n      run.outputs = await this.processOutputs(run.outputs);\n    }\n    // TODO: Untangle types\n    const data = {\n      ...run,\n      id: runId\n    };\n    if (!this._filterForSampling([data], true).length) {\n      return;\n    }\n    if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n      const otelContext = this._cloneCurrentOTELContext();\n      if (run.end_time !== undefined && data.parent_run_id === undefined && this.blockOnRootRunFinalization && !this.manualFlushMode) {\n        // Trigger batches as soon as a root trace ends and wait to ensure trace finishes\n        // in serverless environments.\n        await this.processRunOperation({\n          action: \"update\",\n          item: data,\n          otelContext,\n          apiKey: options?.apiKey,\n          apiUrl: options?.apiUrl\n        }).catch(console.error);\n        return;\n      } else {\n        void this.processRunOperation({\n          action: \"update\",\n          item: data,\n          otelContext,\n          apiKey: options?.apiKey,\n          apiUrl: options?.apiUrl\n        }).catch(console.error);\n      }\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    if (options?.apiKey !== undefined) {\n      headers[\"x-api-key\"] = options.apiKey;\n    }\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${options?.apiUrl ?? this.apiUrl}/runs/${runId}`, {\n      method: \"PATCH\",\n      headers,\n      body: serializePayloadForTracing(run, `Serializing payload to update run with id: ${runId}`),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"update run\", true);\n  }\n  async readRun(runId, {\n    loadChildRuns\n  } = {\n    loadChildRuns: false\n  }) {\n    assertUuid(runId);\n    let run = await this._get(`/runs/${runId}`);\n    if (loadChildRuns) {\n      run = await this._loadChildRuns(run);\n    }\n    return run;\n  }\n  async getRunUrl({\n    runId,\n    run,\n    projectOpts\n  }) {\n    if (run !== undefined) {\n      let sessionId;\n      if (run.session_id) {\n        sessionId = run.session_id;\n      } else if (projectOpts?.projectName) {\n        sessionId = (await this.readProject({\n          projectName: projectOpts?.projectName\n        })).id;\n      } else if (projectOpts?.projectId) {\n        sessionId = projectOpts?.projectId;\n      } else {\n        const project = await this.readProject({\n          projectName: getLangSmithEnvironmentVariable(\"PROJECT\") || \"default\"\n        });\n        sessionId = project.id;\n      }\n      const tenantId = await this._getTenantId();\n      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n    } else if (runId !== undefined) {\n      const run_ = await this.readRun(runId);\n      if (!run_.app_path) {\n        throw new Error(`Run ${runId} has no app_path`);\n      }\n      const baseUrl = this.getHostUrl();\n      return `${baseUrl}${run_.app_path}`;\n    } else {\n      throw new Error(\"Must provide either runId or run\");\n    }\n  }\n  async _loadChildRuns(run) {\n    const childRuns = await toArray(this.listRuns({\n      isRoot: false,\n      projectId: run.session_id,\n      traceId: run.trace_id\n    }));\n    const treemap = {};\n    const runs = {};\n    // TODO: make dotted order required when the migration finishes\n    childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n    for (const childRun of childRuns) {\n      if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n        throw new Error(`Child run ${childRun.id} has no parent`);\n      }\n      if (childRun.dotted_order?.startsWith(run.dotted_order ?? \"\") && childRun.id !== run.id) {\n        if (!(childRun.parent_run_id in treemap)) {\n          treemap[childRun.parent_run_id] = [];\n        }\n        treemap[childRun.parent_run_id].push(childRun);\n        runs[childRun.id] = childRun;\n      }\n    }\n    run.child_runs = treemap[run.id] || [];\n    for (const runId in treemap) {\n      if (runId !== run.id) {\n        runs[runId].child_runs = treemap[runId];\n      }\n    }\n    return run;\n  }\n  /**\n   * List runs from the LangSmith server.\n   * @param projectId - The ID of the project to filter by.\n   * @param projectName - The name of the project to filter by.\n   * @param parentRunId - The ID of the parent run to filter by.\n   * @param traceId - The ID of the trace to filter by.\n   * @param referenceExampleId - The ID of the reference example to filter by.\n   * @param startTime - The start time to filter by.\n   * @param isRoot - Indicates whether to only return root runs.\n   * @param runType - The run type to filter by.\n   * @param error - Indicates whether to filter by error runs.\n   * @param id - The ID of the run to filter by.\n   * @param query - The query string to filter by.\n   * @param filter - The filter string to apply to the run spans.\n   * @param traceFilter - The filter string to apply on the root run of the trace.\n   * @param treeFilter - The filter string to apply on other runs in the trace.\n   * @param limit - The maximum number of runs to retrieve.\n   * @returns {AsyncIterable<Run>} - The runs.\n   *\n   * @example\n   * // List all runs in a project\n   * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n   *\n   * @example\n   * // List LLM and Chat runs in the last 24 hours\n   * const todaysLLMRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n   *   run_type: \"llm\",\n   * });\n   *\n   * @example\n   * // List traces in a project\n   * const rootRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   execution_order: 1,\n   * });\n   *\n   * @example\n   * // List runs without errors\n   * const correctRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   error: false,\n   * });\n   *\n   * @example\n   * // List runs by run ID\n   * const runIds = [\n   *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n   *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n   * ];\n   * const selectedRuns = client.listRuns({ run_ids: runIds });\n   *\n   * @example\n   * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n   * const chainRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n   * });\n   *\n   * @example\n   * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n   * const goodExtractorRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   filter: 'eq(name, \"extractor\")',\n   *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n   * });\n   *\n   * @example\n   * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n   * const complexRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n   * });\n   *\n   * @example\n   * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n   * const taggedRuns = client.listRuns({\n   *   projectName: \"<your_project>\",\n   *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n   * });\n   */\n  async *listRuns(props) {\n    const {\n      projectId,\n      projectName,\n      parentRunId,\n      traceId,\n      referenceExampleId,\n      startTime,\n      executionOrder,\n      isRoot,\n      runType,\n      error,\n      id,\n      query,\n      filter,\n      traceFilter,\n      treeFilter,\n      limit,\n      select,\n      order\n    } = props;\n    let projectIds = [];\n    if (projectId) {\n      projectIds = Array.isArray(projectId) ? projectId : [projectId];\n    }\n    if (projectName) {\n      const projectNames = Array.isArray(projectName) ? projectName : [projectName];\n      const projectIds_ = await Promise.all(projectNames.map(name => this.readProject({\n        projectName: name\n      }).then(project => project.id)));\n      projectIds.push(...projectIds_);\n    }\n    const default_select = [\"app_path\", \"completion_cost\", \"completion_tokens\", \"dotted_order\", \"end_time\", \"error\", \"events\", \"extra\", \"feedback_stats\", \"first_token_time\", \"id\", \"inputs\", \"name\", \"outputs\", \"parent_run_id\", \"parent_run_ids\", \"prompt_cost\", \"prompt_tokens\", \"reference_example_id\", \"run_type\", \"session_id\", \"start_time\", \"status\", \"tags\", \"total_cost\", \"total_tokens\", \"trace_id\"];\n    const body = {\n      session: projectIds.length ? projectIds : null,\n      run_type: runType,\n      reference_example: referenceExampleId,\n      query,\n      filter,\n      trace_filter: traceFilter,\n      tree_filter: treeFilter,\n      execution_order: executionOrder,\n      parent_run: parentRunId,\n      start_time: startTime ? startTime.toISOString() : null,\n      error,\n      id,\n      limit,\n      trace: traceId,\n      select: select ? select : default_select,\n      is_root: isRoot,\n      order\n    };\n    let runsYielded = 0;\n    for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n      if (limit) {\n        if (runsYielded >= limit) {\n          break;\n        }\n        if (runs.length + runsYielded > limit) {\n          const newRuns = runs.slice(0, limit - runsYielded);\n          yield* newRuns;\n          break;\n        }\n        runsYielded += runs.length;\n        yield* runs;\n      } else {\n        yield* runs;\n      }\n    }\n  }\n  async *listGroupRuns(props) {\n    const {\n      projectId,\n      projectName,\n      groupBy,\n      filter,\n      startTime,\n      endTime,\n      limit,\n      offset\n    } = props;\n    const sessionId = projectId || (await this.readProject({\n      projectName\n    })).id;\n    const baseBody = {\n      session_id: sessionId,\n      group_by: groupBy,\n      filter,\n      start_time: startTime ? startTime.toISOString() : null,\n      end_time: endTime ? endTime.toISOString() : null,\n      limit: Number(limit) || 100\n    };\n    let currentOffset = Number(offset) || 0;\n    const path = \"/runs/group\";\n    const url = `${this.apiUrl}${path}`;\n    while (true) {\n      const currentBody = {\n        ...baseBody,\n        offset: currentOffset\n      };\n      // Remove undefined values from the payload\n      const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value]) => value !== undefined));\n      const response = await this.caller.call(_getFetchImplementation(), url, {\n        method: \"POST\",\n        headers: {\n          ...this.headers,\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(filteredPayload),\n        signal: AbortSignal.timeout(this.timeout_ms),\n        ...this.fetchOptions\n      });\n      await raiseForStatus(response, `Failed to fetch ${path}`);\n      const items = await response.json();\n      const {\n        groups,\n        total\n      } = items;\n      if (groups.length === 0) {\n        break;\n      }\n      for (const thread of groups) {\n        yield thread;\n      }\n      currentOffset += groups.length;\n      if (currentOffset >= total) {\n        break;\n      }\n    }\n  }\n  async getRunStats({\n    id,\n    trace,\n    parentRun,\n    runType,\n    projectNames,\n    projectIds,\n    referenceExampleIds,\n    startTime,\n    endTime,\n    error,\n    query,\n    filter,\n    traceFilter,\n    treeFilter,\n    isRoot,\n    dataSourceType\n  }) {\n    let projectIds_ = projectIds || [];\n    if (projectNames) {\n      projectIds_ = [...(projectIds || []), ...(await Promise.all(projectNames.map(name => this.readProject({\n        projectName: name\n      }).then(project => project.id))))];\n    }\n    const payload = {\n      id,\n      trace,\n      parent_run: parentRun,\n      run_type: runType,\n      session: projectIds_,\n      reference_example: referenceExampleIds,\n      start_time: startTime,\n      end_time: endTime,\n      error,\n      query,\n      filter,\n      trace_filter: traceFilter,\n      tree_filter: treeFilter,\n      is_root: isRoot,\n      data_source_type: dataSourceType\n    };\n    // Remove undefined values from the payload\n    const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== undefined));\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/stats`, {\n      method: \"POST\",\n      headers: this.headers,\n      body: JSON.stringify(filteredPayload),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const result = await response.json();\n    return result;\n  }\n  async shareRun(runId, {\n    shareId\n  } = {}) {\n    const data = {\n      run_id: runId,\n      share_token: shareId || uuid.v4()\n    };\n    assertUuid(runId);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      throw new Error(\"Invalid response from server\");\n    }\n    return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n  }\n  async unshareRun(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"unshare run\", true);\n  }\n  async readRunSharedLink(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      return undefined;\n    }\n    return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n  }\n  async listSharedRuns(shareToken, {\n    runIds\n  } = {}) {\n    const queryParams = new URLSearchParams({\n      share_token: shareToken\n    });\n    if (runIds !== undefined) {\n      for (const runId of runIds) {\n        queryParams.append(\"id\", runId);\n      }\n    }\n    assertUuid(shareToken);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const runs = await response.json();\n    return runs;\n  }\n  async readDatasetSharedSchema(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    assertUuid(datasetId);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n    return shareSchema;\n  }\n  async shareDataset(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    const data = {\n      dataset_id: datasetId\n    };\n    assertUuid(datasetId);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n    return shareSchema;\n  }\n  async unshareDataset(datasetId) {\n    assertUuid(datasetId);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"unshare dataset\", true);\n  }\n  async readSharedDataset(shareToken) {\n    assertUuid(shareToken);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/public/${shareToken}/datasets`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const dataset = await response.json();\n    return dataset;\n  }\n  /**\n   * Get shared examples.\n   *\n   * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.\n   * @param {Object} [options] Additional options for listing the examples.\n   * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.\n   * @returns {Promise<Example[]>} The shared examples.\n   */\n  async listSharedExamples(shareToken, options) {\n    const params = {};\n    if (options?.exampleIds) {\n      params.id = options.exampleIds;\n    }\n    const urlParams = new URLSearchParams();\n    Object.entries(params).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        value.forEach(v => urlParams.append(key, v));\n      } else {\n        urlParams.append(key, value);\n      }\n    });\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      if (\"detail\" in result) {\n        throw new Error(`Failed to list shared examples.\\nStatus: ${response.status}\\nMessage: ${Array.isArray(result.detail) ? result.detail.join(\"\\n\") : \"Unspecified error\"}`);\n      }\n      throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);\n    }\n    return result.map(example => ({\n      ...example,\n      _hostUrl: this.getHostUrl()\n    }));\n  }\n  async createProject({\n    projectName,\n    description = null,\n    metadata = null,\n    upsert = false,\n    projectExtra = null,\n    referenceDatasetId = null\n  }) {\n    const upsert_ = upsert ? `?upsert=true` : \"\";\n    const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n    const extra = projectExtra || {};\n    if (metadata) {\n      extra[\"metadata\"] = metadata;\n    }\n    const body = {\n      name: projectName,\n      extra,\n      description\n    };\n    if (referenceDatasetId !== null) {\n      body[\"reference_dataset_id\"] = referenceDatasetId;\n    }\n    const response = await this.caller.call(_getFetchImplementation(this.debug), endpoint, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"create project\");\n    const result = await response.json();\n    return result;\n  }\n  async updateProject(projectId, {\n    name = null,\n    description = null,\n    metadata = null,\n    projectExtra = null,\n    endTime = null\n  }) {\n    const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n    let extra = projectExtra;\n    if (metadata) {\n      extra = {\n        ...(extra || {}),\n        metadata\n      };\n    }\n    const body = {\n      name,\n      extra,\n      description,\n      end_time: endTime ? new Date(endTime).toISOString() : null\n    };\n    const response = await this.caller.call(_getFetchImplementation(this.debug), endpoint, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"update project\");\n    const result = await response.json();\n    return result;\n  }\n  async hasProject({\n    projectId,\n    projectName\n  }) {\n    // TODO: Add a head request\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      assertUuid(projectId);\n      path += `/${projectId}`;\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${path}?${params}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    try {\n      const result = await response.json();\n      if (!response.ok) {\n        return false;\n      }\n      // If it's OK and we're querying by name, need to check the list is not empty\n      if (Array.isArray(result)) {\n        return result.length > 0;\n      }\n      // projectId querying\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  async readProject({\n    projectId,\n    projectName,\n    includeStats\n  }) {\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      assertUuid(projectId);\n      path += `/${projectId}`;\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    if (includeStats !== undefined) {\n      params.append(\"include_stats\", includeStats.toString());\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async getProjectUrl({\n    projectId,\n    projectName\n  }) {\n    if (projectId === undefined && projectName === undefined) {\n      throw new Error(\"Must provide either projectName or projectId\");\n    }\n    const project = await this.readProject({\n      projectId,\n      projectName\n    });\n    const tenantId = await this._getTenantId();\n    return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n  }\n  async getDatasetUrl({\n    datasetId,\n    datasetName\n  }) {\n    if (datasetId === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    }\n    const dataset = await this.readDataset({\n      datasetId,\n      datasetName\n    });\n    const tenantId = await this._getTenantId();\n    return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n  }\n  async _getTenantId() {\n    if (this._tenantId !== null) {\n      return this._tenantId;\n    }\n    const queryParams = new URLSearchParams({\n      limit: \"1\"\n    });\n    for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n      this._tenantId = projects[0].tenant_id;\n      return projects[0].tenant_id;\n    }\n    throw new Error(\"No projects found to resolve tenant.\");\n  }\n  async *listProjects({\n    projectIds,\n    name,\n    nameContains,\n    referenceDatasetId,\n    referenceDatasetName,\n    referenceFree,\n    metadata\n  } = {}) {\n    const params = new URLSearchParams();\n    if (projectIds !== undefined) {\n      for (const projectId of projectIds) {\n        params.append(\"id\", projectId);\n      }\n    }\n    if (name !== undefined) {\n      params.append(\"name\", name);\n    }\n    if (nameContains !== undefined) {\n      params.append(\"name_contains\", nameContains);\n    }\n    if (referenceDatasetId !== undefined) {\n      params.append(\"reference_dataset\", referenceDatasetId);\n    } else if (referenceDatasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName: referenceDatasetName\n      });\n      params.append(\"reference_dataset\", dataset.id);\n    }\n    if (referenceFree !== undefined) {\n      params.append(\"reference_free\", referenceFree.toString());\n    }\n    if (metadata !== undefined) {\n      params.append(\"metadata\", JSON.stringify(metadata));\n    }\n    for await (const projects of this._getPaginated(\"/sessions\", params)) {\n      yield* projects;\n    }\n  }\n  async deleteProject({\n    projectId,\n    projectName\n  }) {\n    let projectId_;\n    if (projectId === undefined && projectName === undefined) {\n      throw new Error(\"Must provide projectName or projectId\");\n    } else if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId === undefined) {\n      projectId_ = (await this.readProject({\n        projectName\n      })).id;\n    } else {\n      projectId_ = projectId;\n    }\n    assertUuid(projectId_);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/sessions/${projectId_}`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, `delete session ${projectId_} (${projectName})`, true);\n  }\n  async uploadCsv({\n    csvFile,\n    fileName,\n    inputKeys,\n    outputKeys,\n    description,\n    dataType,\n    name\n  }) {\n    const url = `${this.apiUrl}/datasets/upload`;\n    const formData = new FormData();\n    formData.append(\"file\", csvFile, fileName);\n    inputKeys.forEach(key => {\n      formData.append(\"input_keys\", key);\n    });\n    outputKeys.forEach(key => {\n      formData.append(\"output_keys\", key);\n    });\n    if (description) {\n      formData.append(\"description\", description);\n    }\n    if (dataType) {\n      formData.append(\"data_type\", dataType);\n    }\n    if (name) {\n      formData.append(\"name\", name);\n    }\n    const response = await this.caller.call(_getFetchImplementation(this.debug), url, {\n      method: \"POST\",\n      headers: this.headers,\n      body: formData,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"upload CSV\");\n    const result = await response.json();\n    return result;\n  }\n  async createDataset(name, {\n    description,\n    dataType,\n    inputsSchema,\n    outputsSchema,\n    metadata\n  } = {}) {\n    const body = {\n      name,\n      description,\n      extra: metadata ? {\n        metadata\n      } : undefined\n    };\n    if (dataType) {\n      body.data_type = dataType;\n    }\n    if (inputsSchema) {\n      body.inputs_schema_definition = inputsSchema;\n    }\n    if (outputsSchema) {\n      body.outputs_schema_definition = outputsSchema;\n    }\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"create dataset\");\n    const result = await response.json();\n    return result;\n  }\n  async readDataset({\n    datasetId,\n    datasetName\n  }) {\n    let path = \"/datasets\";\n    // limit to 1 result\n    const params = new URLSearchParams({\n      limit: \"1\"\n    });\n    if (datasetId && datasetName) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId) {\n      assertUuid(datasetId);\n      path += `/${datasetId}`;\n    } else if (datasetName) {\n      params.append(\"name\", datasetName);\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async hasDataset({\n    datasetId,\n    datasetName\n  }) {\n    try {\n      await this.readDataset({\n        datasetId,\n        datasetName\n      });\n      return true;\n    } catch (e) {\n      if (\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      e instanceof Error && e.message.toLocaleLowerCase().includes(\"not found\")) {\n        return false;\n      }\n      throw e;\n    }\n  }\n  async diffDatasetVersions({\n    datasetId,\n    datasetName,\n    fromVersion,\n    toVersion\n  }) {\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const urlParams = new URLSearchParams({\n      from_version: typeof fromVersion === \"string\" ? fromVersion : fromVersion.toISOString(),\n      to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString()\n    });\n    const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n    return response;\n  }\n  async readDatasetOpenaiFinetuning({\n    datasetId,\n    datasetName\n  }) {\n    const path = \"/datasets\";\n    if (datasetId !== undefined) {\n      // do nothing\n    } else if (datasetName !== undefined) {\n      datasetId = (await this.readDataset({\n        datasetName\n      })).id;\n    } else {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    }\n    const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n    const datasetText = await response.text();\n    const dataset = datasetText.trim().split(\"\\n\").map(line => JSON.parse(line));\n    return dataset;\n  }\n  async *listDatasets({\n    limit = 100,\n    offset = 0,\n    datasetIds,\n    datasetName,\n    datasetNameContains,\n    metadata\n  } = {}) {\n    const path = \"/datasets\";\n    const params = new URLSearchParams({\n      limit: limit.toString(),\n      offset: offset.toString()\n    });\n    if (datasetIds !== undefined) {\n      for (const id_ of datasetIds) {\n        params.append(\"id\", id_);\n      }\n    }\n    if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    }\n    if (datasetNameContains !== undefined) {\n      params.append(\"name_contains\", datasetNameContains);\n    }\n    if (metadata !== undefined) {\n      params.append(\"metadata\", JSON.stringify(metadata));\n    }\n    for await (const datasets of this._getPaginated(path, params)) {\n      yield* datasets;\n    }\n  }\n  /**\n   * Update a dataset\n   * @param props The dataset details to update\n   * @returns The updated dataset\n   */\n  async updateDataset(props) {\n    const {\n      datasetId,\n      datasetName,\n      ...update\n    } = props;\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    }\n    const _datasetId = datasetId ?? (await this.readDataset({\n      datasetName\n    })).id;\n    assertUuid(_datasetId);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${_datasetId}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(update),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"update dataset\");\n    return await response.json();\n  }\n  /**\n   * Updates a tag on a dataset.\n   *\n   * If the tag is already assigned to a different version of this dataset,\n   * the tag will be moved to the new version. The as_of parameter is used to\n   * determine which version of the dataset to apply the new tags to.\n   *\n   * It must be an exact version of the dataset to succeed. You can\n   * use the \"readDatasetVersion\" method to find the exact version\n   * to apply the tags to.\n   * @param params.datasetId The ID of the dataset to update. Must be provided if \"datasetName\" is not provided.\n   * @param params.datasetName The name of the dataset to update. Must be provided if \"datasetId\" is not provided.\n   * @param params.asOf The timestamp of the dataset to apply the new tags to.\n   * @param params.tag The new tag to apply to the dataset.\n   */\n  async updateDatasetTag(props) {\n    const {\n      datasetId,\n      datasetName,\n      asOf,\n      tag\n    } = props;\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    }\n    const _datasetId = datasetId ?? (await this.readDataset({\n      datasetName\n    })).id;\n    assertUuid(_datasetId);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${_datasetId}/tags`, {\n      method: \"PUT\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        as_of: typeof asOf === \"string\" ? asOf : asOf.toISOString(),\n        tag\n      }),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"update dataset tags\");\n  }\n  async deleteDataset({\n    datasetId,\n    datasetName\n  }) {\n    let path = \"/datasets\";\n    let datasetId_ = datasetId;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    if (datasetId_ !== undefined) {\n      assertUuid(datasetId_);\n      path += `/${datasetId_}`;\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this.caller.call(_getFetchImplementation(this.debug), this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, `delete ${path}`);\n    await response.json();\n  }\n  async indexDataset({\n    datasetId,\n    datasetName,\n    tag\n  }) {\n    let datasetId_ = datasetId;\n    if (!datasetId_ && !datasetName) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ && datasetName) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (!datasetId_) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    assertUuid(datasetId_);\n    const data = {\n      tag: tag\n    };\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId_}/index`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"index dataset\");\n    await response.json();\n  }\n  /**\n   * Lets you run a similarity search query on a dataset.\n   *\n   * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.\n   *\n   * @param inputs      The input on which to run the similarity search. Must have the\n   *                    same schema as the dataset.\n   *\n   * @param datasetId   The dataset to search for similar examples.\n   *\n   * @param limit       The maximum number of examples to return. Will return the top `limit` most\n   *                    similar examples in order of most similar to least similar. If no similar\n   *                    examples are found, random examples will be returned.\n   *\n   * @param filter      A filter string to apply to the search. Only examples will be returned that\n   *                    match the filter string. Some examples of filters\n   *\n   *                    - eq(metadata.mykey, \"value\")\n   *                    - and(neq(metadata.my.nested.key, \"value\"), neq(metadata.mykey, \"value\"))\n   *                    - or(eq(metadata.mykey, \"value\"), eq(metadata.mykey, \"othervalue\"))\n   *\n   * @returns           A list of similar examples.\n   *\n   *\n   * @example\n   * dataset_id = \"123e4567-e89b-12d3-a456-426614174000\"\n   * inputs = {\"text\": \"How many people live in Berlin?\"}\n   * limit = 5\n   * examples = await client.similarExamples(inputs, dataset_id, limit)\n   */\n  async similarExamples(inputs, datasetId, limit, {\n    filter\n  } = {}) {\n    const data = {\n      limit: limit,\n      inputs: inputs\n    };\n    if (filter !== undefined) {\n      data[\"filter\"] = filter;\n    }\n    assertUuid(datasetId);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/search`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"fetch similar examples\");\n    const result = await response.json();\n    return result[\"examples\"];\n  }\n  async createExample(inputsOrUpdate, outputs, options) {\n    if (isExampleCreate(inputsOrUpdate)) {\n      if (outputs !== undefined || options !== undefined) {\n        throw new Error(\"Cannot provide outputs or options when using ExampleCreate object\");\n      }\n    }\n    let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;\n    const datasetName_ = outputs ? options?.datasetName : inputsOrUpdate.dataset_name;\n    if (datasetId_ === undefined && datasetName_ === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName: datasetName_\n      });\n      datasetId_ = dataset.id;\n    }\n    const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || new Date();\n    let data;\n    if (!isExampleCreate(inputsOrUpdate)) {\n      data = {\n        inputs: inputsOrUpdate,\n        outputs,\n        created_at: createdAt_?.toISOString(),\n        id: options?.exampleId,\n        metadata: options?.metadata,\n        split: options?.split,\n        source_run_id: options?.sourceRunId,\n        use_source_run_io: options?.useSourceRunIO,\n        use_source_run_attachments: options?.useSourceRunAttachments,\n        attachments: options?.attachments\n      };\n    } else {\n      data = inputsOrUpdate;\n    }\n    const response = await this._uploadExamplesMultipart(datasetId_, [data]);\n    const example = await this.readExample(response.example_ids?.[0] ?? uuid.v4());\n    return example;\n  }\n  async createExamples(propsOrUploads) {\n    if (Array.isArray(propsOrUploads)) {\n      if (propsOrUploads.length === 0) {\n        return [];\n      }\n      const uploads = propsOrUploads;\n      let datasetId_ = uploads[0].dataset_id;\n      const datasetName_ = uploads[0].dataset_name;\n      if (datasetId_ === undefined && datasetName_ === undefined) {\n        throw new Error(\"Must provide either datasetName or datasetId\");\n      } else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n        throw new Error(\"Must provide either datasetName or datasetId, not both\");\n      } else if (datasetId_ === undefined) {\n        const dataset = await this.readDataset({\n          datasetName: datasetName_\n        });\n        datasetId_ = dataset.id;\n      }\n      const response = await this._uploadExamplesMultipart(datasetId_, uploads);\n      const examples = await Promise.all(response.example_ids.map(id => this.readExample(id)));\n      return examples;\n    }\n    const {\n      inputs,\n      outputs,\n      metadata,\n      splits,\n      sourceRunIds,\n      useSourceRunIOs,\n      useSourceRunAttachments,\n      attachments,\n      exampleIds,\n      datasetId,\n      datasetName\n    } = propsOrUploads;\n    if (inputs === undefined) {\n      throw new Error(\"Must provide inputs when using legacy parameters\");\n    }\n    let datasetId_ = datasetId;\n    const datasetName_ = datasetName;\n    if (datasetId_ === undefined && datasetName_ === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName: datasetName_\n      });\n      datasetId_ = dataset.id;\n    }\n    const formattedExamples = inputs.map((input, idx) => {\n      return {\n        dataset_id: datasetId_,\n        inputs: input,\n        outputs: outputs?.[idx],\n        metadata: metadata?.[idx],\n        split: splits?.[idx],\n        id: exampleIds?.[idx],\n        attachments: attachments?.[idx],\n        source_run_id: sourceRunIds?.[idx],\n        use_source_run_io: useSourceRunIOs?.[idx],\n        use_source_run_attachments: useSourceRunAttachments?.[idx]\n      };\n    });\n    const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);\n    const examples = await Promise.all(response.example_ids.map(id => this.readExample(id)));\n    return examples;\n  }\n  async createLLMExample(input, generation, options) {\n    return this.createExample({\n      input\n    }, {\n      output: generation\n    }, options);\n  }\n  async createChatExample(input, generations, options) {\n    const finalInput = input.map(message => {\n      if (isLangChainMessage(message)) {\n        return convertLangChainMessageToExample(message);\n      }\n      return message;\n    });\n    const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;\n    return this.createExample({\n      input: finalInput\n    }, {\n      output: finalOutput\n    }, options);\n  }\n  async readExample(exampleId) {\n    assertUuid(exampleId);\n    const path = `/examples/${exampleId}`;\n    const rawExample = await this._get(path);\n    const {\n      attachment_urls,\n      ...rest\n    } = rawExample;\n    const example = rest;\n    if (attachment_urls) {\n      example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {\n        acc[key.slice(\"attachment.\".length)] = {\n          presigned_url: value.presigned_url,\n          mime_type: value.mime_type\n        };\n        return acc;\n      }, {});\n    }\n    return example;\n  }\n  async *listExamples({\n    datasetId,\n    datasetName,\n    exampleIds,\n    asOf,\n    splits,\n    inlineS3Urls,\n    metadata,\n    limit,\n    offset,\n    filter,\n    includeAttachments\n  } = {}) {\n    let datasetId_;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      datasetId_ = datasetId;\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    } else {\n      throw new Error(\"Must provide a datasetName or datasetId\");\n    }\n    const params = new URLSearchParams({\n      dataset: datasetId_\n    });\n    const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n    if (dataset_version) {\n      params.append(\"as_of\", dataset_version);\n    }\n    const inlineS3Urls_ = inlineS3Urls ?? true;\n    params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n    if (exampleIds !== undefined) {\n      for (const id_ of exampleIds) {\n        params.append(\"id\", id_);\n      }\n    }\n    if (splits !== undefined) {\n      for (const split of splits) {\n        params.append(\"splits\", split);\n      }\n    }\n    if (metadata !== undefined) {\n      const serializedMetadata = JSON.stringify(metadata);\n      params.append(\"metadata\", serializedMetadata);\n    }\n    if (limit !== undefined) {\n      params.append(\"limit\", limit.toString());\n    }\n    if (offset !== undefined) {\n      params.append(\"offset\", offset.toString());\n    }\n    if (filter !== undefined) {\n      params.append(\"filter\", filter);\n    }\n    if (includeAttachments === true) {\n      [\"attachment_urls\", \"outputs\", \"metadata\"].forEach(field => params.append(\"select\", field));\n    }\n    let i = 0;\n    for await (const rawExamples of this._getPaginated(\"/examples\", params)) {\n      for (const rawExample of rawExamples) {\n        const {\n          attachment_urls,\n          ...rest\n        } = rawExample;\n        const example = rest;\n        if (attachment_urls) {\n          example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {\n            acc[key.slice(\"attachment.\".length)] = {\n              presigned_url: value.presigned_url,\n              mime_type: value.mime_type || undefined\n            };\n            return acc;\n          }, {});\n        }\n        yield example;\n        i++;\n      }\n      if (limit !== undefined && i >= limit) {\n        break;\n      }\n    }\n  }\n  async deleteExample(exampleId) {\n    assertUuid(exampleId);\n    const path = `/examples/${exampleId}`;\n    const response = await this.caller.call(_getFetchImplementation(this.debug), this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, `delete ${path}`);\n    await response.json();\n  }\n  async updateExample(exampleIdOrUpdate, update) {\n    let exampleId;\n    if (update) {\n      exampleId = exampleIdOrUpdate;\n    } else {\n      exampleId = exampleIdOrUpdate.id;\n    }\n    assertUuid(exampleId);\n    let updateToUse;\n    if (update) {\n      updateToUse = {\n        id: exampleId,\n        ...update\n      };\n    } else {\n      updateToUse = exampleIdOrUpdate;\n    }\n    let datasetId;\n    if (updateToUse.dataset_id !== undefined) {\n      datasetId = updateToUse.dataset_id;\n    } else {\n      const example = await this.readExample(exampleId);\n      datasetId = example.dataset_id;\n    }\n    return this._updateExamplesMultipart(datasetId, [updateToUse]);\n  }\n  async updateExamples(update) {\n    // We will naively get dataset id from first example and assume it works for all\n    let datasetId;\n    if (update[0].dataset_id === undefined) {\n      const example = await this.readExample(update[0].id);\n      datasetId = example.dataset_id;\n    } else {\n      datasetId = update[0].dataset_id;\n    }\n    return this._updateExamplesMultipart(datasetId, update);\n  }\n  /**\n   * Get dataset version by closest date or exact tag.\n   *\n   * Use this to resolve the nearest version to a given timestamp or for a given tag.\n   *\n   * @param options The options for getting the dataset version\n   * @param options.datasetId The ID of the dataset\n   * @param options.datasetName The name of the dataset\n   * @param options.asOf The timestamp of the dataset to retrieve\n   * @param options.tag The tag of the dataset to retrieve\n   * @returns The dataset version\n   */\n  async readDatasetVersion({\n    datasetId,\n    datasetName,\n    asOf,\n    tag\n  }) {\n    let resolvedDatasetId;\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      resolvedDatasetId = dataset.id;\n    } else {\n      resolvedDatasetId = datasetId;\n    }\n    assertUuid(resolvedDatasetId);\n    if (asOf && tag || !asOf && !tag) {\n      throw new Error(\"Exactly one of asOf and tag must be specified.\");\n    }\n    const params = new URLSearchParams();\n    if (asOf !== undefined) {\n      params.append(\"as_of\", typeof asOf === \"string\" ? asOf : asOf.toISOString());\n    }\n    if (tag !== undefined) {\n      params.append(\"tag\", tag);\n    }\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {\n      method: \"GET\",\n      headers: {\n        ...this.headers\n      },\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"read dataset version\");\n    return await response.json();\n  }\n  async listDatasetSplits({\n    datasetId,\n    datasetName,\n    asOf\n  }) {\n    let datasetId_;\n    if (datasetId === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide dataset name or ID\");\n    } else if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    } else {\n      datasetId_ = datasetId;\n    }\n    assertUuid(datasetId_);\n    const params = new URLSearchParams();\n    const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n    if (dataset_version) {\n      params.append(\"as_of\", dataset_version);\n    }\n    const response = await this._get(`/datasets/${datasetId_}/splits`, params);\n    return response;\n  }\n  async updateDatasetSplits({\n    datasetId,\n    datasetName,\n    splitName,\n    exampleIds,\n    remove = false\n  }) {\n    let datasetId_;\n    if (datasetId === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide dataset name or ID\");\n    } else if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    } else {\n      datasetId_ = datasetId;\n    }\n    assertUuid(datasetId_);\n    const data = {\n      split_name: splitName,\n      examples: exampleIds.map(id => {\n        assertUuid(id);\n        return id;\n      }),\n      remove\n    };\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId_}/splits`, {\n      method: \"PUT\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"update dataset splits\", true);\n  }\n  /**\n   * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\n   */\n  async evaluateRun(run, evaluator, {\n    sourceInfo,\n    loadChildRuns,\n    referenceExample\n  } = {\n    loadChildRuns: false\n  }) {\n    warnOnce(\"This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\");\n    let run_;\n    if (typeof run === \"string\") {\n      run_ = await this.readRun(run, {\n        loadChildRuns\n      });\n    } else if (typeof run === \"object\" && \"id\" in run) {\n      run_ = run;\n    } else {\n      throw new Error(`Invalid run type: ${typeof run}`);\n    }\n    if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n      referenceExample = await this.readExample(run_.reference_example_id);\n    }\n    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n    const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);\n    return feedbacks[0];\n  }\n  async createFeedback(runId, key, {\n    score,\n    value,\n    correction,\n    comment,\n    sourceInfo,\n    feedbackSourceType = \"api\",\n    sourceRunId,\n    feedbackId,\n    feedbackConfig,\n    projectId,\n    comparativeExperimentId\n  }) {\n    if (!runId && !projectId) {\n      throw new Error(\"One of runId or projectId must be provided\");\n    }\n    if (runId && projectId) {\n      throw new Error(\"Only one of runId or projectId can be provided\");\n    }\n    const feedback_source = {\n      type: feedbackSourceType ?? \"api\",\n      metadata: sourceInfo ?? {}\n    };\n    if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n      feedback_source.metadata[\"__run\"] = {\n        run_id: sourceRunId\n      };\n    }\n    if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n      assertUuid(feedback_source.metadata[\"__run\"].run_id);\n    }\n    const feedback = {\n      id: feedbackId ?? uuid.v4(),\n      run_id: runId,\n      key,\n      score: _formatFeedbackScore(score),\n      value,\n      correction,\n      comment,\n      feedback_source: feedback_source,\n      comparative_experiment_id: comparativeExperimentId,\n      feedbackConfig,\n      session_id: projectId\n    };\n    const url = `${this.apiUrl}/feedback`;\n    const response = await this.caller.call(_getFetchImplementation(this.debug), url, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedback),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"create feedback\", true);\n    return feedback;\n  }\n  async updateFeedback(feedbackId, {\n    score,\n    value,\n    correction,\n    comment\n  }) {\n    const feedbackUpdate = {};\n    if (score !== undefined && score !== null) {\n      feedbackUpdate[\"score\"] = _formatFeedbackScore(score);\n    }\n    if (value !== undefined && value !== null) {\n      feedbackUpdate[\"value\"] = value;\n    }\n    if (correction !== undefined && correction !== null) {\n      feedbackUpdate[\"correction\"] = correction;\n    }\n    if (comment !== undefined && comment !== null) {\n      feedbackUpdate[\"comment\"] = comment;\n    }\n    assertUuid(feedbackId);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/feedback/${feedbackId}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedbackUpdate),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"update feedback\", true);\n  }\n  async readFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = `/feedback/${feedbackId}`;\n    const response = await this._get(path);\n    return response;\n  }\n  async deleteFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = `/feedback/${feedbackId}`;\n    const response = await this.caller.call(_getFetchImplementation(this.debug), this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, `delete ${path}`);\n    await response.json();\n  }\n  async *listFeedback({\n    runIds,\n    feedbackKeys,\n    feedbackSourceTypes\n  } = {}) {\n    const queryParams = new URLSearchParams();\n    if (runIds) {\n      queryParams.append(\"run\", runIds.join(\",\"));\n    }\n    if (feedbackKeys) {\n      for (const key of feedbackKeys) {\n        queryParams.append(\"key\", key);\n      }\n    }\n    if (feedbackSourceTypes) {\n      for (const type of feedbackSourceTypes) {\n        queryParams.append(\"source\", type);\n      }\n    }\n    for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n      yield* feedbacks;\n    }\n  }\n  /**\n   * Creates a presigned feedback token and URL.\n   *\n   * The token can be used to authorize feedback metrics without\n   * needing an API key. This is useful for giving browser-based\n   * applications the ability to submit feedback without needing\n   * to expose an API key.\n   *\n   * @param runId The ID of the run.\n   * @param feedbackKey The feedback key.\n   * @param options Additional options for the token.\n   * @param options.expiration The expiration time for the token.\n   *\n   * @returns A promise that resolves to a FeedbackIngestToken.\n   */\n  async createPresignedFeedbackToken(runId, feedbackKey, {\n    expiration,\n    feedbackConfig\n  } = {}) {\n    const body = {\n      run_id: runId,\n      feedback_key: feedbackKey,\n      feedback_config: feedbackConfig\n    };\n    if (expiration) {\n      if (typeof expiration === \"string\") {\n        body[\"expires_at\"] = expiration;\n      } else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n        body[\"expires_in\"] = expiration;\n      }\n    } else {\n      body[\"expires_in\"] = {\n        hours: 3\n      };\n    }\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/feedback/tokens`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const result = await response.json();\n    return result;\n  }\n  async createComparativeExperiment({\n    name,\n    experimentIds,\n    referenceDatasetId,\n    createdAt,\n    description,\n    metadata,\n    id\n  }) {\n    if (experimentIds.length === 0) {\n      throw new Error(\"At least one experiment is required\");\n    }\n    if (!referenceDatasetId) {\n      referenceDatasetId = (await this.readProject({\n        projectId: experimentIds[0]\n      })).reference_dataset_id;\n    }\n    if (!referenceDatasetId == null) {\n      throw new Error(\"A reference dataset is required\");\n    }\n    const body = {\n      id,\n      name,\n      experiment_ids: experimentIds,\n      reference_dataset_id: referenceDatasetId,\n      description,\n      created_at: (createdAt ?? new Date())?.toISOString(),\n      extra: {}\n    };\n    if (metadata) body.extra[\"metadata\"] = metadata;\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/comparative`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    return await response.json();\n  }\n  /**\n   * Retrieves a list of presigned feedback tokens for a given run ID.\n   * @param runId The ID of the run.\n   * @returns An async iterable of FeedbackIngestToken objects.\n   */\n  async *listPresignedFeedbackTokens(runId) {\n    assertUuid(runId);\n    const params = new URLSearchParams({\n      run_id: runId\n    });\n    for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)) {\n      yield* tokens;\n    }\n  }\n  _selectEvalResults(results) {\n    let results_;\n    if (\"results\" in results) {\n      results_ = results.results;\n    } else if (Array.isArray(results)) {\n      results_ = results;\n    } else {\n      results_ = [results];\n    }\n    return results_;\n  }\n  async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n    const evalResults = this._selectEvalResults(evaluatorResponse);\n    const feedbacks = [];\n    for (const res of evalResults) {\n      let sourceInfo_ = sourceInfo || {};\n      if (res.evaluatorInfo) {\n        sourceInfo_ = {\n          ...res.evaluatorInfo,\n          ...sourceInfo_\n        };\n      }\n      let runId_ = null;\n      if (res.targetRunId) {\n        runId_ = res.targetRunId;\n      } else if (run) {\n        runId_ = run.id;\n      }\n      feedbacks.push(await this.createFeedback(runId_, res.key, {\n        score: res.score,\n        value: res.value,\n        comment: res.comment,\n        correction: res.correction,\n        sourceInfo: sourceInfo_,\n        sourceRunId: res.sourceRunId,\n        feedbackConfig: res.feedbackConfig,\n        feedbackSourceType: \"model\"\n      }));\n    }\n    return [evalResults, feedbacks];\n  }\n  async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n    const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);\n    return results;\n  }\n  /**\n   * API for managing annotation queues\n   */\n  /**\n   * List the annotation queues on the LangSmith API.\n   * @param options - The options for listing annotation queues\n   * @param options.queueIds - The IDs of the queues to filter by\n   * @param options.name - The name of the queue to filter by\n   * @param options.nameContains - The substring that the queue name should contain\n   * @param options.limit - The maximum number of queues to return\n   * @returns An iterator of AnnotationQueue objects\n   */\n  async *listAnnotationQueues(options = {}) {\n    const {\n      queueIds,\n      name,\n      nameContains,\n      limit\n    } = options;\n    const params = new URLSearchParams();\n    if (queueIds) {\n      queueIds.forEach((id, i) => {\n        assertUuid(id, `queueIds[${i}]`);\n        params.append(\"ids\", id);\n      });\n    }\n    if (name) params.append(\"name\", name);\n    if (nameContains) params.append(\"name_contains\", nameContains);\n    params.append(\"limit\", (limit !== undefined ? Math.min(limit, 100) : 100).toString());\n    let count = 0;\n    for await (const queues of this._getPaginated(\"/annotation-queues\", params)) {\n      yield* queues;\n      count++;\n      if (limit !== undefined && count >= limit) break;\n    }\n  }\n  /**\n   * Create an annotation queue on the LangSmith API.\n   * @param options - The options for creating an annotation queue\n   * @param options.name - The name of the annotation queue\n   * @param options.description - The description of the annotation queue\n   * @param options.queueId - The ID of the annotation queue\n   * @returns The created AnnotationQueue object\n   */\n  async createAnnotationQueue(options) {\n    const {\n      name,\n      description,\n      queueId,\n      rubricInstructions\n    } = options;\n    const body = {\n      name,\n      description,\n      id: queueId || uuid.v4(),\n      rubric_instructions: rubricInstructions\n    };\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== undefined))),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"create annotation queue\");\n    const data = await response.json();\n    return data;\n  }\n  /**\n   * Read an annotation queue with the specified queue ID.\n   * @param queueId - The ID of the annotation queue to read\n   * @returns The AnnotationQueueWithDetails object\n   */\n  async readAnnotationQueue(queueId) {\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"read annotation queue\");\n    const data = await response.json();\n    return data;\n  }\n  /**\n   * Update an annotation queue with the specified queue ID.\n   * @param queueId - The ID of the annotation queue to update\n   * @param options - The options for updating the annotation queue\n   * @param options.name - The new name for the annotation queue\n   * @param options.description - The new description for the annotation queue\n   */\n  async updateAnnotationQueue(queueId, options) {\n    const {\n      name,\n      description,\n      rubricInstructions\n    } = options;\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        name,\n        description,\n        rubric_instructions: rubricInstructions\n      }),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"update annotation queue\");\n  }\n  /**\n   * Delete an annotation queue with the specified queue ID.\n   * @param queueId - The ID of the annotation queue to delete\n   */\n  async deleteAnnotationQueue(queueId) {\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}`, {\n      method: \"DELETE\",\n      headers: {\n        ...this.headers,\n        Accept: \"application/json\"\n      },\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"delete annotation queue\");\n  }\n  /**\n   * Add runs to an annotation queue with the specified queue ID.\n   * @param queueId - The ID of the annotation queue\n   * @param runIds - The IDs of the runs to be added to the annotation queue\n   */\n  async addRunsToAnnotationQueue(queueId, runIds) {\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}/runs`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(runIds.map((id, i) => assertUuid(id, `runIds[${i}]`).toString())),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"add runs to annotation queue\");\n  }\n  /**\n   * Get a run from an annotation queue at the specified index.\n   * @param queueId - The ID of the annotation queue\n   * @param index - The index of the run to retrieve\n   * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object\n   * @throws {Error} If the run is not found at the given index or for other API-related errors\n   */\n  async getRunFromAnnotationQueue(queueId, index) {\n    const baseUrl = `/annotation-queues/${assertUuid(queueId, \"queueId\")}/run`;\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${baseUrl}/${index}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"get run from annotation queue\");\n    return await response.json();\n  }\n  /**\n   * Delete a run from an an annotation queue.\n   * @param queueId - The ID of the annotation queue to delete the run from\n   * @param queueRunId - The ID of the run to delete from the annotation queue\n   */\n  async deleteRunFromAnnotationQueue(queueId, queueRunId) {\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}/runs/${assertUuid(queueRunId, \"queueRunId\")}`, {\n      method: \"DELETE\",\n      headers: {\n        ...this.headers,\n        Accept: \"application/json\"\n      },\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"delete run from annotation queue\");\n  }\n  /**\n   * Get the size of an annotation queue.\n   * @param queueId - The ID of the annotation queue\n   */\n  async getSizeFromAnnotationQueue(queueId) {\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}/size`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"get size from annotation queue\");\n    return await response.json();\n  }\n  async _currentTenantIsOwner(owner) {\n    const settings = await this._getSettings();\n    return owner == \"-\" || settings.tenant_handle === owner;\n  }\n  async _ownerConflictError(action, owner) {\n    const settings = await this._getSettings();\n    return new Error(`Cannot ${action} for another tenant.\\n\n      Current tenant: ${settings.tenant_handle}\\n\n      Requested tenant: ${owner}`);\n  }\n  async _getLatestCommitHash(promptOwnerAndName) {\n    const res = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    const json = await res.json();\n    if (!res.ok) {\n      const detail = typeof json.detail === \"string\" ? json.detail : JSON.stringify(json.detail);\n      const error = new Error(`Error ${res.status}: ${res.statusText}\\n${detail}`);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      error.statusCode = res.status;\n      throw error;\n    }\n    if (json.commits.length === 0) {\n      return undefined;\n    }\n    return json.commits[0].commit_hash;\n  }\n  async _likeOrUnlikePrompt(promptIdentifier, like) {\n    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/likes/${owner}/${promptName}`, {\n      method: \"POST\",\n      body: JSON.stringify({\n        like: like\n      }),\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, `${like ? \"like\" : \"unlike\"} prompt`);\n    return await response.json();\n  }\n  async _getPromptUrl(promptIdentifier) {\n    const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);\n    if (!(await this._currentTenantIsOwner(owner))) {\n      if (commitHash !== \"latest\") {\n        return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;\n      } else {\n        return `${this.getHostUrl()}/hub/${owner}/${promptName}`;\n      }\n    } else {\n      const settings = await this._getSettings();\n      if (commitHash !== \"latest\") {\n        return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;\n      } else {\n        return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;\n      }\n    }\n  }\n  async promptExists(promptIdentifier) {\n    const prompt = await this.getPrompt(promptIdentifier);\n    return !!prompt;\n  }\n  async likePrompt(promptIdentifier) {\n    return this._likeOrUnlikePrompt(promptIdentifier, true);\n  }\n  async unlikePrompt(promptIdentifier) {\n    return this._likeOrUnlikePrompt(promptIdentifier, false);\n  }\n  async *listCommits(promptOwnerAndName) {\n    for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), res => res.commits)) {\n      yield* commits;\n    }\n  }\n  async *listPrompts(options) {\n    const params = new URLSearchParams();\n    params.append(\"sort_field\", options?.sortField ?? \"updated_at\");\n    params.append(\"sort_direction\", \"desc\");\n    params.append(\"is_archived\", (!!options?.isArchived).toString());\n    if (options?.isPublic !== undefined) {\n      params.append(\"is_public\", options.isPublic.toString());\n    }\n    if (options?.query) {\n      params.append(\"query\", options.query);\n    }\n    for await (const prompts of this._getPaginated(\"/repos\", params, res => res.repos)) {\n      yield* prompts;\n    }\n  }\n  async getPrompt(promptIdentifier) {\n    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    if (response.status === 404) {\n      return null;\n    }\n    await raiseForStatus(response, \"get prompt\");\n    const result = await response.json();\n    if (result.repo) {\n      return result.repo;\n    } else {\n      return null;\n    }\n  }\n  async createPrompt(promptIdentifier, options) {\n    const settings = await this._getSettings();\n    if (options?.isPublic && !settings.tenant_handle) {\n      throw new Error(`Cannot create a public prompt without first\\n\n        creating a LangChain Hub handle.\n        You can add a handle by creating a public prompt at:\\n\n        https://smith.langchain.com/prompts`);\n    }\n    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n    if (!(await this._currentTenantIsOwner(owner))) {\n      throw await this._ownerConflictError(\"create a prompt\", owner);\n    }\n    const data = {\n      repo_handle: promptName,\n      ...(options?.description && {\n        description: options.description\n      }),\n      ...(options?.readme && {\n        readme: options.readme\n      }),\n      ...(options?.tags && {\n        tags: options.tags\n      }),\n      is_public: !!options?.isPublic\n    };\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"create prompt\");\n    const {\n      repo\n    } = await response.json();\n    return repo;\n  }\n  async createCommit(promptIdentifier, object, options) {\n    if (!(await this.promptExists(promptIdentifier))) {\n      throw new Error(\"Prompt does not exist, you must create it first.\");\n    }\n    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n    const resolvedParentCommitHash = options?.parentCommitHash === \"latest\" || !options?.parentCommitHash ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options?.parentCommitHash;\n    const payload = {\n      manifest: JSON.parse(JSON.stringify(object)),\n      parent_commit: resolvedParentCommitHash\n    };\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/commits/${owner}/${promptName}`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(payload),\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"create commit\");\n    const result = await response.json();\n    return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : \"\"}`);\n  }\n  /**\n   * Update examples with attachments using multipart form data.\n   * @param updates List of ExampleUpdateWithAttachments objects to upsert\n   * @returns Promise with the update response\n   */\n  async updateExamplesMultipart(datasetId, updates = []) {\n    return this._updateExamplesMultipart(datasetId, updates);\n  }\n  async _updateExamplesMultipart(datasetId, updates = []) {\n    if (!(await this._getMultiPartSupport())) {\n      throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n    }\n    const formData = new FormData();\n    for (const example of updates) {\n      const exampleId = example.id;\n      // Prepare the main example body\n      const exampleBody = {\n        ...(example.metadata && {\n          metadata: example.metadata\n        }),\n        ...(example.split && {\n          split: example.split\n        })\n      };\n      // Add main example data\n      const stringifiedExample = serializePayloadForTracing(exampleBody, `Serializing body for example with id: ${exampleId}`);\n      const exampleBlob = new Blob([stringifiedExample], {\n        type: \"application/json\"\n      });\n      formData.append(exampleId, exampleBlob);\n      // Add inputs if present\n      if (example.inputs) {\n        const stringifiedInputs = serializePayloadForTracing(example.inputs, `Serializing inputs for example with id: ${exampleId}`);\n        const inputsBlob = new Blob([stringifiedInputs], {\n          type: \"application/json\"\n        });\n        formData.append(`${exampleId}.inputs`, inputsBlob);\n      }\n      // Add outputs if present\n      if (example.outputs) {\n        const stringifiedOutputs = serializePayloadForTracing(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);\n        const outputsBlob = new Blob([stringifiedOutputs], {\n          type: \"application/json\"\n        });\n        formData.append(`${exampleId}.outputs`, outputsBlob);\n      }\n      // Add attachments if present\n      if (example.attachments) {\n        for (const [name, attachment] of Object.entries(example.attachments)) {\n          let mimeType;\n          let data;\n          if (Array.isArray(attachment)) {\n            [mimeType, data] = attachment;\n          } else {\n            mimeType = attachment.mimeType;\n            data = attachment.data;\n          }\n          const attachmentBlob = new Blob([data], {\n            type: `${mimeType}; length=${data.byteLength}`\n          });\n          formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n        }\n      }\n      if (example.attachments_operations) {\n        const stringifiedAttachmentsOperations = serializePayloadForTracing(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);\n        const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {\n          type: \"application/json\"\n        });\n        formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);\n      }\n    }\n    const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetIdToUse}/examples`)}`, {\n      method: \"PATCH\",\n      headers: this.headers,\n      body: formData\n    });\n    const result = await response.json();\n    return result;\n  }\n  /**\n   * Upload examples with attachments using multipart form data.\n   * @param uploads List of ExampleUploadWithAttachments objects to upload\n   * @returns Promise with the upload response\n   * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead\n   */\n  async uploadExamplesMultipart(datasetId, uploads = []) {\n    return this._uploadExamplesMultipart(datasetId, uploads);\n  }\n  async _uploadExamplesMultipart(datasetId, uploads = []) {\n    if (!(await this._getMultiPartSupport())) {\n      throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n    }\n    const formData = new FormData();\n    for (const example of uploads) {\n      const exampleId = (example.id ?? uuid.v4()).toString();\n      // Prepare the main example body\n      const exampleBody = {\n        created_at: example.created_at,\n        ...(example.metadata && {\n          metadata: example.metadata\n        }),\n        ...(example.split && {\n          split: example.split\n        }),\n        ...(example.source_run_id && {\n          source_run_id: example.source_run_id\n        }),\n        ...(example.use_source_run_io && {\n          use_source_run_io: example.use_source_run_io\n        }),\n        ...(example.use_source_run_attachments && {\n          use_source_run_attachments: example.use_source_run_attachments\n        })\n      };\n      // Add main example data\n      const stringifiedExample = serializePayloadForTracing(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);\n      const exampleBlob = new Blob([stringifiedExample], {\n        type: \"application/json\"\n      });\n      formData.append(exampleId, exampleBlob);\n      // Add inputs if present\n      if (example.inputs) {\n        const stringifiedInputs = serializePayloadForTracing(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);\n        const inputsBlob = new Blob([stringifiedInputs], {\n          type: \"application/json\"\n        });\n        formData.append(`${exampleId}.inputs`, inputsBlob);\n      }\n      // Add outputs if present\n      if (example.outputs) {\n        const stringifiedOutputs = serializePayloadForTracing(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);\n        const outputsBlob = new Blob([stringifiedOutputs], {\n          type: \"application/json\"\n        });\n        formData.append(`${exampleId}.outputs`, outputsBlob);\n      }\n      // Add attachments if present\n      if (example.attachments) {\n        for (const [name, attachment] of Object.entries(example.attachments)) {\n          let mimeType;\n          let data;\n          if (Array.isArray(attachment)) {\n            [mimeType, data] = attachment;\n          } else {\n            mimeType = attachment.mimeType;\n            data = attachment.data;\n          }\n          const attachmentBlob = new Blob([data], {\n            type: `${mimeType}; length=${data.byteLength}`\n          });\n          formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n        }\n      }\n    }\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetId}/examples`)}`, {\n      method: \"POST\",\n      headers: this.headers,\n      body: formData\n    });\n    await raiseForStatus(response, \"upload examples\");\n    const result = await response.json();\n    return result;\n  }\n  async updatePrompt(promptIdentifier, options) {\n    if (!(await this.promptExists(promptIdentifier))) {\n      throw new Error(\"Prompt does not exist, you must create it first.\");\n    }\n    const [owner, promptName] = parsePromptIdentifier(promptIdentifier);\n    if (!(await this._currentTenantIsOwner(owner))) {\n      throw await this._ownerConflictError(\"update a prompt\", owner);\n    }\n    const payload = {};\n    if (options?.description !== undefined) payload.description = options.description;\n    if (options?.readme !== undefined) payload.readme = options.readme;\n    if (options?.tags !== undefined) payload.tags = options.tags;\n    if (options?.isPublic !== undefined) payload.is_public = options.isPublic;\n    if (options?.isArchived !== undefined) payload.is_archived = options.isArchived;\n    // Check if payload is empty\n    if (Object.keys(payload).length === 0) {\n      throw new Error(\"No valid update options provided\");\n    }\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n      method: \"PATCH\",\n      body: JSON.stringify(payload),\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"update prompt\");\n    return response.json();\n  }\n  async deletePrompt(promptIdentifier) {\n    if (!(await this.promptExists(promptIdentifier))) {\n      throw new Error(\"Prompt does not exist, you must create it first.\");\n    }\n    const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n    if (!(await this._currentTenantIsOwner(owner))) {\n      throw await this._ownerConflictError(\"delete a prompt\", owner);\n    }\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    return await response.json();\n  }\n  async pullPromptCommit(promptIdentifier, options) {\n    const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);\n    const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? \"?include_model=true\" : \"\"}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms),\n      ...this.fetchOptions\n    });\n    await raiseForStatus(response, \"pull prompt commit\");\n    const result = await response.json();\n    return {\n      owner,\n      repo: promptName,\n      commit_hash: result.commit_hash,\n      manifest: result.manifest,\n      examples: result.examples\n    };\n  }\n  /**\n   * This method should not be used directly, use `import { pull } from \"langchain/hub\"` instead.\n   * Using this method directly returns the JSON string of the prompt rather than a LangChain object.\n   * @private\n   */\n  async _pullPrompt(promptIdentifier, options) {\n    const promptObject = await this.pullPromptCommit(promptIdentifier, {\n      includeModel: options?.includeModel\n    });\n    const prompt = JSON.stringify(promptObject.manifest);\n    return prompt;\n  }\n  async pushPrompt(promptIdentifier, options) {\n    // Create or update prompt metadata\n    if (await this.promptExists(promptIdentifier)) {\n      if (options && Object.keys(options).some(key => key !== \"object\")) {\n        await this.updatePrompt(promptIdentifier, {\n          description: options?.description,\n          readme: options?.readme,\n          tags: options?.tags,\n          isPublic: options?.isPublic\n        });\n      }\n    } else {\n      await this.createPrompt(promptIdentifier, {\n        description: options?.description,\n        readme: options?.readme,\n        tags: options?.tags,\n        isPublic: options?.isPublic\n      });\n    }\n    if (!options?.object) {\n      return await this._getPromptUrl(promptIdentifier);\n    }\n    // Create a commit with the new manifest\n    const url = await this.createCommit(promptIdentifier, options?.object, {\n      parentCommitHash: options?.parentCommitHash\n    });\n    return url;\n  }\n  /**\n   * Clone a public dataset to your own langsmith tenant.\n   * This operation is idempotent. If you already have a dataset with the given name,\n   * this function will do nothing.\n      * @param {string} tokenOrUrl The token of the public dataset to clone.\n   * @param {Object} [options] Additional options for cloning the dataset.\n   * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.\n   * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.\n   * @returns {Promise<void>}\n   */\n  async clonePublicDataset(tokenOrUrl, options = {}) {\n    const {\n      sourceApiUrl = this.apiUrl,\n      datasetName\n    } = options;\n    const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);\n    const sourceClient = new Client({\n      apiUrl: parsedApiUrl,\n      // Placeholder API key not needed anymore in most cases, but\n      // some private deployments may have API key-based rate limiting\n      // that would cause this to fail if we provide no value.\n      apiKey: \"placeholder\"\n    });\n    const ds = await sourceClient.readSharedDataset(tokenUuid);\n    const finalDatasetName = datasetName || ds.name;\n    try {\n      if (await this.hasDataset({\n        datasetId: finalDatasetName\n      })) {\n        console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);\n        return;\n      }\n    } catch (_) {\n      // `.hasDataset` will throw an error if the dataset does not exist.\n      // no-op in that case\n    }\n    // Fetch examples first, then create the dataset\n    const examples = await sourceClient.listSharedExamples(tokenUuid);\n    const dataset = await this.createDataset(finalDatasetName, {\n      description: ds.description,\n      dataType: ds.data_type || \"kv\",\n      inputsSchema: ds.inputs_schema_definition ?? undefined,\n      outputsSchema: ds.outputs_schema_definition ?? undefined\n    });\n    try {\n      await this.createExamples({\n        inputs: examples.map(e => e.inputs),\n        outputs: examples.flatMap(e => e.outputs ? [e.outputs] : []),\n        datasetId: dataset.id\n      });\n    } catch (e) {\n      console.error(`An error occurred while creating dataset ${finalDatasetName}. ` + \"You should delete it manually.\");\n      throw e;\n    }\n  }\n  parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = \"dataset\") {\n    // Try parsing as UUID\n    try {\n      assertUuid(urlOrToken); // Will throw if it's not a UUID.\n      return [apiUrl, urlOrToken];\n    } catch (_) {\n      // no-op if it's not a uuid\n    }\n    // Parse as URL\n    try {\n      const parsedUrl = new URL(urlOrToken);\n      const pathParts = parsedUrl.pathname.split(\"/\").filter(part => part !== \"\");\n      if (pathParts.length >= numParts) {\n        const tokenUuid = pathParts[pathParts.length - numParts];\n        return [apiUrl, tokenUuid];\n      } else {\n        throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);\n      }\n    } catch (error) {\n      throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);\n    }\n  }\n  /**\n   * Awaits all pending trace batches. Useful for environments where\n   * you need to be sure that all tracing requests finish before execution ends,\n   * such as serverless environments.\n   *\n   * @example\n   * ```\n   * import { Client } from \"langsmith\";\n   *\n   * const client = new Client();\n   *\n   * try {\n   *   // Tracing happens here\n   *   ...\n   * } finally {\n   *   await client.awaitPendingTraceBatches();\n   * }\n   * ```\n   *\n   * @returns A promise that resolves once all currently pending traces have sent.\n   */\n  async awaitPendingTraceBatches() {\n    if (this.manualFlushMode) {\n      console.warn(\"[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.\");\n      return Promise.resolve();\n    }\n    await Promise.all([...this.autoBatchQueue.items.map(({\n      itemPromise\n    }) => itemPromise), this.batchIngestCaller.queue.onIdle()]);\n    if (this.langSmithToOTELTranslator !== undefined) {\n      await getDefaultOTLPTracerComponents()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();\n    }\n  }\n}\nfunction isExampleCreate(input) {\n  return \"dataset_id\" in input || \"dataset_name\" in input;\n}","map":{"version":3,"names":["uuid","LangSmithToOTELTranslator","getDefaultOTLPTracerComponents","getOTELTrace","getOTELContext","AsyncCaller","convertLangChainMessageToExample","isLangChainMessage","getEnvironmentVariable","getLangChainEnvVarsMetadata","getLangSmithEnvironmentVariable","getRuntimeEnvironment","getOtelEnabled","__version__","assertUuid","warnOnce","parsePromptIdentifier","raiseForStatus","_globalFetchImplementationIsNodeFetch","_getFetchImplementation","serialize","serializePayloadForTracing","mergeRuntimeEnvIntoRun","run","runtimeEnv","envVars","extra","metadata","runtime","revision_id","undefined","getTracingSamplingRate","configRate","samplingRateStr","toString","samplingRate","parseFloat","Error","isLocalhost","url","strippedUrl","replace","hostname","split","toArray","iterable","result","item","push","trimQuotes","str","trim","handle429","response","status","retryAfter","parseInt","headers","get","Promise","resolve","setTimeout","_formatFeedbackScore","score","Number","toFixed","AutoBatchQueue","constructor","Object","defineProperty","enumerable","configurable","writable","value","peek","items","itemPromiseResolve","itemPromise","size","id","length","action","payload","otelContext","apiKey","apiUrl","sizeBytes","pop","upToSizeBytes","popped","poppedSizeBytes","shift","map","it","forEach","DEFAULT_BATCH_SIZE_LIMIT_BYTES","SERVER_INFO_REQUEST_TIMEOUT","DEFAULT_API_URL","Client","config","Set","defaultConfig","getDefaultClientConfig","tracingSampleRate","tracingSamplingRate","endsWith","slice","webUrl","timeout_ms","caller","callerOptions","debug","traceBatchConcurrency","batchIngestCaller","maxRetries","maxConcurrency","onFailedResponseHook","hideInputs","anonymizer","hideOutputs","autoBatchTracing","blockOnRootRunFinalization","batchSizeBytesLimit","fetchOptions","manualFlushMode","langSmithToOTELTranslator","getHostUrl","includes","_getPlatformEndpointPath","path","needsV1Prefix","processInputs","inputs","processOutputs","outputs","prepareRunCreateOrUpdateInputs","runParams","_getResponse","queryParams","paramsString","call","method","signal","AbortSignal","timeout","_get","json","_getPaginated","URLSearchParams","transform","offset","limit","set","String","_getCursorPaginatedList","body","requestMethod","dataKey","bodyParams","JSON","stringify","responseBody","cursors","next","cursor","_shouldSample","Math","random","_filterForSampling","runs","patch","sampled","filteredPostUuids","has","trace_id","delete","traceId","add","_getBatchSizeLimitBytes","serverInfo","_ensureServerInfo","batch_ingest_config","size_limit_bytes","_getMultiPartSupport","instance_flags","dataset_examples_multipart_enabled","drainAutoBatchQueue","batchSizeLimit","promises","autoBatchQueue","batch","done","batchesByDestination","reduce","acc","isDefault","batchKey","batchPromises","entries","batchPromise","_processBatch","allBatchesPromise","all","finally","options","_sendBatchToOTELTranslator","ingestParams","runCreates","filter","runUpdates","use_multipart_endpoint","multipartIngestRuns","batchIngestRuns","e","console","error","otelContextMap","Map","operations","operation","exportBatch","processRunOperation","clearTimeout","autoBatchTimeout","sizeLimitBytes","autoBatchAggregationDelayMs","_getServerInfo","Accept","log","_getServerInfoPromise","_serverInfo","warn","then","_getSettings","settings","flush","_cloneCurrentOTELContext","otel_trace","otel_context","currentSpan","getActiveSpan","setSpan","active","createRun","session_name","project_name","runCreate","start_time","Date","now","dotted_order","catch","mergedRunCreateParam","preparedCreateParams","create","preparedUpdateParams","update","createById","params","standaloneUpdates","updateParam","values","rawBatch","post","batchChunks","k","key","batchItems","reverse","batchItem","runIds","concat","join","_postBatchIngestRuns","allAttachments","preparedCreate","attachments","invalidRunCreate","find","invalidRunUpdate","runUpdate","accumulatedContext","accumulatedParts","payloads","originalPayload","events","serialized","fields","stringifiedPayload","name","Blob","type","stringifiedValue","attachment","contentType","content","Array","isArray","mimeType","data","byteLength","_sendMultipartRequest","_createNodeFetchBody","parts","boundary","chunks","part","arrayBuffer","_createMultipartStream","encoder","TextEncoder","stream","ReadableStream","start","controller","writeChunk","chunk","enqueue","encode","payloadStream","reader","getReader","read","releaseLock","close","context","isNodeFetch","buildBuffered","buildStream","send","duplex","res","streamedAttempt","multipartStreamingDisabled","message","updateRun","runId","end_time","parent_run_id","readRun","loadChildRuns","_loadChildRuns","getRunUrl","projectOpts","sessionId","session_id","projectName","readProject","projectId","project","tenantId","_getTenantId","run_","app_path","baseUrl","childRuns","listRuns","isRoot","treemap","sort","a","b","localeCompare","childRun","startsWith","child_runs","props","parentRunId","referenceExampleId","startTime","executionOrder","runType","query","traceFilter","treeFilter","select","order","projectIds","projectNames","projectIds_","default_select","session","run_type","reference_example","trace_filter","tree_filter","execution_order","parent_run","toISOString","trace","is_root","runsYielded","newRuns","listGroupRuns","groupBy","endTime","baseBody","group_by","currentOffset","currentBody","filteredPayload","fromEntries","_","groups","total","thread","getRunStats","parentRun","referenceExampleIds","dataSourceType","data_source_type","shareRun","shareId","run_id","share_token","v4","unshareRun","readRunSharedLink","listSharedRuns","shareToken","append","readDatasetSharedSchema","datasetId","datasetName","dataset","readDataset","shareSchema","shareDataset","dataset_id","unshareDataset","readSharedDataset","listSharedExamples","exampleIds","urlParams","v","ok","detail","statusText","example","_hostUrl","createProject","description","upsert","projectExtra","referenceDatasetId","upsert_","endpoint","updateProject","hasProject","includeStats","getProjectUrl","getDatasetUrl","_tenantId","projects","tenant_id","listProjects","nameContains","referenceDatasetName","referenceFree","deleteProject","projectId_","uploadCsv","csvFile","fileName","inputKeys","outputKeys","dataType","formData","FormData","createDataset","inputsSchema","outputsSchema","data_type","inputs_schema_definition","outputs_schema_definition","hasDataset","toLocaleLowerCase","diffDatasetVersions","fromVersion","toVersion","datasetId_","from_version","to_version","readDatasetOpenaiFinetuning","datasetText","text","line","parse","listDatasets","datasetIds","datasetNameContains","id_","datasets","updateDataset","_datasetId","updateDatasetTag","asOf","tag","as_of","deleteDataset","indexDataset","similarExamples","createExample","inputsOrUpdate","isExampleCreate","datasetName_","dataset_name","createdAt_","createdAt","created_at","exampleId","source_run_id","sourceRunId","use_source_run_io","useSourceRunIO","use_source_run_attachments","useSourceRunAttachments","_uploadExamplesMultipart","readExample","example_ids","createExamples","propsOrUploads","uploads","examples","splits","sourceRunIds","useSourceRunIOs","formattedExamples","input","idx","createLLMExample","generation","output","createChatExample","generations","finalInput","finalOutput","rawExample","attachment_urls","rest","presigned_url","mime_type","listExamples","inlineS3Urls","includeAttachments","dataset_version","inlineS3Urls_","serializedMetadata","field","i","rawExamples","deleteExample","updateExample","exampleIdOrUpdate","updateToUse","_updateExamplesMultipart","updateExamples","readDatasetVersion","resolvedDatasetId","listDatasetSplits","updateDatasetSplits","splitName","remove","split_name","evaluateRun","evaluator","sourceInfo","referenceExample","reference_example_id","feedbackResult","feedbacks","_logEvaluationFeedback","createFeedback","correction","comment","feedbackSourceType","feedbackId","feedbackConfig","comparativeExperimentId","feedback_source","feedback","comparative_experiment_id","updateFeedback","feedbackUpdate","readFeedback","deleteFeedback","listFeedback","feedbackKeys","feedbackSourceTypes","createPresignedFeedbackToken","feedbackKey","expiration","feedback_key","feedback_config","hours","minutes","days","createComparativeExperiment","experimentIds","reference_dataset_id","experiment_ids","listPresignedFeedbackTokens","tokens","_selectEvalResults","results","results_","evaluatorResponse","evalResults","sourceInfo_","evaluatorInfo","runId_","targetRunId","logEvaluationFeedback","listAnnotationQueues","queueIds","min","count","queues","createAnnotationQueue","queueId","rubricInstructions","rubric_instructions","readAnnotationQueue","updateAnnotationQueue","deleteAnnotationQueue","addRunsToAnnotationQueue","getRunFromAnnotationQueue","index","deleteRunFromAnnotationQueue","queueRunId","getSizeFromAnnotationQueue","_currentTenantIsOwner","owner","tenant_handle","_ownerConflictError","_getLatestCommitHash","promptOwnerAndName","statusCode","commits","commit_hash","_likeOrUnlikePrompt","promptIdentifier","like","promptName","_getPromptUrl","commitHash","substring","promptExists","prompt","getPrompt","likePrompt","unlikePrompt","listCommits","listPrompts","sortField","isArchived","isPublic","prompts","repos","repo","createPrompt","repo_handle","readme","tags","is_public","createCommit","object","resolvedParentCommitHash","parentCommitHash","manifest","parent_commit","updateExamplesMultipart","updates","exampleBody","stringifiedExample","exampleBlob","stringifiedInputs","inputsBlob","stringifiedOutputs","outputsBlob","attachmentBlob","attachments_operations","stringifiedAttachmentsOperations","attachmentsOperationsBlob","datasetIdToUse","uploadExamplesMultipart","updatePrompt","is_archived","keys","deletePrompt","pullPromptCommit","includeModel","_pullPrompt","promptObject","pushPrompt","some","clonePublicDataset","tokenOrUrl","sourceApiUrl","parsedApiUrl","tokenUuid","parseTokenOrUrl","sourceClient","ds","finalDatasetName","flatMap","urlOrToken","numParts","kind","parsedUrl","URL","pathParts","pathname","awaitPendingTraceBatches","queue","onIdle","DEFAULT_LANGSMITH_SPAN_PROCESSOR","forceFlush"],"sources":["/Users/chetan/Desktop/summarize_agent/frontend/node_modules/@langchain/core/node_modules/langsmith/dist/client.js"],"sourcesContent":["import * as uuid from \"uuid\";\nimport { LangSmithToOTELTranslator, } from \"./experimental/otel/translator.js\";\nimport { getDefaultOTLPTracerComponents, getOTELTrace, getOTELContext, } from \"./singletons/otel.js\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage, } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getLangSmithEnvironmentVariable, getRuntimeEnvironment, getOtelEnabled, } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nimport { assertUuid } from \"./utils/_uuid.js\";\nimport { warnOnce } from \"./utils/warn.js\";\nimport { parsePromptIdentifier } from \"./utils/prompts.js\";\nimport { raiseForStatus } from \"./utils/error.js\";\nimport { _globalFetchImplementationIsNodeFetch, _getFetchImplementation, } from \"./singletons/fetch.js\";\nimport { serialize as serializePayloadForTracing } from \"./utils/fast-safe-stringify/index.js\";\nexport function mergeRuntimeEnvIntoRun(run) {\n    const runtimeEnv = getRuntimeEnvironment();\n    const envVars = getLangChainEnvVarsMetadata();\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n        ...extra,\n        runtime: {\n            ...runtimeEnv,\n            ...extra?.runtime,\n        },\n        metadata: {\n            ...envVars,\n            ...(envVars.revision_id || (\"revision_id\" in run && run.revision_id)\n                ? {\n                    revision_id: (\"revision_id\" in run ? run.revision_id : undefined) ??\n                        envVars.revision_id,\n                }\n                : {}),\n            ...metadata,\n        },\n    };\n    return run;\n}\nconst getTracingSamplingRate = (configRate) => {\n    const samplingRateStr = configRate?.toString() ??\n        getLangSmithEnvironmentVariable(\"TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async (response) => {\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"30\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve) => setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nfunction _formatFeedbackScore(score) {\n    if (typeof score === \"number\") {\n        // Truncate at 4 decimal places\n        return Number(score.toFixed(4));\n    }\n    return score;\n}\nexport class AutoBatchQueue {\n    constructor() {\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"sizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n    }\n    peek() {\n        return this.items[0];\n    }\n    push(item) {\n        let itemPromiseResolve;\n        const itemPromise = new Promise((resolve) => {\n            // Setting itemPromiseResolve is synchronous with promise creation:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n            itemPromiseResolve = resolve;\n        });\n        const size = serializePayloadForTracing(item.item, `Serializing run with id: ${item.item.id}`).length;\n        this.items.push({\n            action: item.action,\n            payload: item.item,\n            otelContext: item.otelContext,\n            apiKey: item.apiKey,\n            apiUrl: item.apiUrl,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            itemPromiseResolve: itemPromiseResolve,\n            itemPromise,\n            size,\n        });\n        this.sizeBytes += size;\n        return itemPromise;\n    }\n    pop(upToSizeBytes) {\n        if (upToSizeBytes < 1) {\n            throw new Error(\"Number of bytes to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        let poppedSizeBytes = 0;\n        // Pop items until we reach or exceed the size limit\n        while (poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes &&\n            this.items.length > 0) {\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n                poppedSizeBytes += item.size;\n                this.sizeBytes -= item.size;\n            }\n        }\n        // If there is an item on the queue we were unable to pop,\n        // just return it as a single batch.\n        if (popped.length === 0 && this.items.length > 0) {\n            const item = this.items.shift();\n            popped.push(item);\n            poppedSizeBytes += item.size;\n            this.sizeBytes -= item.size;\n        }\n        return [\n            popped.map((it) => ({\n                action: it.action,\n                item: it.payload,\n                otelContext: it.otelContext,\n                apiKey: it.apiKey,\n                apiUrl: it.apiUrl,\n            })),\n            () => popped.forEach((it) => it.itemPromiseResolve()),\n        ];\n    }\n}\n// 20 MB\nexport const DEFAULT_BATCH_SIZE_LIMIT_BYTES = 20_971_520;\nconst SERVER_INFO_REQUEST_TIMEOUT = 2500;\nconst DEFAULT_API_URL = \"https://api.smith.langchain.com\";\nexport class Client {\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filteredPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new AutoBatchQueue()\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"batchSizeBytesLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"settings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"blockOnRootRunFinalization\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: getEnvironmentVariable(\"LANGSMITH_TRACING_BACKGROUND\") === \"false\"\n        });\n        Object.defineProperty(this, \"traceBatchConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5\n        });\n        Object.defineProperty(this, \"_serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_getServerInfoPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"manualFlushMode\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"langSmithToOTELTranslator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"multipartStreamingDisabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: getEnvironmentVariable(\"LANGSMITH_DEBUG\") === \"true\"\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        if (this.apiUrl.endsWith(\"/\")) {\n            this.apiUrl = this.apiUrl.slice(0, -1);\n        }\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        if (this.webUrl?.endsWith(\"/\")) {\n            this.webUrl = this.webUrl.slice(0, -1);\n        }\n        this.timeout_ms = config.timeout_ms ?? 90_000;\n        this.caller = new AsyncCaller({\n            ...(config.callerOptions ?? {}),\n            debug: config.debug ?? this.debug,\n        });\n        this.traceBatchConcurrency =\n            config.traceBatchConcurrency ?? this.traceBatchConcurrency;\n        if (this.traceBatchConcurrency < 1) {\n            throw new Error(\"Trace batch concurrency must be positive.\");\n        }\n        this.debug = config.debug ?? this.debug;\n        this.batchIngestCaller = new AsyncCaller({\n            maxRetries: 2,\n            maxConcurrency: this.traceBatchConcurrency,\n            ...(config.callerOptions ?? {}),\n            onFailedResponseHook: handle429,\n            debug: config.debug ?? this.debug,\n        });\n        this.hideInputs =\n            config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;\n        this.hideOutputs =\n            config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.blockOnRootRunFinalization =\n            config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;\n        this.batchSizeBytesLimit = config.batchSizeBytesLimit;\n        this.fetchOptions = config.fetchOptions || {};\n        this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;\n        if (getOtelEnabled()) {\n            this.langSmithToOTELTranslator = new LangSmithToOTELTranslator();\n        }\n    }\n    static getDefaultClientConfig() {\n        const apiKey = getLangSmithEnvironmentVariable(\"API_KEY\");\n        const apiUrl = getLangSmithEnvironmentVariable(\"ENDPOINT\") ?? DEFAULT_API_URL;\n        const hideInputs = getLangSmithEnvironmentVariable(\"HIDE_INPUTS\") === \"true\";\n        const hideOutputs = getLangSmithEnvironmentVariable(\"HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs,\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        }\n        else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost:3000\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.endsWith(\"/api/v1\")) {\n            this.webUrl = this.apiUrl.replace(\"/api/v1\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.includes(\"/api\") &&\n            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"eu\")) {\n            this.webUrl = \"https://eu.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"beta\")) {\n            this.webUrl = \"https://beta.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return this.webUrl;\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${__version__}`,\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    _getPlatformEndpointPath(path) {\n        // Check if apiUrl already ends with /v1 or /v1/ to avoid double /v1/v1/ paths\n        const needsV1Prefix = this.apiUrl.slice(-3) !== \"/v1\" && this.apiUrl.slice(-4) !== \"/v1/\";\n        return needsV1Prefix ? `/v1/platform/${path}` : `/platform/${path}`;\n    }\n    async processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    async processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    async prepareRunCreateOrUpdateInputs(run) {\n        const runParams = { ...run };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = await this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = await this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(_getFetchImplementation(this.debug), url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, `Failed to fetch ${path}`);\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(_getFetchImplementation(this.debug), url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(response, `Failed to fetch ${path}`);\n            const items = transform\n                ? transform(await response.json())\n                : await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? { ...body } : {};\n        while (true) {\n            const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: JSON.stringify(bodyParams),\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    // Allows mocking for tests\n    _shouldSample() {\n        if (this.tracingSampleRate === undefined) {\n            return true;\n        }\n        return Math.random() < this.tracingSampleRate;\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs) {\n                if (!this.filteredPostUuids.has(run.trace_id)) {\n                    sampled.push(run);\n                }\n                else if (run.id === run.trace_id) {\n                    this.filteredPostUuids.delete(run.trace_id);\n                }\n            }\n            return sampled;\n        }\n        else {\n            // For new runs, sample at trace level to maintain consistency\n            const sampled = [];\n            for (const run of runs) {\n                const traceId = run.trace_id ?? run.id;\n                // If we've already made a decision about this trace, follow it\n                if (this.filteredPostUuids.has(traceId)) {\n                    continue;\n                }\n                // For new traces, apply sampling\n                if (run.id === traceId) {\n                    if (this._shouldSample()) {\n                        sampled.push(run);\n                    }\n                    else {\n                        this.filteredPostUuids.add(traceId);\n                    }\n                }\n                else {\n                    // Child runs follow their trace's sampling decision\n                    sampled.push(run);\n                }\n            }\n            return sampled;\n        }\n    }\n    async _getBatchSizeLimitBytes() {\n        const serverInfo = await this._ensureServerInfo();\n        return (this.batchSizeBytesLimit ??\n            serverInfo.batch_ingest_config?.size_limit_bytes ??\n            DEFAULT_BATCH_SIZE_LIMIT_BYTES);\n    }\n    async _getMultiPartSupport() {\n        const serverInfo = await this._ensureServerInfo();\n        return (serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false);\n    }\n    drainAutoBatchQueue(batchSizeLimit) {\n        const promises = [];\n        while (this.autoBatchQueue.items.length > 0) {\n            const [batch, done] = this.autoBatchQueue.pop(batchSizeLimit);\n            if (!batch.length) {\n                done();\n                break;\n            }\n            const batchesByDestination = batch.reduce((acc, item) => {\n                const apiUrl = item.apiUrl ?? this.apiUrl;\n                const apiKey = item.apiKey ?? this.apiKey;\n                const isDefault = item.apiKey === this.apiKey && item.apiUrl === this.apiUrl;\n                const batchKey = isDefault ? \"default\" : `${apiUrl}|${apiKey}`;\n                if (!acc[batchKey]) {\n                    acc[batchKey] = [];\n                }\n                acc[batchKey].push(item);\n                return acc;\n            }, {});\n            const batchPromises = [];\n            for (const [batchKey, batch] of Object.entries(batchesByDestination)) {\n                const batchPromise = this._processBatch(batch, {\n                    apiUrl: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[0],\n                    apiKey: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[1],\n                });\n                batchPromises.push(batchPromise);\n            }\n            // Wait for all batches to complete, then call the overall done callback\n            const allBatchesPromise = Promise.all(batchPromises).finally(done);\n            promises.push(allBatchesPromise);\n        }\n        return Promise.all(promises);\n    }\n    async _processBatch(batch, options) {\n        if (!batch.length) {\n            return;\n        }\n        try {\n            if (this.langSmithToOTELTranslator !== undefined) {\n                this._sendBatchToOTELTranslator(batch);\n            }\n            else {\n                const ingestParams = {\n                    runCreates: batch\n                        .filter((item) => item.action === \"create\")\n                        .map((item) => item.item),\n                    runUpdates: batch\n                        .filter((item) => item.action === \"update\")\n                        .map((item) => item.item),\n                };\n                const serverInfo = await this._ensureServerInfo();\n                if (serverInfo?.batch_ingest_config?.use_multipart_endpoint) {\n                    await this.multipartIngestRuns(ingestParams, options);\n                }\n                else {\n                    await this.batchIngestRuns(ingestParams, options);\n                }\n            }\n        }\n        catch (e) {\n            console.error(\"Error exporting batch:\", e);\n        }\n    }\n    _sendBatchToOTELTranslator(batch) {\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const otelContextMap = new Map();\n            const operations = [];\n            for (const item of batch) {\n                if (item.item.id && item.otelContext) {\n                    otelContextMap.set(item.item.id, item.otelContext);\n                    if (item.action === \"create\") {\n                        operations.push({\n                            operation: \"post\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item,\n                        });\n                    }\n                    else {\n                        operations.push({\n                            operation: \"patch\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item,\n                        });\n                    }\n                }\n            }\n            this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);\n        }\n    }\n    async processRunOperation(item) {\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        item.item = mergeRuntimeEnvIntoRun(item.item);\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (this.manualFlushMode) {\n            // Rely on manual flushing in serverless environments\n            return itemPromise;\n        }\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        if (this.autoBatchQueue.sizeBytes > sizeLimitBytes) {\n            void this.drainAutoBatchQueue(sizeLimitBytes);\n        }\n        if (this.autoBatchQueue.items.length > 0) {\n            this.autoBatchTimeout = setTimeout(() => {\n                this.autoBatchTimeout = undefined;\n                void this.drainAutoBatchQueue(sizeLimitBytes);\n            }, this.autoBatchAggregationDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/info`, {\n            method: \"GET\",\n            headers: { Accept: \"application/json\" },\n            signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"get server info\");\n        const json = await response.json();\n        if (this.debug) {\n            console.log(\"\\n=== LangSmith Server Configuration ===\\n\" +\n                JSON.stringify(json, null, 2) +\n                \"\\n\");\n        }\n        return json;\n    }\n    async _ensureServerInfo() {\n        if (this._getServerInfoPromise === undefined) {\n            this._getServerInfoPromise = (async () => {\n                if (this._serverInfo === undefined) {\n                    try {\n                        this._serverInfo = await this._getServerInfo();\n                    }\n                    catch (e) {\n                        console.warn(`[WARNING]: LangSmith failed to fetch info on supported operations with status code ${e.status}. Falling back to batch operations and default limits.`);\n                    }\n                }\n                return this._serverInfo ?? {};\n            })();\n        }\n        return this._getServerInfoPromise.then((serverInfo) => {\n            if (this._serverInfo === undefined) {\n                this._getServerInfoPromise = undefined;\n            }\n            return serverInfo;\n        });\n    }\n    async _getSettings() {\n        if (!this.settings) {\n            this.settings = this._get(\"/settings\");\n        }\n        return await this.settings;\n    }\n    /**\n     * Flushes current queued traces.\n     */\n    async flush() {\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        await this.drainAutoBatchQueue(sizeLimitBytes);\n    }\n    _cloneCurrentOTELContext() {\n        const otel_trace = getOTELTrace();\n        const otel_context = getOTELContext();\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const currentSpan = otel_trace.getActiveSpan();\n            if (currentSpan) {\n                return otel_trace.setSpan(otel_context.active(), currentSpan);\n            }\n        }\n        return undefined;\n    }\n    async createRun(run, options) {\n        if (!this._filterForSampling([run]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = await this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now(),\n        });\n        if (this.autoBatchTracing &&\n            runCreate.trace_id !== undefined &&\n            runCreate.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate,\n                otelContext,\n                apiKey: options?.apiKey,\n                apiUrl: options?.apiUrl,\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParam = mergeRuntimeEnvIntoRun(runCreate);\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${options?.apiUrl ?? this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: serializePayloadForTracing(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"create run\", true);\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async batchIngestRuns({ runCreates, runUpdates, }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = await Promise.all(runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? []);\n        let preparedUpdateParams = await Promise.all(runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? []);\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: preparedCreateParams,\n            patch: preparedUpdateParams,\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        const batchChunks = {\n            post: [],\n            patch: [],\n        };\n        for (const k of [\"post\", \"patch\"]) {\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while (batchItem !== undefined) {\n                // Type is wrong but this is a deprecated code path anyway\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            const runIds = batchChunks.post\n                .map((item) => item.id)\n                .concat(batchChunks.patch.map((item) => item.id))\n                .join(\",\");\n            await this._postBatchIngestRuns(serializePayloadForTracing(batchChunks, `Ingesting runs with ids: ${runIds}`), options);\n        }\n    }\n    async _postBatchIngestRuns(body, options) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        const response = await this.batchIngestCaller.call(_getFetchImplementation(this.debug), `${options?.apiUrl ?? this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: body,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"batch create run\", true);\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async multipartIngestRuns({ runCreates, runUpdates, }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        // transform and convert to dicts\n        const allAttachments = {};\n        let preparedCreateParams = [];\n        for (const create of runCreates ?? []) {\n            const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);\n            if (preparedCreate.id !== undefined &&\n                preparedCreate.attachments !== undefined) {\n                allAttachments[preparedCreate.id] = preparedCreate.attachments;\n            }\n            delete preparedCreate.attachments;\n            preparedCreateParams.push(preparedCreate);\n        }\n        let preparedUpdateParams = [];\n        for (const update of runUpdates ?? []) {\n            preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));\n        }\n        // require trace_id and dotted_order\n        const invalidRunCreate = preparedCreateParams.find((runCreate) => {\n            return (runCreate.trace_id === undefined || runCreate.dotted_order === undefined);\n        });\n        if (invalidRunCreate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when creating a run`);\n        }\n        const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {\n            return (runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined);\n        });\n        if (invalidRunUpdate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when updating a run`);\n        }\n        // combine post and patch dicts where possible\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        if (preparedCreateParams.length === 0 &&\n            preparedUpdateParams.length === 0) {\n            return;\n        }\n        // send the runs in multipart requests\n        const accumulatedContext = [];\n        const accumulatedParts = [];\n        for (const [method, payloads] of [\n            [\"post\", preparedCreateParams],\n            [\"patch\", preparedUpdateParams],\n        ]) {\n            for (const originalPayload of payloads) {\n                // collect fields to be sent as separate parts\n                const { inputs, outputs, events, extra, error, serialized, attachments, ...payload } = originalPayload;\n                const fields = { inputs, outputs, events, extra, error, serialized };\n                // encode the main run payload\n                const stringifiedPayload = serializePayloadForTracing(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);\n                accumulatedParts.push({\n                    name: `${method}.${payload.id}`,\n                    payload: new Blob([stringifiedPayload], {\n                        type: `application/json; length=${stringifiedPayload.length}`, // encoding=gzip\n                    }),\n                });\n                // encode the fields we collected\n                for (const [key, value] of Object.entries(fields)) {\n                    if (value === undefined) {\n                        continue;\n                    }\n                    const stringifiedValue = serializePayloadForTracing(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);\n                    accumulatedParts.push({\n                        name: `${method}.${payload.id}.${key}`,\n                        payload: new Blob([stringifiedValue], {\n                            type: `application/json; length=${stringifiedValue.length}`,\n                        }),\n                    });\n                }\n                // encode the attachments\n                if (payload.id !== undefined) {\n                    const attachments = allAttachments[payload.id];\n                    if (attachments) {\n                        delete allAttachments[payload.id];\n                        for (const [name, attachment] of Object.entries(attachments)) {\n                            let contentType;\n                            let content;\n                            if (Array.isArray(attachment)) {\n                                [contentType, content] = attachment;\n                            }\n                            else {\n                                contentType = attachment.mimeType;\n                                content = attachment.data;\n                            }\n                            // Validate that the attachment name doesn't contain a '.'\n                            if (name.includes(\".\")) {\n                                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. ` +\n                                    `Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);\n                                continue;\n                            }\n                            accumulatedParts.push({\n                                name: `attachment.${payload.id}.${name}`,\n                                payload: new Blob([content], {\n                                    type: `${contentType}; length=${content.byteLength}`,\n                                }),\n                            });\n                        }\n                    }\n                }\n                // compute context\n                accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);\n            }\n        }\n        await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join(\"; \"), options);\n    }\n    async _createNodeFetchBody(parts, boundary) {\n        // Create multipart form data manually using Blobs\n        const chunks = [];\n        for (const part of parts) {\n            // Add field boundary\n            chunks.push(new Blob([`--${boundary}\\r\\n`]));\n            chunks.push(new Blob([\n                `Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`,\n                `Content-Type: ${part.payload.type}\\r\\n\\r\\n`,\n            ]));\n            chunks.push(part.payload);\n            chunks.push(new Blob([\"\\r\\n\"]));\n        }\n        // Add final boundary\n        chunks.push(new Blob([`--${boundary}--\\r\\n`]));\n        // Combine all chunks into a single Blob\n        const body = new Blob(chunks);\n        // Convert Blob to ArrayBuffer for compatibility\n        const arrayBuffer = await body.arrayBuffer();\n        return arrayBuffer;\n    }\n    async _createMultipartStream(parts, boundary) {\n        const encoder = new TextEncoder();\n        // Create a ReadableStream for streaming the multipart data\n        // Only do special handling if we're using node-fetch\n        const stream = new ReadableStream({\n            async start(controller) {\n                // Helper function to write a chunk to the stream\n                const writeChunk = async (chunk) => {\n                    if (typeof chunk === \"string\") {\n                        controller.enqueue(encoder.encode(chunk));\n                    }\n                    else {\n                        controller.enqueue(chunk);\n                    }\n                };\n                // Write each part to the stream\n                for (const part of parts) {\n                    // Write boundary and headers\n                    await writeChunk(`--${boundary}\\r\\n`);\n                    await writeChunk(`Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`);\n                    await writeChunk(`Content-Type: ${part.payload.type}\\r\\n\\r\\n`);\n                    // Write the payload\n                    const payloadStream = part.payload.stream();\n                    const reader = payloadStream.getReader();\n                    try {\n                        let result;\n                        while (!(result = await reader.read()).done) {\n                            controller.enqueue(result.value);\n                        }\n                    }\n                    finally {\n                        reader.releaseLock();\n                    }\n                    await writeChunk(\"\\r\\n\");\n                }\n                // Write final boundary\n                await writeChunk(`--${boundary}--\\r\\n`);\n                controller.close();\n            },\n        });\n        return stream;\n    }\n    async _sendMultipartRequest(parts, context, options) {\n        // Create multipart form data boundary\n        const boundary = \"----LangSmithFormBoundary\" + Math.random().toString(36).slice(2);\n        const isNodeFetch = _globalFetchImplementationIsNodeFetch();\n        const buildBuffered = () => this._createNodeFetchBody(parts, boundary);\n        const buildStream = () => this._createMultipartStream(parts, boundary);\n        const send = async (body) => {\n            const headers = {\n                ...this.headers,\n                \"Content-Type\": `multipart/form-data; boundary=${boundary}`,\n            };\n            if (options?.apiKey !== undefined) {\n                headers[\"x-api-key\"] = options.apiKey;\n            }\n            return this.batchIngestCaller.call(_getFetchImplementation(this.debug), `${options?.apiUrl ?? this.apiUrl}/runs/multipart`, {\n                method: \"POST\",\n                headers,\n                body,\n                duplex: \"half\",\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n        };\n        try {\n            let res;\n            let streamedAttempt = false;\n            // attempt stream only if not disabled and not using node-fetch\n            if (!isNodeFetch && !this.multipartStreamingDisabled) {\n                streamedAttempt = true;\n                res = await send(await buildStream());\n            }\n            else {\n                res = await send(await buildBuffered());\n            }\n            // if stream fails, fallback to buffered body\n            if ((!this.multipartStreamingDisabled || streamedAttempt) &&\n                res.status === 422 &&\n                (options?.apiUrl ?? this.apiUrl) !== DEFAULT_API_URL) {\n                console.warn(`Streaming multipart upload to ${options?.apiUrl ?? this.apiUrl}/runs/multipart failed. ` +\n                    `This usually means the host does not support chunked uploads. ` +\n                    `Retrying with a buffered upload for operation \"${context}\".`);\n                // Disable streaming for future requests\n                this.multipartStreamingDisabled = true;\n                // retry with fully-buffered body\n                res = await send(await buildBuffered());\n            }\n            // raise if still failing\n            await raiseForStatus(res, \"ingest multipart runs\", true);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            console.warn(`${e.message.trim()}\\n\\nContext: ${context}`);\n        }\n    }\n    async updateRun(runId, run, options) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = await this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = await this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = { ...run, id: runId };\n        if (!this._filterForSampling([data], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing &&\n            data.trace_id !== undefined &&\n            data.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            if (run.end_time !== undefined &&\n                data.parent_run_id === undefined &&\n                this.blockOnRootRunFinalization &&\n                !this.manualFlushMode) {\n                // Trigger batches as soon as a root trace ends and wait to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl,\n                }).catch(console.error);\n                return;\n            }\n            else {\n                void this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl,\n                }).catch(console.error);\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${options?.apiUrl ?? this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: serializePayloadForTracing(run, `Serializing payload to update run with id: ${runId}`),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"update run\", true);\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts, }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            }\n            else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n            }\n            else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            }\n            else {\n                const project = await this.readProject({\n                    projectName: getLangSmithEnvironmentVariable(\"PROJECT\") || \"default\",\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        }\n        else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        }\n        else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            isRoot: false,\n            projectId: run.session_id,\n            traceId: run.trace_id,\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (childRun.dotted_order?.startsWith(run.dotted_order ?? \"\") &&\n                childRun.id !== run.id) {\n                if (!(childRun.parent_run_id in treemap)) {\n                    treemap[childRun.parent_run_id] = [];\n                }\n                treemap[childRun.parent_run_id].push(childRun);\n                runs[childRun.id] = childRun;\n            }\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param isRoot - Indicates whether to only return root runs.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param treeFilter - The filter string to apply on other runs in the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */\n    async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, order, } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [projectId];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName)\n                ? projectName\n                : [projectName];\n            const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const default_select = [\n            \"app_path\",\n            \"completion_cost\",\n            \"completion_tokens\",\n            \"dotted_order\",\n            \"end_time\",\n            \"error\",\n            \"events\",\n            \"extra\",\n            \"feedback_stats\",\n            \"first_token_time\",\n            \"id\",\n            \"inputs\",\n            \"name\",\n            \"outputs\",\n            \"parent_run_id\",\n            \"parent_run_ids\",\n            \"prompt_cost\",\n            \"prompt_tokens\",\n            \"reference_example_id\",\n            \"run_type\",\n            \"session_id\",\n            \"start_time\",\n            \"status\",\n            \"tags\",\n            \"total_cost\",\n            \"total_tokens\",\n            \"trace_id\",\n        ];\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n            select: select ? select : default_select,\n            is_root: isRoot,\n            order,\n        };\n        let runsYielded = 0;\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n            if (limit) {\n                if (runsYielded >= limit) {\n                    break;\n                }\n                if (runs.length + runsYielded > limit) {\n                    const newRuns = runs.slice(0, limit - runsYielded);\n                    yield* newRuns;\n                    break;\n                }\n                runsYielded += runs.length;\n                yield* runs;\n            }\n            else {\n                yield* runs;\n            }\n        }\n    }\n    async *listGroupRuns(props) {\n        const { projectId, projectName, groupBy, filter, startTime, endTime, limit, offset, } = props;\n        const sessionId = projectId || (await this.readProject({ projectName })).id;\n        const baseBody = {\n            session_id: sessionId,\n            group_by: groupBy,\n            filter,\n            start_time: startTime ? startTime.toISOString() : null,\n            end_time: endTime ? endTime.toISOString() : null,\n            limit: Number(limit) || 100,\n        };\n        let currentOffset = Number(offset) || 0;\n        const path = \"/runs/group\";\n        const url = `${this.apiUrl}${path}`;\n        while (true) {\n            const currentBody = {\n                ...baseBody,\n                offset: currentOffset,\n            };\n            // Remove undefined values from the payload\n            const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value]) => value !== undefined));\n            const response = await this.caller.call(_getFetchImplementation(), url, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                body: JSON.stringify(filteredPayload),\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(response, `Failed to fetch ${path}`);\n            const items = await response.json();\n            const { groups, total } = items;\n            if (groups.length === 0) {\n                break;\n            }\n            for (const thread of groups) {\n                yield thread;\n            }\n            currentOffset += groups.length;\n            if (currentOffset >= total) {\n                break;\n            }\n        }\n    }\n    async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType, }) {\n        let projectIds_ = projectIds || [];\n        if (projectNames) {\n            projectIds_ = [\n                ...(projectIds || []),\n                ...(await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))),\n            ];\n        }\n        const payload = {\n            id,\n            trace,\n            parent_run: parentRun,\n            run_type: runType,\n            session: projectIds_,\n            reference_example: referenceExampleIds,\n            start_time: startTime,\n            end_time: endTime,\n            error,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            is_root: isRoot,\n            data_source_type: dataSourceType,\n        };\n        // Remove undefined values from the payload\n        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== undefined));\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/stats`, {\n            method: \"POST\",\n            headers: this.headers,\n            body: JSON.stringify(filteredPayload),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        return result;\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid.v4(),\n        };\n        assertUuid(runId);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"unshare run\", true);\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds, } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken,\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds) {\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId,\n        };\n        assertUuid(datasetId);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"unshare dataset\", true);\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    /**\n     * Get shared examples.\n     *\n     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.\n     * @param {Object} [options] Additional options for listing the examples.\n     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.\n     * @returns {Promise<Example[]>} The shared examples.\n     */\n    async listSharedExamples(shareToken, options) {\n        const params = {};\n        if (options?.exampleIds) {\n            params.id = options.exampleIds;\n        }\n        const urlParams = new URLSearchParams();\n        Object.entries(params).forEach(([key, value]) => {\n            if (Array.isArray(value)) {\n                value.forEach((v) => urlParams.append(key, v));\n            }\n            else {\n                urlParams.append(key, value);\n            }\n        });\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            if (\"detail\" in result) {\n                throw new Error(`Failed to list shared examples.\\nStatus: ${response.status}\\nMessage: ${Array.isArray(result.detail)\n                    ? result.detail.join(\"\\n\")\n                    : \"Unspecified error\"}`);\n            }\n            throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);\n        }\n        return result.map((example) => ({\n            ...example,\n            _hostUrl: this.getHostUrl(),\n        }));\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description,\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call(_getFetchImplementation(this.debug), endpoint, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"create project\");\n        const result = await response.json();\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = { ...(extra || {}), metadata };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null,\n        };\n        const response = await this.caller.call(_getFetchImplementation(this.debug), endpoint, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"update project\");\n        const result = await response.json();\n        return result;\n    }\n    async hasProject({ projectId, projectName, }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${path}?${params}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async getProjectUrl({ projectId, projectName, }) {\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide either projectName or projectId\");\n        }\n        const project = await this.readProject({ projectId, projectName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n    }\n    async getDatasetUrl({ datasetId, datasetName, }) {\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const dataset = await this.readDataset({ datasetId, datasetName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({ limit: \"1\" });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, metadata, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, `delete session ${projectId_} (${projectName})`, true);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(_getFetchImplementation(this.debug), url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"upload CSV\");\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata, } = {}) {\n        const body = {\n            name,\n            description,\n            extra: metadata ? { metadata } : undefined,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        if (inputsSchema) {\n            body.inputs_schema_definition = inputsSchema;\n        }\n        if (outputsSchema) {\n            body.outputs_schema_definition = outputsSchema;\n        }\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"create dataset\");\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        }\n        else if (datasetName) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async hasDataset({ datasetId, datasetName, }) {\n        try {\n            await this.readDataset({ datasetId, datasetName });\n            return true;\n        }\n        catch (e) {\n            if (\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            e instanceof Error &&\n                e.message.toLocaleLowerCase().includes(\"not found\")) {\n                return false;\n            }\n            throw e;\n        }\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion, }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\"\n                ? fromVersion\n                : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString(),\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n            // do nothing\n        }\n        else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({ datasetName })).id;\n        }\n        else {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText\n            .trim()\n            .split(\"\\n\")\n            .map((line) => JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    /**\n     * Update a dataset\n     * @param props The dataset details to update\n     * @returns The updated dataset\n     */\n    async updateDataset(props) {\n        const { datasetId, datasetName, ...update } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;\n        assertUuid(_datasetId);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${_datasetId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"update dataset\");\n        return (await response.json());\n    }\n    /**\n     * Updates a tag on a dataset.\n     *\n     * If the tag is already assigned to a different version of this dataset,\n     * the tag will be moved to the new version. The as_of parameter is used to\n     * determine which version of the dataset to apply the new tags to.\n     *\n     * It must be an exact version of the dataset to succeed. You can\n     * use the \"readDatasetVersion\" method to find the exact version\n     * to apply the tags to.\n     * @param params.datasetId The ID of the dataset to update. Must be provided if \"datasetName\" is not provided.\n     * @param params.datasetName The name of the dataset to update. Must be provided if \"datasetId\" is not provided.\n     * @param params.asOf The timestamp of the dataset to apply the new tags to.\n     * @param params.tag The new tag to apply to the dataset.\n     */\n    async updateDatasetTag(props) {\n        const { datasetId, datasetName, asOf, tag } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;\n        assertUuid(_datasetId);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${_datasetId}/tags`, {\n            method: \"PUT\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                as_of: typeof asOf === \"string\" ? asOf : asOf.toISOString(),\n                tag,\n            }),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"update dataset tags\");\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call(_getFetchImplementation(this.debug), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, `delete ${path}`);\n        await response.json();\n    }\n    async indexDataset({ datasetId, datasetName, tag, }) {\n        let datasetId_ = datasetId;\n        if (!datasetId_ && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (!datasetId_) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        assertUuid(datasetId_);\n        const data = {\n            tag: tag,\n        };\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId_}/index`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"index dataset\");\n        await response.json();\n    }\n    /**\n     * Lets you run a similarity search query on a dataset.\n     *\n     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.\n     *\n     * @param inputs      The input on which to run the similarity search. Must have the\n     *                    same schema as the dataset.\n     *\n     * @param datasetId   The dataset to search for similar examples.\n     *\n     * @param limit       The maximum number of examples to return. Will return the top `limit` most\n     *                    similar examples in order of most similar to least similar. If no similar\n     *                    examples are found, random examples will be returned.\n     *\n     * @param filter      A filter string to apply to the search. Only examples will be returned that\n     *                    match the filter string. Some examples of filters\n     *\n     *                    - eq(metadata.mykey, \"value\")\n     *                    - and(neq(metadata.my.nested.key, \"value\"), neq(metadata.mykey, \"value\"))\n     *                    - or(eq(metadata.mykey, \"value\"), eq(metadata.mykey, \"othervalue\"))\n     *\n     * @returns           A list of similar examples.\n     *\n     *\n     * @example\n     * dataset_id = \"123e4567-e89b-12d3-a456-426614174000\"\n     * inputs = {\"text\": \"How many people live in Berlin?\"}\n     * limit = 5\n     * examples = await client.similarExamples(inputs, dataset_id, limit)\n     */\n    async similarExamples(inputs, datasetId, limit, { filter, } = {}) {\n        const data = {\n            limit: limit,\n            inputs: inputs,\n        };\n        if (filter !== undefined) {\n            data[\"filter\"] = filter;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId}/search`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"fetch similar examples\");\n        const result = await response.json();\n        return result[\"examples\"];\n    }\n    async createExample(inputsOrUpdate, outputs, options) {\n        if (isExampleCreate(inputsOrUpdate)) {\n            if (outputs !== undefined || options !== undefined) {\n                throw new Error(\"Cannot provide outputs or options when using ExampleCreate object\");\n            }\n        }\n        let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;\n        const datasetName_ = outputs\n            ? options?.datasetName\n            : inputsOrUpdate.dataset_name;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName: datasetName_ });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || new Date();\n        let data;\n        if (!isExampleCreate(inputsOrUpdate)) {\n            data = {\n                inputs: inputsOrUpdate,\n                outputs,\n                created_at: createdAt_?.toISOString(),\n                id: options?.exampleId,\n                metadata: options?.metadata,\n                split: options?.split,\n                source_run_id: options?.sourceRunId,\n                use_source_run_io: options?.useSourceRunIO,\n                use_source_run_attachments: options?.useSourceRunAttachments,\n                attachments: options?.attachments,\n            };\n        }\n        else {\n            data = inputsOrUpdate;\n        }\n        const response = await this._uploadExamplesMultipart(datasetId_, [data]);\n        const example = await this.readExample(response.example_ids?.[0] ?? uuid.v4());\n        return example;\n    }\n    async createExamples(propsOrUploads) {\n        if (Array.isArray(propsOrUploads)) {\n            if (propsOrUploads.length === 0) {\n                return [];\n            }\n            const uploads = propsOrUploads;\n            let datasetId_ = uploads[0].dataset_id;\n            const datasetName_ = uploads[0].dataset_name;\n            if (datasetId_ === undefined && datasetName_ === undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId\");\n            }\n            else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId, not both\");\n            }\n            else if (datasetId_ === undefined) {\n                const dataset = await this.readDataset({ datasetName: datasetName_ });\n                datasetId_ = dataset.id;\n            }\n            const response = await this._uploadExamplesMultipart(datasetId_, uploads);\n            const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));\n            return examples;\n        }\n        const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName, } = propsOrUploads;\n        if (inputs === undefined) {\n            throw new Error(\"Must provide inputs when using legacy parameters\");\n        }\n        let datasetId_ = datasetId;\n        const datasetName_ = datasetName;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName: datasetName_ });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx) => {\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs?.[idx],\n                metadata: metadata?.[idx],\n                split: splits?.[idx],\n                id: exampleIds?.[idx],\n                attachments: attachments?.[idx],\n                source_run_id: sourceRunIds?.[idx],\n                use_source_run_io: useSourceRunIOs?.[idx],\n                use_source_run_attachments: useSourceRunAttachments?.[idx],\n            };\n        });\n        const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);\n        const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));\n        return examples;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({ input }, { output: generation }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message) => {\n            if (isLangChainMessage(message)) {\n                return convertLangChainMessageToExample(message);\n            }\n            return message;\n        });\n        const finalOutput = isLangChainMessage(generations)\n            ? convertLangChainMessageToExample(generations)\n            : generations;\n        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const rawExample = await this._get(path);\n        const { attachment_urls, ...rest } = rawExample;\n        const example = rest;\n        if (attachment_urls) {\n            example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {\n                acc[key.slice(\"attachment.\".length)] = {\n                    presigned_url: value.presigned_url,\n                    mime_type: value.mime_type,\n                };\n                return acc;\n            }, {});\n        }\n        return example;\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (splits !== undefined) {\n            for (const split of splits) {\n                params.append(\"splits\", split);\n            }\n        }\n        if (metadata !== undefined) {\n            const serializedMetadata = JSON.stringify(metadata);\n            params.append(\"metadata\", serializedMetadata);\n        }\n        if (limit !== undefined) {\n            params.append(\"limit\", limit.toString());\n        }\n        if (offset !== undefined) {\n            params.append(\"offset\", offset.toString());\n        }\n        if (filter !== undefined) {\n            params.append(\"filter\", filter);\n        }\n        if (includeAttachments === true) {\n            [\"attachment_urls\", \"outputs\", \"metadata\"].forEach((field) => params.append(\"select\", field));\n        }\n        let i = 0;\n        for await (const rawExamples of this._getPaginated(\"/examples\", params)) {\n            for (const rawExample of rawExamples) {\n                const { attachment_urls, ...rest } = rawExample;\n                const example = rest;\n                if (attachment_urls) {\n                    example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {\n                        acc[key.slice(\"attachment.\".length)] = {\n                            presigned_url: value.presigned_url,\n                            mime_type: value.mime_type || undefined,\n                        };\n                        return acc;\n                    }, {});\n                }\n                yield example;\n                i++;\n            }\n            if (limit !== undefined && i >= limit) {\n                break;\n            }\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call(_getFetchImplementation(this.debug), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, `delete ${path}`);\n        await response.json();\n    }\n    async updateExample(exampleIdOrUpdate, update) {\n        let exampleId;\n        if (update) {\n            exampleId = exampleIdOrUpdate;\n        }\n        else {\n            exampleId = exampleIdOrUpdate.id;\n        }\n        assertUuid(exampleId);\n        let updateToUse;\n        if (update) {\n            updateToUse = { id: exampleId, ...update };\n        }\n        else {\n            updateToUse = exampleIdOrUpdate;\n        }\n        let datasetId;\n        if (updateToUse.dataset_id !== undefined) {\n            datasetId = updateToUse.dataset_id;\n        }\n        else {\n            const example = await this.readExample(exampleId);\n            datasetId = example.dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, [updateToUse]);\n    }\n    async updateExamples(update) {\n        // We will naively get dataset id from first example and assume it works for all\n        let datasetId;\n        if (update[0].dataset_id === undefined) {\n            const example = await this.readExample(update[0].id);\n            datasetId = example.dataset_id;\n        }\n        else {\n            datasetId = update[0].dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, update);\n    }\n    /**\n     * Get dataset version by closest date or exact tag.\n     *\n     * Use this to resolve the nearest version to a given timestamp or for a given tag.\n     *\n     * @param options The options for getting the dataset version\n     * @param options.datasetId The ID of the dataset\n     * @param options.datasetName The name of the dataset\n     * @param options.asOf The timestamp of the dataset to retrieve\n     * @param options.tag The tag of the dataset to retrieve\n     * @returns The dataset version\n     */\n    async readDatasetVersion({ datasetId, datasetName, asOf, tag, }) {\n        let resolvedDatasetId;\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            resolvedDatasetId = dataset.id;\n        }\n        else {\n            resolvedDatasetId = datasetId;\n        }\n        assertUuid(resolvedDatasetId);\n        if ((asOf && tag) || (!asOf && !tag)) {\n            throw new Error(\"Exactly one of asOf and tag must be specified.\");\n        }\n        const params = new URLSearchParams();\n        if (asOf !== undefined) {\n            params.append(\"as_of\", typeof asOf === \"string\" ? asOf : asOf.toISOString());\n        }\n        if (tag !== undefined) {\n            params.append(\"tag\", tag);\n        }\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {\n            method: \"GET\",\n            headers: { ...this.headers },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"read dataset version\");\n        return await response.json();\n    }\n    async listDatasetSplits({ datasetId, datasetName, asOf, }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        }\n        else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            datasetId_ = datasetId;\n        }\n        assertUuid(datasetId_);\n        const params = new URLSearchParams();\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const response = await this._get(`/datasets/${datasetId_}/splits`, params);\n        return response;\n    }\n    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false, }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        }\n        else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            datasetId_ = datasetId;\n        }\n        assertUuid(datasetId_);\n        const data = {\n            split_name: splitName,\n            examples: exampleIds.map((id) => {\n                assertUuid(id);\n                return id;\n            }),\n            remove,\n        };\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/${datasetId_}/splits`, {\n            method: \"PUT\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"update dataset splits\", true);\n    }\n    /**\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\n     */\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample, } = { loadChildRuns: false }) {\n        warnOnce(\"This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\");\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, { loadChildRuns });\n        }\n        else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        }\n        else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null &&\n            run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);\n        return feedbacks[0];\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId, }) {\n        if (!runId && !projectId) {\n            throw new Error(\"One of runId or projectId must be provided\");\n        }\n        if (runId && projectId) {\n            throw new Error(\"Only one of runId or projectId can be provided\");\n        }\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {},\n        };\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        if (feedback_source?.metadata !== undefined &&\n            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid.v4(),\n            run_id: runId,\n            key,\n            score: _formatFeedbackScore(score),\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            comparative_experiment_id: comparativeExperimentId,\n            feedbackConfig,\n            session_id: projectId,\n        };\n        const url = `${this.apiUrl}/feedback`;\n        const response = await this.caller.call(_getFetchImplementation(this.debug), url, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"create feedback\", true);\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = _formatFeedbackScore(score);\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"update feedback\", true);\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call(_getFetchImplementation(this.debug), this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, `delete ${path}`);\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys) {\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes) {\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId The ID of the run.\n     * @param feedbackKey The feedback key.\n     * @param options Additional options for the token.\n     * @param options.expiration The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */\n    async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig, } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig,\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            }\n            else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        }\n        else {\n            body[\"expires_in\"] = {\n                hours: 3,\n            };\n        }\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/feedback/tokens`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const result = await response.json();\n        return result;\n    }\n    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id, }) {\n        if (experimentIds.length === 0) {\n            throw new Error(\"At least one experiment is required\");\n        }\n        if (!referenceDatasetId) {\n            referenceDatasetId = (await this.readProject({\n                projectId: experimentIds[0],\n            })).reference_dataset_id;\n        }\n        if (!referenceDatasetId == null) {\n            throw new Error(\"A reference dataset is required\");\n        }\n        const body = {\n            id,\n            name,\n            experiment_ids: experimentIds,\n            reference_dataset_id: referenceDatasetId,\n            description,\n            created_at: (createdAt ?? new Date())?.toISOString(),\n            extra: {},\n        };\n        if (metadata)\n            body.extra[\"metadata\"] = metadata;\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/datasets/comparative`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        return await response.json();\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */\n    async *listPresignedFeedbackTokens(runId) {\n        assertUuid(runId);\n        const params = new URLSearchParams({ run_id: runId });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)) {\n            yield* tokens;\n        }\n    }\n    _selectEvalResults(results) {\n        let results_;\n        if (\"results\" in results) {\n            results_ = results.results;\n        }\n        else if (Array.isArray(results)) {\n            results_ = results;\n        }\n        else {\n            results_ = [results];\n        }\n        return results_;\n    }\n    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const evalResults = this._selectEvalResults(evaluatorResponse);\n        const feedbacks = [];\n        for (const res of evalResults) {\n            let sourceInfo_ = sourceInfo || {};\n            if (res.evaluatorInfo) {\n                sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };\n            }\n            let runId_ = null;\n            if (res.targetRunId) {\n                runId_ = res.targetRunId;\n            }\n            else if (run) {\n                runId_ = run.id;\n            }\n            feedbacks.push(await this.createFeedback(runId_, res.key, {\n                score: res.score,\n                value: res.value,\n                comment: res.comment,\n                correction: res.correction,\n                sourceInfo: sourceInfo_,\n                sourceRunId: res.sourceRunId,\n                feedbackConfig: res.feedbackConfig,\n                feedbackSourceType: \"model\",\n            }));\n        }\n        return [evalResults, feedbacks];\n    }\n    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);\n        return results;\n    }\n    /**\n     * API for managing annotation queues\n     */\n    /**\n     * List the annotation queues on the LangSmith API.\n     * @param options - The options for listing annotation queues\n     * @param options.queueIds - The IDs of the queues to filter by\n     * @param options.name - The name of the queue to filter by\n     * @param options.nameContains - The substring that the queue name should contain\n     * @param options.limit - The maximum number of queues to return\n     * @returns An iterator of AnnotationQueue objects\n     */\n    async *listAnnotationQueues(options = {}) {\n        const { queueIds, name, nameContains, limit } = options;\n        const params = new URLSearchParams();\n        if (queueIds) {\n            queueIds.forEach((id, i) => {\n                assertUuid(id, `queueIds[${i}]`);\n                params.append(\"ids\", id);\n            });\n        }\n        if (name)\n            params.append(\"name\", name);\n        if (nameContains)\n            params.append(\"name_contains\", nameContains);\n        params.append(\"limit\", (limit !== undefined ? Math.min(limit, 100) : 100).toString());\n        let count = 0;\n        for await (const queues of this._getPaginated(\"/annotation-queues\", params)) {\n            yield* queues;\n            count++;\n            if (limit !== undefined && count >= limit)\n                break;\n        }\n    }\n    /**\n     * Create an annotation queue on the LangSmith API.\n     * @param options - The options for creating an annotation queue\n     * @param options.name - The name of the annotation queue\n     * @param options.description - The description of the annotation queue\n     * @param options.queueId - The ID of the annotation queue\n     * @returns The created AnnotationQueue object\n     */\n    async createAnnotationQueue(options) {\n        const { name, description, queueId, rubricInstructions } = options;\n        const body = {\n            name,\n            description,\n            id: queueId || uuid.v4(),\n            rubric_instructions: rubricInstructions,\n        };\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== undefined))),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"create annotation queue\");\n        const data = await response.json();\n        return data;\n    }\n    /**\n     * Read an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to read\n     * @returns The AnnotationQueueWithDetails object\n     */\n    async readAnnotationQueue(queueId) {\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"read annotation queue\");\n        const data = await response.json();\n        return data;\n    }\n    /**\n     * Update an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to update\n     * @param options - The options for updating the annotation queue\n     * @param options.name - The new name for the annotation queue\n     * @param options.description - The new description for the annotation queue\n     */\n    async updateAnnotationQueue(queueId, options) {\n        const { name, description, rubricInstructions } = options;\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                name,\n                description,\n                rubric_instructions: rubricInstructions,\n            }),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"update annotation queue\");\n    }\n    /**\n     * Delete an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to delete\n     */\n    async deleteAnnotationQueue(queueId) {\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}`, {\n            method: \"DELETE\",\n            headers: { ...this.headers, Accept: \"application/json\" },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"delete annotation queue\");\n    }\n    /**\n     * Add runs to an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue\n     * @param runIds - The IDs of the runs to be added to the annotation queue\n     */\n    async addRunsToAnnotationQueue(queueId, runIds) {\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}/runs`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(runIds.map((id, i) => assertUuid(id, `runIds[${i}]`).toString())),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"add runs to annotation queue\");\n    }\n    /**\n     * Get a run from an annotation queue at the specified index.\n     * @param queueId - The ID of the annotation queue\n     * @param index - The index of the run to retrieve\n     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object\n     * @throws {Error} If the run is not found at the given index or for other API-related errors\n     */\n    async getRunFromAnnotationQueue(queueId, index) {\n        const baseUrl = `/annotation-queues/${assertUuid(queueId, \"queueId\")}/run`;\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${baseUrl}/${index}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"get run from annotation queue\");\n        return await response.json();\n    }\n    /**\n     * Delete a run from an an annotation queue.\n     * @param queueId - The ID of the annotation queue to delete the run from\n     * @param queueRunId - The ID of the run to delete from the annotation queue\n     */\n    async deleteRunFromAnnotationQueue(queueId, queueRunId) {\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}/runs/${assertUuid(queueRunId, \"queueRunId\")}`, {\n            method: \"DELETE\",\n            headers: { ...this.headers, Accept: \"application/json\" },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"delete run from annotation queue\");\n    }\n    /**\n     * Get the size of an annotation queue.\n     * @param queueId - The ID of the annotation queue\n     */\n    async getSizeFromAnnotationQueue(queueId) {\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}/size`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"get size from annotation queue\");\n        return await response.json();\n    }\n    async _currentTenantIsOwner(owner) {\n        const settings = await this._getSettings();\n        return owner == \"-\" || settings.tenant_handle === owner;\n    }\n    async _ownerConflictError(action, owner) {\n        const settings = await this._getSettings();\n        return new Error(`Cannot ${action} for another tenant.\\n\n      Current tenant: ${settings.tenant_handle}\\n\n      Requested tenant: ${owner}`);\n    }\n    async _getLatestCommitHash(promptOwnerAndName) {\n        const res = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        const json = await res.json();\n        if (!res.ok) {\n            const detail = typeof json.detail === \"string\"\n                ? json.detail\n                : JSON.stringify(json.detail);\n            const error = new Error(`Error ${res.status}: ${res.statusText}\\n${detail}`);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            error.statusCode = res.status;\n            throw error;\n        }\n        if (json.commits.length === 0) {\n            return undefined;\n        }\n        return json.commits[0].commit_hash;\n    }\n    async _likeOrUnlikePrompt(promptIdentifier, like) {\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/likes/${owner}/${promptName}`, {\n            method: \"POST\",\n            body: JSON.stringify({ like: like }),\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, `${like ? \"like\" : \"unlike\"} prompt`);\n        return await response.json();\n    }\n    async _getPromptUrl(promptIdentifier) {\n        const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;\n            }\n            else {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}`;\n            }\n        }\n        else {\n            const settings = await this._getSettings();\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;\n            }\n            else {\n                return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;\n            }\n        }\n    }\n    async promptExists(promptIdentifier) {\n        const prompt = await this.getPrompt(promptIdentifier);\n        return !!prompt;\n    }\n    async likePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, true);\n    }\n    async unlikePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, false);\n    }\n    async *listCommits(promptOwnerAndName) {\n        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {\n            yield* commits;\n        }\n    }\n    async *listPrompts(options) {\n        const params = new URLSearchParams();\n        params.append(\"sort_field\", options?.sortField ?? \"updated_at\");\n        params.append(\"sort_direction\", \"desc\");\n        params.append(\"is_archived\", (!!options?.isArchived).toString());\n        if (options?.isPublic !== undefined) {\n            params.append(\"is_public\", options.isPublic.toString());\n        }\n        if (options?.query) {\n            params.append(\"query\", options.query);\n        }\n        for await (const prompts of this._getPaginated(\"/repos\", params, (res) => res.repos)) {\n            yield* prompts;\n        }\n    }\n    async getPrompt(promptIdentifier) {\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        if (response.status === 404) {\n            return null;\n        }\n        await raiseForStatus(response, \"get prompt\");\n        const result = await response.json();\n        if (result.repo) {\n            return result.repo;\n        }\n        else {\n            return null;\n        }\n    }\n    async createPrompt(promptIdentifier, options) {\n        const settings = await this._getSettings();\n        if (options?.isPublic && !settings.tenant_handle) {\n            throw new Error(`Cannot create a public prompt without first\\n\n        creating a LangChain Hub handle.\n        You can add a handle by creating a public prompt at:\\n\n        https://smith.langchain.com/prompts`);\n        }\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"create a prompt\", owner);\n        }\n        const data = {\n            repo_handle: promptName,\n            ...(options?.description && { description: options.description }),\n            ...(options?.readme && { readme: options.readme }),\n            ...(options?.tags && { tags: options.tags }),\n            is_public: !!options?.isPublic,\n        };\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"create prompt\");\n        const { repo } = await response.json();\n        return repo;\n    }\n    async createCommit(promptIdentifier, object, options) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        const resolvedParentCommitHash = options?.parentCommitHash === \"latest\" || !options?.parentCommitHash\n            ? await this._getLatestCommitHash(`${owner}/${promptName}`)\n            : options?.parentCommitHash;\n        const payload = {\n            manifest: JSON.parse(JSON.stringify(object)),\n            parent_commit: resolvedParentCommitHash,\n        };\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/commits/${owner}/${promptName}`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(payload),\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"create commit\");\n        const result = await response.json();\n        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : \"\"}`);\n    }\n    /**\n     * Update examples with attachments using multipart form data.\n     * @param updates List of ExampleUpdateWithAttachments objects to upsert\n     * @returns Promise with the update response\n     */\n    async updateExamplesMultipart(datasetId, updates = []) {\n        return this._updateExamplesMultipart(datasetId, updates);\n    }\n    async _updateExamplesMultipart(datasetId, updates = []) {\n        if (!(await this._getMultiPartSupport())) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of updates) {\n            const exampleId = example.id;\n            // Prepare the main example body\n            const exampleBody = {\n                ...(example.metadata && { metadata: example.metadata }),\n                ...(example.split && { split: example.split }),\n            };\n            // Add main example data\n            const stringifiedExample = serializePayloadForTracing(exampleBody, `Serializing body for example with id: ${exampleId}`);\n            const exampleBlob = new Blob([stringifiedExample], {\n                type: \"application/json\",\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = serializePayloadForTracing(example.inputs, `Serializing inputs for example with id: ${exampleId}`);\n                const inputsBlob = new Blob([stringifiedInputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = serializePayloadForTracing(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);\n                const outputsBlob = new Blob([stringifiedOutputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)) {\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    }\n                    else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([data], {\n                        type: `${mimeType}; length=${data.byteLength}`,\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n            if (example.attachments_operations) {\n                const stringifiedAttachmentsOperations = serializePayloadForTracing(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);\n                const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);\n            }\n        }\n        const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetIdToUse}/examples`)}`, {\n            method: \"PATCH\",\n            headers: this.headers,\n            body: formData,\n        });\n        const result = await response.json();\n        return result;\n    }\n    /**\n     * Upload examples with attachments using multipart form data.\n     * @param uploads List of ExampleUploadWithAttachments objects to upload\n     * @returns Promise with the upload response\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead\n     */\n    async uploadExamplesMultipart(datasetId, uploads = []) {\n        return this._uploadExamplesMultipart(datasetId, uploads);\n    }\n    async _uploadExamplesMultipart(datasetId, uploads = []) {\n        if (!(await this._getMultiPartSupport())) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of uploads) {\n            const exampleId = (example.id ?? uuid.v4()).toString();\n            // Prepare the main example body\n            const exampleBody = {\n                created_at: example.created_at,\n                ...(example.metadata && { metadata: example.metadata }),\n                ...(example.split && { split: example.split }),\n                ...(example.source_run_id && { source_run_id: example.source_run_id }),\n                ...(example.use_source_run_io && {\n                    use_source_run_io: example.use_source_run_io,\n                }),\n                ...(example.use_source_run_attachments && {\n                    use_source_run_attachments: example.use_source_run_attachments,\n                }),\n            };\n            // Add main example data\n            const stringifiedExample = serializePayloadForTracing(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);\n            const exampleBlob = new Blob([stringifiedExample], {\n                type: \"application/json\",\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = serializePayloadForTracing(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);\n                const inputsBlob = new Blob([stringifiedInputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = serializePayloadForTracing(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);\n                const outputsBlob = new Blob([stringifiedOutputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)) {\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    }\n                    else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([data], {\n                        type: `${mimeType}; length=${data.byteLength}`,\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n        }\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetId}/examples`)}`, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n        });\n        await raiseForStatus(response, \"upload examples\");\n        const result = await response.json();\n        return result;\n    }\n    async updatePrompt(promptIdentifier, options) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName] = parsePromptIdentifier(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"update a prompt\", owner);\n        }\n        const payload = {};\n        if (options?.description !== undefined)\n            payload.description = options.description;\n        if (options?.readme !== undefined)\n            payload.readme = options.readme;\n        if (options?.tags !== undefined)\n            payload.tags = options.tags;\n        if (options?.isPublic !== undefined)\n            payload.is_public = options.isPublic;\n        if (options?.isArchived !== undefined)\n            payload.is_archived = options.isArchived;\n        // Check if payload is empty\n        if (Object.keys(payload).length === 0) {\n            throw new Error(\"No valid update options provided\");\n        }\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"PATCH\",\n            body: JSON.stringify(payload),\n            headers: {\n                ...this.headers,\n                \"Content-Type\": \"application/json\",\n            },\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"update prompt\");\n        return response.json();\n    }\n    async deletePrompt(promptIdentifier) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"delete a prompt\", owner);\n        }\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/repos/${owner}/${promptName}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        return await response.json();\n    }\n    async pullPromptCommit(promptIdentifier, options) {\n        const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);\n        const response = await this.caller.call(_getFetchImplementation(this.debug), `${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? \"?include_model=true\" : \"\"}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n            ...this.fetchOptions,\n        });\n        await raiseForStatus(response, \"pull prompt commit\");\n        const result = await response.json();\n        return {\n            owner,\n            repo: promptName,\n            commit_hash: result.commit_hash,\n            manifest: result.manifest,\n            examples: result.examples,\n        };\n    }\n    /**\n     * This method should not be used directly, use `import { pull } from \"langchain/hub\"` instead.\n     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.\n     * @private\n     */\n    async _pullPrompt(promptIdentifier, options) {\n        const promptObject = await this.pullPromptCommit(promptIdentifier, {\n            includeModel: options?.includeModel,\n        });\n        const prompt = JSON.stringify(promptObject.manifest);\n        return prompt;\n    }\n    async pushPrompt(promptIdentifier, options) {\n        // Create or update prompt metadata\n        if (await this.promptExists(promptIdentifier)) {\n            if (options && Object.keys(options).some((key) => key !== \"object\")) {\n                await this.updatePrompt(promptIdentifier, {\n                    description: options?.description,\n                    readme: options?.readme,\n                    tags: options?.tags,\n                    isPublic: options?.isPublic,\n                });\n            }\n        }\n        else {\n            await this.createPrompt(promptIdentifier, {\n                description: options?.description,\n                readme: options?.readme,\n                tags: options?.tags,\n                isPublic: options?.isPublic,\n            });\n        }\n        if (!options?.object) {\n            return await this._getPromptUrl(promptIdentifier);\n        }\n        // Create a commit with the new manifest\n        const url = await this.createCommit(promptIdentifier, options?.object, {\n            parentCommitHash: options?.parentCommitHash,\n        });\n        return url;\n    }\n    /**\n     * Clone a public dataset to your own langsmith tenant.\n     * This operation is idempotent. If you already have a dataset with the given name,\n     * this function will do nothing.\n  \n     * @param {string} tokenOrUrl The token of the public dataset to clone.\n     * @param {Object} [options] Additional options for cloning the dataset.\n     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.\n     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.\n     * @returns {Promise<void>}\n     */\n    async clonePublicDataset(tokenOrUrl, options = {}) {\n        const { sourceApiUrl = this.apiUrl, datasetName } = options;\n        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);\n        const sourceClient = new Client({\n            apiUrl: parsedApiUrl,\n            // Placeholder API key not needed anymore in most cases, but\n            // some private deployments may have API key-based rate limiting\n            // that would cause this to fail if we provide no value.\n            apiKey: \"placeholder\",\n        });\n        const ds = await sourceClient.readSharedDataset(tokenUuid);\n        const finalDatasetName = datasetName || ds.name;\n        try {\n            if (await this.hasDataset({ datasetId: finalDatasetName })) {\n                console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);\n                return;\n            }\n        }\n        catch (_) {\n            // `.hasDataset` will throw an error if the dataset does not exist.\n            // no-op in that case\n        }\n        // Fetch examples first, then create the dataset\n        const examples = await sourceClient.listSharedExamples(tokenUuid);\n        const dataset = await this.createDataset(finalDatasetName, {\n            description: ds.description,\n            dataType: ds.data_type || \"kv\",\n            inputsSchema: ds.inputs_schema_definition ?? undefined,\n            outputsSchema: ds.outputs_schema_definition ?? undefined,\n        });\n        try {\n            await this.createExamples({\n                inputs: examples.map((e) => e.inputs),\n                outputs: examples.flatMap((e) => (e.outputs ? [e.outputs] : [])),\n                datasetId: dataset.id,\n            });\n        }\n        catch (e) {\n            console.error(`An error occurred while creating dataset ${finalDatasetName}. ` +\n                \"You should delete it manually.\");\n            throw e;\n        }\n    }\n    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = \"dataset\") {\n        // Try parsing as UUID\n        try {\n            assertUuid(urlOrToken); // Will throw if it's not a UUID.\n            return [apiUrl, urlOrToken];\n        }\n        catch (_) {\n            // no-op if it's not a uuid\n        }\n        // Parse as URL\n        try {\n            const parsedUrl = new URL(urlOrToken);\n            const pathParts = parsedUrl.pathname\n                .split(\"/\")\n                .filter((part) => part !== \"\");\n            if (pathParts.length >= numParts) {\n                const tokenUuid = pathParts[pathParts.length - numParts];\n                return [apiUrl, tokenUuid];\n            }\n            else {\n                throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);\n        }\n    }\n    /**\n     * Awaits all pending trace batches. Useful for environments where\n     * you need to be sure that all tracing requests finish before execution ends,\n     * such as serverless environments.\n     *\n     * @example\n     * ```\n     * import { Client } from \"langsmith\";\n     *\n     * const client = new Client();\n     *\n     * try {\n     *   // Tracing happens here\n     *   ...\n     * } finally {\n     *   await client.awaitPendingTraceBatches();\n     * }\n     * ```\n     *\n     * @returns A promise that resolves once all currently pending traces have sent.\n     */\n    async awaitPendingTraceBatches() {\n        if (this.manualFlushMode) {\n            console.warn(\"[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.\");\n            return Promise.resolve();\n        }\n        await Promise.all([\n            ...this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise),\n            this.batchIngestCaller.queue.onIdle(),\n        ]);\n        if (this.langSmithToOTELTranslator !== undefined) {\n            await getDefaultOTLPTracerComponents()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();\n        }\n    }\n}\nfunction isExampleCreate(input) {\n    return \"dataset_id\" in input || \"dataset_name\" in input;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}