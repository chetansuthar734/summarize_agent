{"ast":null,"code":"import { ignoreOverride } from \"./Options.js\";\nimport { selectParser } from \"./selectParser.js\";\nimport { getRelativePath } from \"./getRelativePath.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n  const seenItem = refs.seen.get(def);\n  if (refs.override) {\n    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n    if (seenSchema !== undefined) {\n      return seenSchema;\n    }\n  }\n  const newItem = {\n    def,\n    path: refs.currentPath,\n    jsonSchema: undefined\n  };\n  refs.seen.set(def, newItem);\n  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n  // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n  const jsonSchema = typeof jsonSchemaOrGetter === \"function\" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;\n  if (jsonSchema) {\n    addMeta(def, refs, jsonSchema);\n  }\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n    newItem.jsonSchema = jsonSchema;\n    return postProcessResult;\n  }\n  newItem.jsonSchema = jsonSchema;\n  return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n  switch (refs.$refStrategy) {\n    case \"root\":\n      return {\n        $ref: item.path.join(\"/\")\n      };\n    case \"relative\":\n      return {\n        $ref: getRelativePath(refs.currentPath, item.path)\n      };\n    case \"none\":\n    case \"seen\":\n      {\n        if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n          console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n          return parseAnyDef(refs);\n        }\n        return refs.$refStrategy === \"seen\" ? parseAnyDef(refs) : undefined;\n      }\n  }\n};\nconst addMeta = (def, refs, jsonSchema) => {\n  if (def.description) {\n    jsonSchema.description = def.description;\n    if (refs.markdownDescription) {\n      jsonSchema.markdownDescription = def.description;\n    }\n  }\n  return jsonSchema;\n};","map":{"version":3,"names":["ignoreOverride","selectParser","getRelativePath","parseAnyDef","parseDef","def","refs","forceResolution","seenItem","seen","get","override","overrideResult","seenSchema","get$ref","undefined","newItem","path","currentPath","jsonSchema","set","jsonSchemaOrGetter","typeName","addMeta","postProcess","postProcessResult","item","$refStrategy","$ref","join","length","every","value","index","console","warn","description","markdownDescription"],"sources":["/Users/chetan/Desktop/summarize_agent/frontend/node_modules/zod-to-json-schema/dist/esm/parseDef.js"],"sourcesContent":["import { ignoreOverride } from \"./Options.js\";\nimport { selectParser } from \"./selectParser.js\";\nimport { getRelativePath } from \"./getRelativePath.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n    const seenItem = refs.seen.get(def);\n    if (refs.override) {\n        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n        if (overrideResult !== ignoreOverride) {\n            return overrideResult;\n        }\n    }\n    if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n            return seenSchema;\n        }\n    }\n    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n    refs.seen.set(def, newItem);\n    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n    const jsonSchema = typeof jsonSchemaOrGetter === \"function\"\n        ? parseDef(jsonSchemaOrGetter(), refs)\n        : jsonSchemaOrGetter;\n    if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n    }\n    if (refs.postProcess) {\n        const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n        newItem.jsonSchema = jsonSchema;\n        return postProcessResult;\n    }\n    newItem.jsonSchema = jsonSchema;\n    return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n    switch (refs.$refStrategy) {\n        case \"root\":\n            return { $ref: item.path.join(\"/\") };\n        case \"relative\":\n            return { $ref: getRelativePath(refs.currentPath, item.path) };\n        case \"none\":\n        case \"seen\": {\n            if (item.path.length < refs.currentPath.length &&\n                item.path.every((value, index) => refs.currentPath[index] === value)) {\n                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n                return parseAnyDef(refs);\n            }\n            return refs.$refStrategy === \"seen\" ? parseAnyDef(refs) : undefined;\n        }\n    }\n};\nconst addMeta = (def, refs, jsonSchema) => {\n    if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n            jsonSchema.markdownDescription = def.description;\n        }\n    }\n    return jsonSchema;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}