{"ast":null,"code":"const CR = \"\\r\".charCodeAt(0);\nconst LF = \"\\n\".charCodeAt(0);\nconst NULL = \"\\0\".charCodeAt(0);\nconst COLON = \":\".charCodeAt(0);\nconst SPACE = \" \".charCodeAt(0);\nconst TRAILING_NEWLINE = [CR, LF];\nexport function BytesLineDecoder() {\n  let buffer = [];\n  let trailingCr = false;\n  return new TransformStream({\n    start() {\n      buffer = [];\n      trailingCr = false;\n    },\n    transform(chunk, controller) {\n      // See https://docs.python.org/3/glossary.html#term-universal-newlines\n      let text = chunk;\n      // Handle trailing CR from previous chunk\n      if (trailingCr) {\n        text = joinArrays([[CR], text]);\n        trailingCr = false;\n      }\n      // Check for trailing CR in current chunk\n      if (text.length > 0 && text.at(-1) === CR) {\n        trailingCr = true;\n        text = text.subarray(0, -1);\n      }\n      if (!text.length) return;\n      const trailingNewline = TRAILING_NEWLINE.includes(text.at(-1));\n      const lastIdx = text.length - 1;\n      const {\n        lines\n      } = text.reduce((acc, cur, idx) => {\n        if (acc.from > idx) return acc;\n        if (cur === CR || cur === LF) {\n          acc.lines.push(text.subarray(acc.from, idx));\n          if (cur === CR && text[idx + 1] === LF) {\n            acc.from = idx + 2;\n          } else {\n            acc.from = idx + 1;\n          }\n        }\n        if (idx === lastIdx && acc.from <= lastIdx) {\n          acc.lines.push(text.subarray(acc.from));\n        }\n        return acc;\n      }, {\n        lines: [],\n        from: 0\n      });\n      if (lines.length === 1 && !trailingNewline) {\n        buffer.push(lines[0]);\n        return;\n      }\n      if (buffer.length) {\n        // Include existing buffer in first line\n        buffer.push(lines[0]);\n        lines[0] = joinArrays(buffer);\n        buffer = [];\n      }\n      if (!trailingNewline) {\n        // If the last segment is not newline terminated,\n        // buffer it for the next chunk\n        if (lines.length) buffer = [lines.pop()];\n      }\n      // Enqueue complete lines\n      for (const line of lines) {\n        controller.enqueue(line);\n      }\n    },\n    flush(controller) {\n      if (buffer.length) {\n        controller.enqueue(joinArrays(buffer));\n      }\n    }\n  });\n}\nexport function SSEDecoder() {\n  let event = \"\";\n  let data = [];\n  let lastEventId = \"\";\n  let retry = null;\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform(chunk, controller) {\n      // Handle empty line case\n      if (!chunk.length) {\n        if (!event && !data.length && !lastEventId && retry == null) return;\n        const sse = {\n          id: lastEventId || undefined,\n          event,\n          data: data.length ? decodeArraysToJson(decoder, data) : null\n        };\n        // NOTE: as per the SSE spec, do not reset lastEventId\n        event = \"\";\n        data = [];\n        retry = null;\n        controller.enqueue(sse);\n        return;\n      }\n      // Ignore comments\n      if (chunk[0] === COLON) return;\n      const sepIdx = chunk.indexOf(COLON);\n      if (sepIdx === -1) return;\n      const fieldName = decoder.decode(chunk.subarray(0, sepIdx));\n      let value = chunk.subarray(sepIdx + 1);\n      if (value[0] === SPACE) value = value.subarray(1);\n      if (fieldName === \"event\") {\n        event = decoder.decode(value);\n      } else if (fieldName === \"data\") {\n        data.push(value);\n      } else if (fieldName === \"id\") {\n        if (value.indexOf(NULL) === -1) lastEventId = decoder.decode(value);\n      } else if (fieldName === \"retry\") {\n        const retryNum = Number.parseInt(decoder.decode(value), 10);\n        if (!Number.isNaN(retryNum)) retry = retryNum;\n      }\n    },\n    flush(controller) {\n      if (event) {\n        controller.enqueue({\n          id: lastEventId || undefined,\n          event,\n          data: data.length ? decodeArraysToJson(decoder, data) : null\n        });\n      }\n    }\n  });\n}\nfunction joinArrays(data) {\n  const totalLength = data.reduce((acc, curr) => acc + curr.length, 0);\n  const merged = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const c of data) {\n    merged.set(c, offset);\n    offset += c.length;\n  }\n  return merged;\n}\nfunction decodeArraysToJson(decoder, data) {\n  return JSON.parse(decoder.decode(joinArrays(data)));\n}","map":{"version":3,"names":["CR","charCodeAt","LF","NULL","COLON","SPACE","TRAILING_NEWLINE","BytesLineDecoder","buffer","trailingCr","TransformStream","start","transform","chunk","controller","text","joinArrays","length","at","subarray","trailingNewline","includes","lastIdx","lines","reduce","acc","cur","idx","from","push","pop","line","enqueue","flush","SSEDecoder","event","data","lastEventId","retry","decoder","TextDecoder","sse","id","undefined","decodeArraysToJson","sepIdx","indexOf","fieldName","decode","value","retryNum","Number","parseInt","isNaN","totalLength","curr","merged","Uint8Array","offset","c","set","JSON","parse"],"sources":["/Users/chetan/Desktop/summarize_agent/frontend/node_modules/@langchain/langgraph-sdk/dist/utils/sse.js"],"sourcesContent":["const CR = \"\\r\".charCodeAt(0);\nconst LF = \"\\n\".charCodeAt(0);\nconst NULL = \"\\0\".charCodeAt(0);\nconst COLON = \":\".charCodeAt(0);\nconst SPACE = \" \".charCodeAt(0);\nconst TRAILING_NEWLINE = [CR, LF];\nexport function BytesLineDecoder() {\n    let buffer = [];\n    let trailingCr = false;\n    return new TransformStream({\n        start() {\n            buffer = [];\n            trailingCr = false;\n        },\n        transform(chunk, controller) {\n            // See https://docs.python.org/3/glossary.html#term-universal-newlines\n            let text = chunk;\n            // Handle trailing CR from previous chunk\n            if (trailingCr) {\n                text = joinArrays([[CR], text]);\n                trailingCr = false;\n            }\n            // Check for trailing CR in current chunk\n            if (text.length > 0 && text.at(-1) === CR) {\n                trailingCr = true;\n                text = text.subarray(0, -1);\n            }\n            if (!text.length)\n                return;\n            const trailingNewline = TRAILING_NEWLINE.includes(text.at(-1));\n            const lastIdx = text.length - 1;\n            const { lines } = text.reduce((acc, cur, idx) => {\n                if (acc.from > idx)\n                    return acc;\n                if (cur === CR || cur === LF) {\n                    acc.lines.push(text.subarray(acc.from, idx));\n                    if (cur === CR && text[idx + 1] === LF) {\n                        acc.from = idx + 2;\n                    }\n                    else {\n                        acc.from = idx + 1;\n                    }\n                }\n                if (idx === lastIdx && acc.from <= lastIdx) {\n                    acc.lines.push(text.subarray(acc.from));\n                }\n                return acc;\n            }, { lines: [], from: 0 });\n            if (lines.length === 1 && !trailingNewline) {\n                buffer.push(lines[0]);\n                return;\n            }\n            if (buffer.length) {\n                // Include existing buffer in first line\n                buffer.push(lines[0]);\n                lines[0] = joinArrays(buffer);\n                buffer = [];\n            }\n            if (!trailingNewline) {\n                // If the last segment is not newline terminated,\n                // buffer it for the next chunk\n                if (lines.length)\n                    buffer = [lines.pop()];\n            }\n            // Enqueue complete lines\n            for (const line of lines) {\n                controller.enqueue(line);\n            }\n        },\n        flush(controller) {\n            if (buffer.length) {\n                controller.enqueue(joinArrays(buffer));\n            }\n        },\n    });\n}\nexport function SSEDecoder() {\n    let event = \"\";\n    let data = [];\n    let lastEventId = \"\";\n    let retry = null;\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform(chunk, controller) {\n            // Handle empty line case\n            if (!chunk.length) {\n                if (!event && !data.length && !lastEventId && retry == null)\n                    return;\n                const sse = {\n                    id: lastEventId || undefined,\n                    event,\n                    data: data.length ? decodeArraysToJson(decoder, data) : null,\n                };\n                // NOTE: as per the SSE spec, do not reset lastEventId\n                event = \"\";\n                data = [];\n                retry = null;\n                controller.enqueue(sse);\n                return;\n            }\n            // Ignore comments\n            if (chunk[0] === COLON)\n                return;\n            const sepIdx = chunk.indexOf(COLON);\n            if (sepIdx === -1)\n                return;\n            const fieldName = decoder.decode(chunk.subarray(0, sepIdx));\n            let value = chunk.subarray(sepIdx + 1);\n            if (value[0] === SPACE)\n                value = value.subarray(1);\n            if (fieldName === \"event\") {\n                event = decoder.decode(value);\n            }\n            else if (fieldName === \"data\") {\n                data.push(value);\n            }\n            else if (fieldName === \"id\") {\n                if (value.indexOf(NULL) === -1)\n                    lastEventId = decoder.decode(value);\n            }\n            else if (fieldName === \"retry\") {\n                const retryNum = Number.parseInt(decoder.decode(value), 10);\n                if (!Number.isNaN(retryNum))\n                    retry = retryNum;\n            }\n        },\n        flush(controller) {\n            if (event) {\n                controller.enqueue({\n                    id: lastEventId || undefined,\n                    event,\n                    data: data.length ? decodeArraysToJson(decoder, data) : null,\n                });\n            }\n        },\n    });\n}\nfunction joinArrays(data) {\n    const totalLength = data.reduce((acc, curr) => acc + curr.length, 0);\n    const merged = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const c of data) {\n        merged.set(c, offset);\n        offset += c.length;\n    }\n    return merged;\n}\nfunction decodeArraysToJson(decoder, data) {\n    return JSON.parse(decoder.decode(joinArrays(data)));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}