{"ast":null,"code":"import { z } from \"zod/v3\";\nimport pRetry from \"p-retry\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { isTraceableFunction } from \"langsmith/singletons/traceable\";\nimport { LogStreamCallbackHandler, RunLog, RunLogPatch, isLogStreamHandler } from \"../tracers/log_stream.js\";\nimport { EventStreamCallbackHandler, isStreamEventsHandler } from \"../tracers/event_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream, concat, atee, pipeGeneratorWithSetup, AsyncGeneratorWithSetup } from \"../utils/stream.js\";\nimport { raceWithSignal } from \"../utils/signal.js\";\nimport { DEFAULT_RECURSION_LIMIT, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, pickRunnableConfigKeys } from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter, isRunnableInterface } from \"./utils.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { Graph } from \"./graph.js\";\nimport { convertToHttpEventStream } from \"./wrappers.js\";\nimport { consumeAsyncIterableInContext, consumeIteratorInContext, isAsyncIterable, isIterableIterator, isIterator } from \"./iter.js\";\nimport { _isToolCall, ToolInputParsingException } from \"../tools/utils.js\";\nimport { getSchemaDescription, interopParseAsync, isSimpleStringZodSchema } from \"../utils/types/zod.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value, defaultKey) {\n  return value && !Array.isArray(value) &&\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  !(value instanceof Date) && typeof value === \"object\" ? value : {\n    [defaultKey]: value\n  };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  getName(suffix) {\n    const name =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n    return suffix ? `${name}${suffix}` : name;\n  }\n  /**\n   * Bind arguments to a Runnable, returning a new Runnable.\n   * @param kwargs\n   * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n   *\n   * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n   */\n  bind(kwargs) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      kwargs,\n      config: {}\n    });\n  }\n  /**\n   * Return a new Runnable that maps a list of inputs to a list of outputs,\n   * by calling invoke() with each input.\n   *\n   * @deprecated This will be removed in the next breaking release.\n   */\n  map() {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableEach({\n      bound: this\n    });\n  }\n  /**\n   * Add retry logic to an existing runnable.\n   * @param fields.stopAfterAttempt The number of attempts to retry.\n   * @param fields.onFailedAttempt A function that is called when a retry fails.\n   * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n   */\n  withRetry(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this,\n      kwargs: {},\n      config: {},\n      maxAttemptNumber: fields?.stopAfterAttempt,\n      ...fields\n    });\n  }\n  /**\n   * Bind config to a Runnable, returning a new Runnable.\n   * @param config New configuration parameters to attach to the new runnable.\n   * @returns A new RunnableBinding with a config matching what's passed.\n   */\n  withConfig(config) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config,\n      kwargs: {}\n    });\n  }\n  /**\n   * Create a new runnable from the current one that will try invoking\n   * other passed fallback runnables if the initial invocation fails.\n   * @param fields.fallbacks Other runnables to call if the runnable errors.\n   * @returns A new RunnableWithFallbacks.\n   */\n  withFallbacks(fields) {\n    const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableWithFallbacks({\n      runnable: this,\n      fallbacks\n    });\n  }\n  _getOptionsList(options, length = 0) {\n    if (Array.isArray(options) && options.length !== length) {\n      throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n    }\n    if (Array.isArray(options)) {\n      return options.map(ensureConfig);\n    }\n    if (length > 1 && !Array.isArray(options) && options.runId) {\n      console.warn(\"Provided runId will be used only for the first element of the batch.\");\n      const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n      return Array.from({\n        length\n      }, (_, i) => ensureConfig(i === 0 ? options : subsequent));\n    }\n    return Array.from({\n      length\n    }, () => ensureConfig(options));\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const caller = new AsyncCaller({\n      maxConcurrency,\n      onFailedAttempt: e => {\n        throw e;\n      }\n    });\n    const batchCalls = inputs.map((input, i) => caller.call(async () => {\n      try {\n        const result = await this.invoke(input, configList[i]);\n        return result;\n      } catch (e) {\n        if (batchOptions?.returnExceptions) {\n          return e;\n        }\n        throw e;\n      }\n    }));\n    return Promise.all(batchCalls);\n  }\n  /**\n   * Default streaming implementation.\n   * Subclasses should override this method if they support streaming output.\n   * @param input\n   * @param options\n   */\n  async *_streamIterator(input, options) {\n    yield this.invoke(input, options);\n  }\n  /**\n   * Stream output in chunks.\n   * @param input\n   * @param options\n   * @returns A readable stream that is also an iterable.\n   */\n  async stream(input, options) {\n    // Buffer the first streamed chunk to allow for initial errors\n    // to surface immediately.\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this._streamIterator(input, config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n  _separateRunnableConfigFromCallOptions(options) {\n    let runnableConfig;\n    if (options === undefined) {\n      runnableConfig = ensureConfig(options);\n    } else {\n      runnableConfig = ensureConfig({\n        callbacks: options.callbacks,\n        tags: options.tags,\n        metadata: options.metadata,\n        runName: options.runName,\n        configurable: options.configurable,\n        recursionLimit: options.recursionLimit,\n        maxConcurrency: options.maxConcurrency,\n        runId: options.runId,\n        timeout: options.timeout,\n        signal: options.signal\n      });\n    }\n    const callOptions = {\n      ...options\n    };\n    delete callOptions.callbacks;\n    delete callOptions.tags;\n    delete callOptions.metadata;\n    delete callOptions.runName;\n    delete callOptions.configurable;\n    delete callOptions.recursionLimit;\n    delete callOptions.maxConcurrency;\n    delete callOptions.runId;\n    delete callOptions.timeout;\n    delete callOptions.signal;\n    return [runnableConfig, callOptions];\n  }\n  async _callWithConfig(func, input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n    delete config.runId;\n    let output;\n    try {\n      const promise = func.call(this, input, config, runManager);\n      output = await raceWithSignal(promise, options?.signal);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    return output;\n  }\n  /**\n   * Internal method that handles batching and configuration for a runnable\n   * It takes a function, input values, and optional configuration, and\n   * returns a promise that resolves to the output values.\n   * @param func The function to be executed for each input value.\n   * @param input The input values to be processed.\n   * @param config Optional configuration for the function execution.\n   * @returns A promise that resolves to the output values.\n   */\n  async _batchWithConfig(func, inputs, options, batchOptions) {\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));\n    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n      delete optionsList[i].runId;\n      return handleStartRes;\n    }));\n    let outputs;\n    try {\n      const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);\n      outputs = await raceWithSignal(promise, optionsList?.[0]?.signal);\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager?.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n    return outputs;\n  }\n  /** @internal */\n  _concatOutputChunks(first, second) {\n    return concat(first, second);\n  }\n  /**\n   * Helper method to transform an Iterator of Input values into an Iterator of\n   * Output values, with callbacks.\n   * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n   */\n  async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n    let finalInput;\n    let finalInputSupported = true;\n    let finalOutput;\n    let finalOutputSupported = true;\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const outerThis = this;\n    async function* wrapInputForTracing() {\n      for await (const chunk of inputGenerator) {\n        if (finalInputSupported) {\n          if (finalInput === undefined) {\n            finalInput = chunk;\n          } else {\n            try {\n              finalInput = outerThis._concatOutputChunks(finalInput,\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              chunk);\n            } catch {\n              finalInput = undefined;\n              finalInputSupported = false;\n            }\n          }\n        }\n        yield chunk;\n      }\n    }\n    let runManager;\n    try {\n      const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), {\n        input: \"\"\n      }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), options?.signal, config);\n      delete config.runId;\n      runManager = pipe.setup;\n      const streamEventsHandler = runManager?.handlers.find(isStreamEventsHandler);\n      let iterator = pipe.output;\n      if (streamEventsHandler !== undefined && runManager !== undefined) {\n        iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);\n      }\n      const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n      if (streamLogHandler !== undefined && runManager !== undefined) {\n        iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);\n      }\n      for await (const chunk of iterator) {\n        yield chunk;\n        if (finalOutputSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              finalOutput = this._concatOutputChunks(finalOutput,\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              chunk);\n            } catch {\n              finalOutput = undefined;\n              finalOutputSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e, undefined, undefined, undefined, {\n        inputs: _coerceToDict(finalInput, \"input\")\n      });\n      throw e;\n    }\n    await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, {\n      inputs: _coerceToDict(finalInput, \"input\")\n    });\n  }\n  getGraph(_) {\n    const graph = new Graph();\n    // TODO: Add input schema for runnables\n    const inputNode = graph.addNode({\n      name: `${this.getName()}Input`,\n      schema: z.any()\n    });\n    const runnableNode = graph.addNode(this);\n    // TODO: Add output schemas for runnables\n    const outputNode = graph.addNode({\n      name: `${this.getName()}Output`,\n      schema: z.any()\n    });\n    graph.addEdge(inputNode, runnableNode);\n    graph.addEdge(runnableNode, outputNode);\n    return graph;\n  }\n  /**\n   * Create a new runnable sequence that runs each individual runnable in series,\n   * piping the output of one runnable into another runnable or runnable-like.\n   * @param coerceable A runnable, function, or object whose values are functions or runnables.\n   * @returns A new runnable sequence.\n   */\n  pipe(coerceable) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableSequence({\n      first: this,\n      last: _coerceToRunnable(coerceable)\n    });\n  }\n  /**\n   * Pick keys from the dict output of this runnable. Returns a new runnable.\n   */\n  pick(keys) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return this.pipe(new RunnablePick(keys));\n  }\n  /**\n   * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n   */\n  assign(mapping) {\n    return this.pipe(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    new RunnableAssign(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    new RunnableMap({\n      steps: mapping\n    })));\n  }\n  /**\n   * Default implementation of transform, which buffers input and then calls stream.\n   * Subclasses should override this method if they can start producing output while\n   * input is still being generated.\n   * @param generator\n   * @param options\n   */\n  async *transform(generator, options) {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        // This method should throw an error if gathering fails.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        finalChunk = this._concatOutputChunks(finalChunk, chunk);\n      }\n    }\n    yield* this._streamIterator(finalChunk, ensureConfig(options));\n  }\n  /**\n   * Stream all output from a runnable, as reported to the callback system.\n   * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n   * Output is streamed as Log objects, which include a list of\n   * jsonpatch ops that describe how the state of the run has changed in each\n   * step, and the final state of the run.\n   * The jsonpatch ops can be applied in order to construct state.\n   * @param input\n   * @param options\n   * @param streamOptions\n   */\n  async *streamLog(input, options, streamOptions) {\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"original\"\n    });\n    const config = ensureConfig(options);\n    yield* this._streamLog(input, logStreamCallbackHandler, config);\n  }\n  async *_streamLog(input, logStreamCallbackHandler, config) {\n    const {\n      callbacks\n    } = config;\n    if (callbacks === undefined) {\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = [logStreamCallbackHandler];\n    } else if (Array.isArray(callbacks)) {\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = copiedCallbacks;\n    }\n    const runnableStreamPromise = this.stream(input, config);\n    async function consumeRunnableStream() {\n      try {\n        const runnableStream = await runnableStreamPromise;\n        for await (const chunk of runnableStream) {\n          const patch = new RunLogPatch({\n            ops: [{\n              op: \"add\",\n              path: \"/streamed_output/-\",\n              value: chunk\n            }]\n          });\n          await logStreamCallbackHandler.writer.write(patch);\n        }\n      } finally {\n        await logStreamCallbackHandler.writer.close();\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    try {\n      for await (const log of logStreamCallbackHandler) {\n        yield log;\n      }\n    } finally {\n      await runnableStreamConsumePromise;\n    }\n  }\n  streamEvents(input, options, streamOptions) {\n    let stream;\n    if (options.version === \"v1\") {\n      stream = this._streamEventsV1(input, options, streamOptions);\n    } else if (options.version === \"v2\") {\n      stream = this._streamEventsV2(input, options, streamOptions);\n    } else {\n      throw new Error(`Only versions \"v1\" and \"v2\" of the schema are currently supported.`);\n    }\n    if (options.encoding === \"text/event-stream\") {\n      return convertToHttpEventStream(stream);\n    } else {\n      return IterableReadableStream.fromAsyncGenerator(stream);\n    }\n  }\n  async *_streamEventsV2(input, options, streamOptions) {\n    const eventStreamer = new EventStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false\n    });\n    const config = ensureConfig(options);\n    const runId = config.runId ?? uuidv4();\n    config.runId = runId;\n    const callbacks = config.callbacks;\n    if (callbacks === undefined) {\n      config.callbacks = [eventStreamer];\n    } else if (Array.isArray(callbacks)) {\n      config.callbacks = callbacks.concat(eventStreamer);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.addHandler(eventStreamer, true);\n      // eslint-disable-next-line no-param-reassign\n      config.callbacks = copiedCallbacks;\n    }\n    const abortController = new AbortController();\n    // Call the runnable in streaming mode,\n    // add each chunk to the output stream\n    const outerThis = this;\n    async function consumeRunnableStream() {\n      let signal;\n      let listener = null;\n      try {\n        if (options?.signal) {\n          if (\"any\" in AbortSignal) {\n            // Use native AbortSignal.any() if available (Node 19+)\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            signal = AbortSignal.any([abortController.signal, options.signal]);\n          } else {\n            // Fallback for Node 18 and below - just use the provided signal\n            signal = options.signal;\n            // Ensure we still abort our controller when the parent signal aborts\n            listener = () => {\n              abortController.abort();\n            };\n            options.signal.addEventListener(\"abort\", listener, {\n              once: true\n            });\n          }\n        } else {\n          signal = abortController.signal;\n        }\n        const runnableStream = await outerThis.stream(input, {\n          ...config,\n          signal\n        });\n        const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for await (const _ of tappedStream) {\n          // Just iterate so that the callback handler picks up events\n          if (abortController.signal.aborted) break;\n        }\n      } finally {\n        await eventStreamer.finish();\n        if (signal && listener) {\n          signal.removeEventListener(\"abort\", listener);\n        }\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    let firstEventSent = false;\n    let firstEventRunId;\n    try {\n      for await (const event of eventStreamer) {\n        // This is a work-around an issue where the inputs into the\n        // chain are not available until the entire input is consumed.\n        // As a temporary solution, we'll modify the input to be the input\n        // that was passed into the chain.\n        if (!firstEventSent) {\n          event.data.input = input;\n          firstEventSent = true;\n          firstEventRunId = event.run_id;\n          yield event;\n          continue;\n        }\n        if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n          // If it's the end event corresponding to the root runnable\n          // we dont include the input in the event since it's guaranteed\n          // to be included in the first event.\n          if (event.data?.input) {\n            delete event.data.input;\n          }\n        }\n        yield event;\n      }\n    } finally {\n      abortController.abort();\n      await runnableStreamConsumePromise;\n    }\n  }\n  async *_streamEventsV1(input, options, streamOptions) {\n    let runLog;\n    let hasEncounteredStartEvent = false;\n    const config = ensureConfig(options);\n    const rootTags = config.tags ?? [];\n    const rootMetadata = config.metadata ?? {};\n    const rootName = config.runName ?? this.getName();\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"streaming_events\"\n    });\n    const rootEventFilter = new _RootEventFilter({\n      ...streamOptions\n    });\n    const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n    for await (const log of logStream) {\n      if (!runLog) {\n        runLog = RunLog.fromRunLogPatch(log);\n      } else {\n        runLog = runLog.concat(log);\n      }\n      if (runLog.state === undefined) {\n        throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n      }\n      // Yield the start event for the root runnable if it hasn't been seen.\n      // The root run is never filtered out\n      if (!hasEncounteredStartEvent) {\n        hasEncounteredStartEvent = true;\n        const state = {\n          ...runLog.state\n        };\n        const event = {\n          run_id: state.id,\n          event: `on_${state.type}_start`,\n          name: rootName,\n          tags: rootTags,\n          metadata: rootMetadata,\n          data: {\n            input\n          }\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n      const paths = log.ops.filter(op => op.path.startsWith(\"/logs/\")).map(op => op.path.split(\"/\")[2]);\n      const dedupedPaths = [...new Set(paths)];\n      for (const path of dedupedPaths) {\n        let eventType;\n        let data = {};\n        const logEntry = runLog.state.logs[path];\n        if (logEntry.end_time === undefined) {\n          if (logEntry.streamed_output.length > 0) {\n            eventType = \"stream\";\n          } else {\n            eventType = \"start\";\n          }\n        } else {\n          eventType = \"end\";\n        }\n        if (eventType === \"start\") {\n          // Include the inputs with the start event if they are available.\n          // Usually they will NOT be available for components that operate\n          // on streams, since those components stream the input and\n          // don't know its final value until the end of the stream.\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n        } else if (eventType === \"end\") {\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n          data.output = logEntry.final_output;\n        } else if (eventType === \"stream\") {\n          const chunkCount = logEntry.streamed_output.length;\n          if (chunkCount !== 1) {\n            throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n          }\n          data = {\n            chunk: logEntry.streamed_output[0]\n          };\n          // Clean up the stream, we don't need it anymore.\n          // And this avoids duplicates as well!\n          logEntry.streamed_output = [];\n        }\n        yield {\n          event: `on_${logEntry.type}_${eventType}`,\n          name: logEntry.name,\n          run_id: logEntry.id,\n          tags: logEntry.tags,\n          metadata: logEntry.metadata,\n          data\n        };\n      }\n      // Finally, we take care of the streaming output from the root chain\n      // if there is any.\n      const {\n        state\n      } = runLog;\n      if (state.streamed_output.length > 0) {\n        const chunkCount = state.streamed_output.length;\n        if (chunkCount !== 1) {\n          throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n        }\n        const data = {\n          chunk: state.streamed_output[0]\n        };\n        // Clean up the stream, we don't need it anymore.\n        state.streamed_output = [];\n        const event = {\n          event: `on_${state.type}_stream`,\n          run_id: state.id,\n          tags: rootTags,\n          metadata: rootMetadata,\n          name: rootName,\n          data\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n    }\n    const state = runLog?.state;\n    if (state !== undefined) {\n      // Finally, yield the end event for the root runnable.\n      const event = {\n        event: `on_${state.type}_end`,\n        name: rootName,\n        run_id: state.id,\n        tags: rootTags,\n        metadata: rootMetadata,\n        data: {\n          output: state.final_output\n        }\n      };\n      if (rootEventFilter.includeEvent(event, state.type)) yield event;\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnable(thing) {\n    return isRunnableInterface(thing);\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError\n  }) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config: {},\n      configFactories: [config => ({\n        callbacks: [new RootListenersTracer({\n          config,\n          onStart,\n          onEnd,\n          onError\n        })]\n      })]\n    });\n  }\n  /**\n   * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`\n   * which contains the runnable, name, description and schema.\n   *\n   * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.\n   *\n   * @param fields\n   * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n   * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n   * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n   * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n   */\n  asTool(fields) {\n    return convertRunnableToTool(this, fields);\n  }\n}\n/**\n * Wraps a runnable and applies partial config upon invocation.\n *\n * @example\n * ```typescript\n * import {\n *   type RunnableConfig,\n *   RunnableLambda,\n * } from \"@langchain/core/runnables\";\n *\n * const enhanceProfile = (\n *   profile: Record<string, any>,\n *   config?: RunnableConfig\n * ) => {\n *   if (config?.configurable?.role) {\n *     return { ...profile, role: config.configurable.role };\n *   }\n *   return profile;\n * };\n *\n * const runnable = RunnableLambda.from(enhanceProfile);\n *\n * // Bind configuration to the runnable to set the user's role dynamically\n * const adminRunnable = runnable.bind({ configurable: { role: \"Admin\" } });\n * const userRunnable = runnable.bind({ configurable: { role: \"User\" } });\n *\n * const result1 = await adminRunnable.invoke({\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * });\n *\n * // { name: \"Alice\", email: \"alice@example.com\", role: \"Admin\" }\n *\n * const result2 = await userRunnable.invoke({\n *   name: \"Bob\",\n *   email: \"bob@example.com\"\n * });\n *\n * // { name: \"Bob\", email: \"bob@example.com\", role: \"User\" }\n * ```\n */\nexport class RunnableBinding extends Runnable {\n  static lc_name() {\n    return \"RunnableBinding\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"config\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"kwargs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"configFactories\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n    this.kwargs = fields.kwargs;\n    this.config = fields.config;\n    this.configFactories = fields.configFactories;\n  }\n  getName(suffix) {\n    return this.bound.getName(suffix);\n  }\n  async _mergeConfig(...options) {\n    const config = mergeConfigs(this.config, ...options);\n    return mergeConfigs(config, ...(this.configFactories ? await Promise.all(this.configFactories.map(async configFactory => await configFactory(config))) : []));\n  }\n  /**\n   * Binds the runnable with the specified arguments.\n   * @param kwargs The arguments to bind the runnable with.\n   * @returns A new instance of the `RunnableBinding` class that is bound with the specified arguments.\n   *\n   * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n   */\n  bind(kwargs) {\n    return new this.constructor({\n      bound: this.bound,\n      kwargs: {\n        ...this.kwargs,\n        ...kwargs\n      },\n      config: this.config\n    });\n  }\n  withConfig(config) {\n    return new this.constructor({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: {\n        ...this.config,\n        ...config\n      }\n    });\n  }\n  withRetry(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      maxAttemptNumber: fields?.stopAfterAttempt,\n      ...fields\n    });\n  }\n  async invoke(input, options) {\n    return this.bound.invoke(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async batch(inputs, options, batchOptions) {\n    const mergedOptions = Array.isArray(options) ? await Promise.all(options.map(async individualOption => this._mergeConfig(ensureConfig(individualOption), this.kwargs))) : await this._mergeConfig(ensureConfig(options), this.kwargs);\n    return this.bound.batch(inputs, mergedOptions, batchOptions);\n  }\n  /** @internal */\n  _concatOutputChunks(first, second) {\n    return this.bound._concatOutputChunks(first, second);\n  }\n  async *_streamIterator(input, options) {\n    yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async stream(input, options) {\n    return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  async *transform(generator, options) {\n    yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));\n  }\n  streamEvents(input, options, streamOptions) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const outerThis = this;\n    const generator = async function* () {\n      yield* outerThis.bound.streamEvents(input, {\n        ...(await outerThis._mergeConfig(ensureConfig(options), outerThis.kwargs)),\n        version: options.version\n      }, streamOptions);\n    };\n    return IterableReadableStream.fromAsyncGenerator(generator());\n  }\n  static isRunnableBinding(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  thing\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    return thing.bound && Runnable.isRunnable(thing.bound);\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError\n  }) {\n    return new RunnableBinding({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      configFactories: [config => ({\n        callbacks: [new RootListenersTracer({\n          config,\n          onStart,\n          onEnd,\n          onError\n        })]\n      })]\n    });\n  }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n * @example\n * ```typescript\n * import { RunnableEach, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const toUpperCase = (input: string): string => input.toUpperCase();\n * const addGreeting = (input: string): string => `Hello, ${input}!`;\n *\n * const upperCaseLambda = RunnableLambda.from(toUpperCase);\n * const greetingLambda = RunnableLambda.from(addGreeting);\n *\n * const chain = new RunnableEach({\n *   bound: upperCaseLambda.pipe(greetingLambda),\n * });\n *\n * const result = await chain.invoke([\"alice\", \"bob\", \"carol\"])\n *\n * // [\"Hello, ALICE!\", \"Hello, BOB!\", \"Hello, CAROL!\"]\n * ```\n *\n * @deprecated This will be removed in the next breaking release.\n */\nexport class RunnableEach extends Runnable {\n  static lc_name() {\n    return \"RunnableEach\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n  }\n  /**\n   * Binds the runnable with the specified arguments.\n   * @param kwargs The arguments to bind the runnable with.\n   * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n   *\n   * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n   */\n  bind(kwargs) {\n    return new RunnableEach({\n      bound: this.bound.bind(kwargs)\n    });\n  }\n  /**\n   * Invokes the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(inputs, config) {\n    return this._callWithConfig(this._invoke.bind(this), inputs, config);\n  }\n  /**\n   * A helper method that is used to invoke the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async _invoke(inputs, config, runManager) {\n    return this.bound.batch(inputs, patchConfig(config, {\n      callbacks: runManager?.getChild()\n    }));\n  }\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError\n  }) {\n    return new RunnableEach({\n      bound: this.bound.withListeners({\n        onStart,\n        onEnd,\n        onError\n      })\n    });\n  }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableRetry,\n * } from \"@langchain/core/runnables\";\n *\n * // Simulate an API call that fails\n * const simulateApiCall = (input: string): string => {\n *   console.log(`Attempting API call with input: ${input}`);\n *   throw new Error(\"API call failed due to network issue\");\n * };\n *\n * const apiCallLambda = RunnableLambda.from(simulateApiCall);\n *\n * // Apply retry logic using the .withRetry() method\n * const apiCallWithRetry = apiCallLambda.withRetry({ stopAfterAttempt: 3 });\n *\n * // Alternatively, create a RunnableRetry instance manually\n * const manualRetry = new RunnableRetry({\n *   bound: apiCallLambda,\n *   maxAttemptNumber: 3,\n *   config: {},\n * });\n *\n * // Example invocation using the .withRetry() method\n * const res = await apiCallWithRetry\n *   .invoke(\"Request 1\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n *\n * // Example invocation using the manual retry instance\n * const res2 = await manualRetry\n *   .invoke(\"Request 2\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n * ```\n */\nexport class RunnableRetry extends RunnableBinding {\n  static lc_name() {\n    return \"RunnableRetry\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"maxAttemptNumber\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"onFailedAttempt\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: () => {}\n    });\n    this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n    this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n  }\n  _patchConfigForRetry(attempt, config, runManager) {\n    const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n    return patchConfig(config, {\n      callbacks: runManager?.getChild(tag)\n    });\n  }\n  async _invoke(input, config, runManager) {\n    return pRetry(attemptNumber => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onFailedAttempt: error => this.onFailedAttempt(error, input),\n      retries: Math.max(this.maxAttemptNumber - 1, 0),\n      randomize: true\n    });\n  }\n  /**\n   * Method that invokes the runnable with the specified input, run manager,\n   * and config. It handles the retry logic by catching any errors and\n   * recursively invoking itself with the updated config for the next retry\n   * attempt.\n   * @param input The input for the runnable.\n   * @param runManager The run manager for the runnable.\n   * @param config The config for the runnable.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(input, config) {\n    return this._callWithConfig(this._invoke.bind(this), input, config);\n  }\n  async _batch(inputs, configs, runManagers, batchOptions) {\n    const resultsMap = {};\n    try {\n      await pRetry(async attemptNumber => {\n        const remainingIndexes = inputs.map((_, i) => i).filter(i => resultsMap[i.toString()] === undefined ||\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        resultsMap[i.toString()] instanceof Error);\n        const remainingInputs = remainingIndexes.map(i => inputs[i]);\n        const patchedConfigs = remainingIndexes.map(i => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n        const results = await super.batch(remainingInputs, patchedConfigs, {\n          ...batchOptions,\n          returnExceptions: true\n        });\n        let firstException;\n        for (let i = 0; i < results.length; i += 1) {\n          const result = results[i];\n          const resultMapIndex = remainingIndexes[i];\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          if (result instanceof Error) {\n            if (firstException === undefined) {\n              firstException = result;\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              firstException.input = remainingInputs[i];\n            }\n          }\n          resultsMap[resultMapIndex.toString()] = result;\n        }\n        if (firstException) {\n          throw firstException;\n        }\n        return results;\n      }, {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        onFailedAttempt: error => this.onFailedAttempt(error, error.input),\n        retries: Math.max(this.maxAttemptNumber - 1, 0),\n        randomize: true\n      });\n    } catch (e) {\n      if (batchOptions?.returnExceptions !== true) {\n        throw e;\n      }\n    }\n    return Object.keys(resultsMap).sort((a, b) => parseInt(a, 10) - parseInt(b, 10)).map(key => resultsMap[parseInt(key, 10)]);\n  }\n  async batch(inputs, options, batchOptions) {\n    return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n  }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({ model: \"gpt-4o-mini\" })]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence extends Runnable {\n  static lc_name() {\n    return \"RunnableSequence\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"first\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"middle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"last\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"omitSequenceTags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    this.first = fields.first;\n    this.middle = fields.middle ?? this.middle;\n    this.last = fields.last;\n    this.name = fields.name;\n    this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;\n  }\n  get steps() {\n    return [this.first, ...this.middle, this.last];\n  }\n  async invoke(input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n    delete config.runId;\n    let nextStepInput = input;\n    let finalOutput;\n    try {\n      const initialSteps = [this.first, ...this.middle];\n      for (let i = 0; i < initialSteps.length; i += 1) {\n        const step = initialSteps[i];\n        const promise = step.invoke(nextStepInput, patchConfig(config, {\n          callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`)\n        }));\n        nextStepInput = await raceWithSignal(promise, options?.signal);\n      }\n      // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n      if (options?.signal?.aborted) {\n        throw new Error(\"Aborted\");\n      }\n      finalOutput = await this.last.invoke(nextStepInput, patchConfig(config, {\n        callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${this.steps.length}`)\n      }));\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    return finalOutput;\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));\n    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n      delete configList[i].runId;\n      return handleStartRes;\n    }));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextStepInputs = inputs;\n    try {\n      for (let i = 0; i < this.steps.length; i += 1) {\n        const step = this.steps[i];\n        const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n          const childRunManager = runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`);\n          return patchConfig(configList[j], {\n            callbacks: childRunManager\n          });\n        }), batchOptions);\n        nextStepInputs = await raceWithSignal(promise, configList[0]?.signal);\n      }\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager?.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n    return nextStepInputs;\n  }\n  /** @internal */\n  _concatOutputChunks(first, second) {\n    return this.last._concatOutputChunks(first, second);\n  }\n  async *_streamIterator(input, options) {\n    const callbackManager_ = await getCallbackManagerForConfig(options);\n    const {\n      runId,\n      ...otherOptions\n    } = options ?? {};\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n    const steps = [this.first, ...this.middle, this.last];\n    let concatSupported = true;\n    let finalOutput;\n    async function* inputGenerator() {\n      yield input;\n    }\n    try {\n      let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, {\n        callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:1`)\n      }));\n      for (let i = 1; i < steps.length; i += 1) {\n        const step = steps[i];\n        finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, {\n          callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`)\n        }));\n      }\n      for await (const chunk of finalGenerator) {\n        options?.signal?.throwIfAborted();\n        yield chunk;\n        if (concatSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = this._concatOutputChunks(finalOutput, chunk);\n            } catch (e) {\n              finalOutput = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n  }\n  getGraph(config) {\n    const graph = new Graph();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let currentLastNode = null;\n    this.steps.forEach((step, index) => {\n      const stepGraph = step.getGraph(config);\n      if (index !== 0) {\n        stepGraph.trimFirstNode();\n      }\n      if (index !== this.steps.length - 1) {\n        stepGraph.trimLastNode();\n      }\n      graph.extend(stepGraph);\n      const stepFirstNode = stepGraph.firstNode();\n      if (!stepFirstNode) {\n        throw new Error(`Runnable ${step} has no first node`);\n      }\n      if (currentLastNode) {\n        graph.addEdge(currentLastNode, stepFirstNode);\n      }\n      currentLastNode = stepGraph.lastNode();\n    });\n    return graph;\n  }\n  pipe(coerceable) {\n    if (RunnableSequence.isRunnableSequence(coerceable)) {\n      return new RunnableSequence({\n        first: this.first,\n        middle: this.middle.concat([this.last, coerceable.first, ...coerceable.middle]),\n        last: coerceable.last,\n        name: this.name ?? coerceable.name\n      });\n    } else {\n      return new RunnableSequence({\n        first: this.first,\n        middle: [...this.middle, this.last],\n        last: _coerceToRunnable(coerceable),\n        name: this.name\n      });\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnableSequence(thing) {\n    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from([first, ...runnables], nameOrFields) {\n    let extra = {};\n    if (typeof nameOrFields === \"string\") {\n      extra.name = nameOrFields;\n    } else if (nameOrFields !== undefined) {\n      extra = nameOrFields;\n    }\n    return new RunnableSequence({\n      ...extra,\n      first: _coerceToRunnable(first),\n      middle: runnables.slice(0, -1).map(_coerceToRunnable),\n      last: _coerceToRunnable(runnables[runnables.length - 1])\n    });\n  }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap extends Runnable {\n  static lc_name() {\n    return \"RunnableMap\";\n  }\n  getStepsKeys() {\n    return Object.keys(this.steps);\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"steps\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.steps = {};\n    for (const [key, value] of Object.entries(fields.steps)) {\n      this.steps[key] = _coerceToRunnable(value);\n    }\n  }\n  static from(steps) {\n    return new RunnableMap({\n      steps\n    });\n  }\n  async invoke(input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n      input\n    }, config.runId, undefined, undefined, undefined, config?.runName);\n    delete config.runId;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const output = {};\n    try {\n      const promises = Object.entries(this.steps).map(async ([key, runnable]) => {\n        output[key] = await runnable.invoke(input, patchConfig(config, {\n          callbacks: runManager?.getChild(`map:key:${key}`)\n        }));\n      });\n      await raceWithSignal(Promise.all(promises), options?.signal);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(output);\n    return output;\n  }\n  async *_transform(generator, runManager, options) {\n    // shallow copy steps to ignore changes while iterating\n    const steps = {\n      ...this.steps\n    };\n    // each step gets a copy of the input iterator\n    const inputCopies = atee(generator, Object.keys(steps).length);\n    // start the first iteration of each output iterator\n    const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n      const gen = runnable.transform(inputCopies[i], patchConfig(options, {\n        callbacks: runManager?.getChild(`map:key:${key}`)\n      }));\n      return [key, gen.next().then(result => ({\n        key,\n        gen,\n        result\n      }))];\n    }));\n    // yield chunks as they become available,\n    // starting new iterations as needed,\n    // until all iterators are done\n    while (tasks.size) {\n      const promise = Promise.race(tasks.values());\n      const {\n        key,\n        result,\n        gen\n      } = await raceWithSignal(promise, options?.signal);\n      tasks.delete(key);\n      if (!result.done) {\n        yield {\n          [key]: result.value\n        };\n        tasks.set(key, gen.next().then(result => ({\n          key,\n          gen,\n          result\n        })));\n      }\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nexport class RunnableTraceable extends Runnable {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    if (!isTraceableFunction(fields.func)) {\n      throw new Error(\"RunnableTraceable requires a function that is wrapped in traceable higher-order function\");\n    }\n    this.func = fields.func;\n  }\n  async invoke(input, options) {\n    const [config] = this._getOptionsList(options ?? {}, 1);\n    const callbacks = await getCallbackManagerForConfig(config);\n    const promise = this.func(patchConfig(config, {\n      callbacks\n    }), input);\n    return raceWithSignal(promise, config?.signal);\n  }\n  async *_streamIterator(input, options) {\n    const [config] = this._getOptionsList(options ?? {}, 1);\n    const result = await this.invoke(input, options);\n    if (isAsyncIterable(result)) {\n      for await (const item of result) {\n        config?.signal?.throwIfAborted();\n        yield item;\n      }\n      return;\n    }\n    if (isIterator(result)) {\n      while (true) {\n        config?.signal?.throwIfAborted();\n        const state = result.next();\n        if (state.done) break;\n        yield state.value;\n      }\n      return;\n    }\n    yield result;\n  }\n  static from(func) {\n    return new RunnableTraceable({\n      func\n    });\n  }\n}\nfunction assertNonTraceableFunction(func) {\n  if (isTraceableFunction(func)) {\n    throw new Error(\"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\");\n  }\n}\n/**\n * A runnable that wraps an arbitrary function that takes a single argument.\n * @example\n * ```typescript\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const add = (input: { x: number; y: number }) => input.x + input.y;\n *\n * const multiply = (input: { value: number; multiplier: number }) =>\n *   input.value * input.multiplier;\n *\n * // Create runnables for the functions\n * const addLambda = RunnableLambda.from(add);\n * const multiplyLambda = RunnableLambda.from(multiply);\n *\n * // Chain the lambdas for a mathematical operation\n * const chainedLambda = addLambda.pipe((result) =>\n *   multiplyLambda.invoke({ value: result, multiplier: 2 })\n * );\n *\n * // Example invocation of the chainedLambda\n * const result = await chainedLambda.invoke({ x: 2, y: 3 });\n *\n * // Will log \"10\" (since (2 + 3) * 2 = 10)\n * ```\n */\nexport class RunnableLambda extends Runnable {\n  static lc_name() {\n    return \"RunnableLambda\";\n  }\n  constructor(fields) {\n    if (isTraceableFunction(fields.func)) {\n      // eslint-disable-next-line no-constructor-return\n      return RunnableTraceable.from(fields.func);\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    assertNonTraceableFunction(fields.func);\n    this.func = fields.func;\n  }\n  static from(func) {\n    return new RunnableLambda({\n      func\n    });\n  }\n  async _invoke(input, config, runManager) {\n    return new Promise((resolve, reject) => {\n      const childConfig = patchConfig(config, {\n        callbacks: runManager?.getChild(),\n        recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1\n      });\n      void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n        try {\n          let output = await this.func(input, {\n            ...childConfig\n          });\n          if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n              throw new Error(\"Recursion limit reached.\");\n            }\n            output = await output.invoke(input, {\n              ...childConfig,\n              recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1\n            });\n          } else if (isAsyncIterable(output)) {\n            let finalOutput;\n            for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {\n              config?.signal?.throwIfAborted();\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                  finalOutput = this._concatOutputChunks(finalOutput,\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  chunk);\n                } catch (e) {\n                  finalOutput = chunk;\n                }\n              }\n            }\n            output = finalOutput;\n          } else if (isIterableIterator(output)) {\n            let finalOutput;\n            for (const chunk of consumeIteratorInContext(childConfig, output)) {\n              config?.signal?.throwIfAborted();\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                  finalOutput = this._concatOutputChunks(finalOutput,\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  chunk);\n                } catch (e) {\n                  finalOutput = chunk;\n                }\n              }\n            }\n            output = finalOutput;\n          }\n          resolve(output);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(this._invoke.bind(this), input, options);\n  }\n  async *_transform(generator, runManager, config) {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          finalChunk = this._concatOutputChunks(finalChunk, chunk);\n        } catch (e) {\n          finalChunk = chunk;\n        }\n      }\n    }\n    const childConfig = patchConfig(config, {\n      callbacks: runManager?.getChild(),\n      recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1\n    });\n    const output = await new Promise((resolve, reject) => {\n      void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n        try {\n          const res = await this.func(finalChunk, {\n            ...childConfig,\n            config: childConfig\n          });\n          resolve(res);\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n    if (output && Runnable.isRunnable(output)) {\n      if (config?.recursionLimit === 0) {\n        throw new Error(\"Recursion limit reached.\");\n      }\n      const stream = await output.stream(finalChunk, childConfig);\n      for await (const chunk of stream) {\n        yield chunk;\n      }\n    } else if (isAsyncIterable(output)) {\n      for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {\n        config?.signal?.throwIfAborted();\n        yield chunk;\n      }\n    } else if (isIterableIterator(output)) {\n      for (const chunk of consumeIteratorInContext(childConfig, output)) {\n        config?.signal?.throwIfAborted();\n        yield chunk;\n      }\n    } else {\n      yield output;\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const addYears = (age: number): number => age + 5;\n * const yearsToFifty = (age: number): number => 50 - age;\n * const yearsToHundred = (age: number): number => 100 - age;\n *\n * const addYearsLambda = RunnableLambda.from(addYears);\n * const milestoneFiftyLambda = RunnableLambda.from(yearsToFifty);\n * const milestoneHundredLambda = RunnableLambda.from(yearsToHundred);\n *\n * // Pipe will coerce objects into RunnableParallel by default, but we\n * // explicitly instantiate one here to demonstrate\n * const sequence = addYearsLambda.pipe(\n *   RunnableParallel.from({\n *     years_to_fifty: milestoneFiftyLambda,\n *     years_to_hundred: milestoneHundredLambda,\n *   })\n * );\n *\n * // Invoke the sequence with a single age input\n * const res = await sequence.invoke(25);\n *\n * // { years_to_fifty: 20, years_to_hundred: 70 }\n * ```\n */\nexport class RunnableParallel extends RunnableMap {}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n * External APIs (e.g., APIs for a language model) may at times experience\n * degraded performance or even downtime.\n *\n * In these cases, it can be useful to have a fallback Runnable that can be\n * used in place of the original Runnable (e.g., fallback to another LLM provider).\n *\n * Fallbacks can be defined at the level of a single Runnable, or at the level\n * of a chain of Runnables. Fallbacks are tried in order until one succeeds or\n * all fail.\n *\n * While you can instantiate a `RunnableWithFallbacks` directly, it is usually\n * more convenient to use the `withFallbacks` method on an existing Runnable.\n *\n * When streaming, fallbacks will only be called on failures during the initial\n * stream creation. Errors that occur after a stream starts will not fallback\n * to the next Runnable.\n *\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableWithFallbacks,\n * } from \"@langchain/core/runnables\";\n *\n * const primaryOperation = (input: string): string => {\n *   if (input !== \"safe\") {\n *     throw new Error(\"Primary operation failed due to unsafe input\");\n *   }\n *   return `Processed: ${input}`;\n * };\n *\n * // Define a fallback operation that processes the input differently\n * const fallbackOperation = (input: string): string =>\n *   `Fallback processed: ${input}`;\n *\n * const primaryRunnable = RunnableLambda.from(primaryOperation);\n * const fallbackRunnable = RunnableLambda.from(fallbackOperation);\n *\n * // Apply the fallback logic using the .withFallbacks() method\n * const runnableWithFallback = primaryRunnable.withFallbacks([fallbackRunnable]);\n *\n * // Alternatively, create a RunnableWithFallbacks instance manually\n * const manualFallbackChain = new RunnableWithFallbacks({\n *   runnable: primaryRunnable,\n *   fallbacks: [fallbackRunnable],\n * });\n *\n * // Example invocation using .withFallbacks()\n * const res = await runnableWithFallback\n *   .invoke(\"unsafe input\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Fallback processed: unsafe input\"\n *\n * // Example invocation using manual instantiation\n * const res = await manualFallbackChain\n *   .invoke(\"safe\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Processed: safe\"\n * ```\n */\nexport class RunnableWithFallbacks extends Runnable {\n  static lc_name() {\n    return \"RunnableWithFallbacks\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fallbacks\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnable = fields.runnable;\n    this.fallbacks = fields.fallbacks;\n  }\n  *runnables() {\n    yield this.runnable;\n    for (const fallback of this.fallbacks) {\n      yield fallback;\n    }\n  }\n  async invoke(input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const {\n      runId,\n      ...otherConfigFields\n    } = config;\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n    const childConfig = patchConfig(otherConfigFields, {\n      callbacks: runManager?.getChild()\n    });\n    const res = await AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n      let firstError;\n      for (const runnable of this.runnables()) {\n        config?.signal?.throwIfAborted();\n        try {\n          const output = await runnable.invoke(input, childConfig);\n          await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n          return output;\n        } catch (e) {\n          if (firstError === undefined) {\n            firstError = e;\n          }\n        }\n      }\n      if (firstError === undefined) {\n        throw new Error(\"No error stored at end of fallback.\");\n      }\n      await runManager?.handleChainError(firstError);\n      throw firstError;\n    });\n    return res;\n  }\n  async *_streamIterator(input, options) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const {\n      runId,\n      ...otherConfigFields\n    } = config;\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n    let firstError;\n    let stream;\n    for (const runnable of this.runnables()) {\n      config?.signal?.throwIfAborted();\n      const childConfig = patchConfig(otherConfigFields, {\n        callbacks: runManager?.getChild()\n      });\n      try {\n        const originalStream = await runnable.stream(input, childConfig);\n        stream = consumeAsyncIterableInContext(childConfig, originalStream);\n        break;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (stream === undefined) {\n      const error = firstError ?? new Error(\"No error stored at end of fallback.\");\n      await runManager?.handleChainError(error);\n      throw error;\n    }\n    let output;\n    try {\n      for await (const chunk of stream) {\n        yield chunk;\n        try {\n          output = output === undefined ? output : this._concatOutputChunks(output, chunk);\n        } catch (e) {\n          output = undefined;\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n  }\n  async batch(inputs, options, batchOptions) {\n    if (batchOptions?.returnExceptions) {\n      throw new Error(\"Not implemented.\");\n    }\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(config => getCallbackManagerForConfig(config)));\n    const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n      const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n      delete configList[i].runId;\n      return handleStartRes;\n    }));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let firstError;\n    for (const runnable of this.runnables()) {\n      configList[0].signal?.throwIfAborted();\n      try {\n        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {\n          callbacks: runManager?.getChild()\n        })), batchOptions);\n        await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n        return outputs;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (!firstError) {\n      throw new Error(\"No error stored at end of fallbacks.\");\n    }\n    await Promise.all(runManagers.map(runManager => runManager?.handleChainError(firstError)));\n    throw firstError;\n  }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable(coerceable) {\n  if (typeof coerceable === \"function\") {\n    return new RunnableLambda({\n      func: coerceable\n    });\n  } else if (Runnable.isRunnable(coerceable)) {\n    return coerceable;\n  } else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n    const runnables = {};\n    for (const [key, value] of Object.entries(coerceable)) {\n      runnables[key] = _coerceToRunnable(value);\n    }\n    return new RunnableMap({\n      steps: runnables\n    });\n  } else {\n    throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n  }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * @example\n * ```typescript\n * import {\n *   RunnableAssign,\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const calculateAge = (x: { birthYear: number }): { age: number } => {\n *   const currentYear = new Date().getFullYear();\n *   return { age: currentYear - x.birthYear };\n * };\n *\n * const createGreeting = (x: { name: string }): { greeting: string } => {\n *   return { greeting: `Hello, ${x.name}!` };\n * };\n *\n * const mapper = RunnableParallel.from({\n *   age_step: RunnableLambda.from(calculateAge),\n *   greeting_step: RunnableLambda.from(createGreeting),\n * });\n *\n * const runnableAssign = new RunnableAssign({ mapper });\n *\n * const res = await runnableAssign.invoke({ name: \"Alice\", birthYear: 1990 });\n *\n * // { name: \"Alice\", birthYear: 1990, age_step: { age: 34 }, greeting_step: { greeting: \"Hello, Alice!\" } }\n * ```\n */\nexport class RunnableAssign extends Runnable {\n  static lc_name() {\n    return \"RunnableAssign\";\n  }\n  constructor(fields) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (fields instanceof RunnableMap) {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        mapper: fields\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"mapper\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.mapper = fields.mapper;\n  }\n  async invoke(input, options) {\n    const mapperResult = await this.mapper.invoke(input, options);\n    return {\n      ...input,\n      ...mapperResult\n    };\n  }\n  async *_transform(generator, runManager, options) {\n    // collect mapper keys\n    const mapperKeys = this.mapper.getStepsKeys();\n    // create two input gens, one for the mapper, one for the input\n    const [forPassthrough, forMapper] = atee(generator);\n    // create mapper output gen\n    const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, {\n      callbacks: runManager?.getChild()\n    }));\n    // start the mapper\n    const firstMapperChunkPromise = mapperOutput.next();\n    // yield the passthrough\n    for await (const chunk of forPassthrough) {\n      if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n        throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n      }\n      const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n      if (Object.keys(filtered).length > 0) {\n        yield filtered;\n      }\n    }\n    // yield the mapper output\n    yield (await firstMapperChunkPromise).value;\n    for await (const chunk of mapperOutput) {\n      yield chunk;\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * Useful for streaming, can be automatically created and chained by calling `runnable.pick();`.\n * @example\n * ```typescript\n * import { RunnablePick } from \"@langchain/core/runnables\";\n *\n * const inputData = {\n *   name: \"John\",\n *   age: 30,\n *   city: \"New York\",\n *   country: \"USA\",\n *   email: \"john.doe@example.com\",\n *   phone: \"+1234567890\",\n * };\n *\n * const basicInfoRunnable = new RunnablePick([\"name\", \"city\"]);\n *\n * // Example invocation\n * const res = await basicInfoRunnable.invoke(inputData);\n *\n * // { name: 'John', city: 'New York' }\n * ```\n */\nexport class RunnablePick extends Runnable {\n  static lc_name() {\n    return \"RunnablePick\";\n  }\n  constructor(fields) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = {\n        keys: fields\n      };\n    }\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"keys\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.keys = fields.keys;\n  }\n  async _pick(input) {\n    if (typeof this.keys === \"string\") {\n      return input[this.keys];\n    } else {\n      const picked = this.keys.map(key => [key, input[key]]).filter(v => v[1] !== undefined);\n      return picked.length === 0 ? undefined : Object.fromEntries(picked);\n    }\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(this._pick.bind(this), input, options);\n  }\n  async *_transform(generator) {\n    for await (const chunk of generator) {\n      const picked = await this._pick(chunk);\n      if (picked !== undefined) {\n        yield picked;\n      }\n    }\n  }\n  transform(generator, options) {\n    return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n  }\n  async stream(input, options) {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\nexport class RunnableToolLike extends RunnableBinding {\n  constructor(fields) {\n    const sequence = RunnableSequence.from([RunnableLambda.from(async input => {\n      let toolInput;\n      if (_isToolCall(input)) {\n        try {\n          toolInput = await interopParseAsync(this.schema, input.args);\n        } catch (e) {\n          throw new ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));\n        }\n      } else {\n        toolInput = input;\n      }\n      return toolInput;\n    }).withConfig({\n      runName: `${fields.name}:parse_input`\n    }), fields.bound]).withConfig({\n      runName: fields.name\n    });\n    super({\n      bound: sequence,\n      config: fields.config ?? {}\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"description\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"schema\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = fields.name;\n    this.description = fields.description;\n    this.schema = fields.schema;\n  }\n  static lc_name() {\n    return \"RunnableToolLike\";\n  }\n}\n/**\n * Given a runnable and a Zod schema, convert the runnable to a tool.\n *\n * @template RunInput The input type for the runnable.\n * @template RunOutput The output type for the runnable.\n *\n * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.\n * @param fields\n * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n * @param {InteropZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n * @returns {RunnableToolLike<InteropZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n */\nexport function convertRunnableToTool(runnable, fields) {\n  const name = fields.name ?? runnable.getName();\n  const description = fields.description ?? getSchemaDescription(fields.schema);\n  if (isSimpleStringZodSchema(fields.schema)) {\n    return new RunnableToolLike({\n      name,\n      description,\n      schema: z.object({\n        input: z.string()\n      }).transform(input => input.input),\n      bound: runnable\n    });\n  }\n  return new RunnableToolLike({\n    name,\n    description,\n    schema: fields.schema,\n    bound: runnable\n  });\n}","map":{"version":3,"names":["z","pRetry","v4","uuidv4","isTraceableFunction","LogStreamCallbackHandler","RunLog","RunLogPatch","isLogStreamHandler","EventStreamCallbackHandler","isStreamEventsHandler","Serializable","IterableReadableStream","concat","atee","pipeGeneratorWithSetup","AsyncGeneratorWithSetup","raceWithSignal","DEFAULT_RECURSION_LIMIT","ensureConfig","getCallbackManagerForConfig","mergeConfigs","patchConfig","pickRunnableConfigKeys","AsyncCaller","RootListenersTracer","_RootEventFilter","isRunnableInterface","AsyncLocalStorageProviderSingleton","Graph","convertToHttpEventStream","consumeAsyncIterableInContext","consumeIteratorInContext","isAsyncIterable","isIterableIterator","isIterator","_isToolCall","ToolInputParsingException","getSchemaDescription","interopParseAsync","isSimpleStringZodSchema","_coerceToDict","value","defaultKey","Array","isArray","Date","Runnable","constructor","arguments","Object","defineProperty","enumerable","configurable","writable","getName","suffix","name","lc_name","bind","kwargs","RunnableBinding","bound","config","map","RunnableEach","withRetry","fields","RunnableRetry","maxAttemptNumber","stopAfterAttempt","withConfig","withFallbacks","fallbacks","RunnableWithFallbacks","runnable","_getOptionsList","options","length","Error","runId","console","warn","subsequent","fromEntries","entries","filter","key","from","_","i","batch","inputs","batchOptions","configList","maxConcurrency","caller","onFailedAttempt","e","batchCalls","input","call","result","invoke","returnExceptions","Promise","all","_streamIterator","stream","wrappedGenerator","generator","setup","fromAsyncGenerator","_separateRunnableConfigFromCallOptions","runnableConfig","undefined","callbacks","tags","metadata","runName","recursionLimit","timeout","signal","callOptions","_callWithConfig","func","callbackManager_","runManager","handleChainStart","toJSON","runType","output","promise","handleChainError","handleChainEnd","_batchWithConfig","optionsList","callbackManagers","runManagers","callbackManager","handleStartRes","outputs","_concatOutputChunks","first","second","_transformStreamWithConfig","inputGenerator","transformer","finalInput","finalInputSupported","finalOutput","finalOutputSupported","outerThis","wrapInputForTracing","chunk","pipe","streamEventsHandler","handlers","find","iterator","tapOutputIterable","streamLogHandler","getGraph","graph","inputNode","addNode","schema","any","runnableNode","outputNode","addEdge","coerceable","RunnableSequence","last","_coerceToRunnable","pick","keys","RunnablePick","assign","mapping","RunnableAssign","RunnableMap","steps","transform","finalChunk","streamLog","streamOptions","logStreamCallbackHandler","autoClose","_schemaFormat","_streamLog","copiedCallbacks","copy","addHandler","runnableStreamPromise","consumeRunnableStream","runnableStream","patch","ops","op","path","writer","write","close","runnableStreamConsumePromise","log","streamEvents","version","_streamEventsV1","_streamEventsV2","encoding","eventStreamer","abortController","AbortController","listener","AbortSignal","abort","addEventListener","once","tappedStream","aborted","finish","removeEventListener","firstEventSent","firstEventRunId","event","data","run_id","endsWith","runLog","hasEncounteredStartEvent","rootTags","rootMetadata","rootName","rootEventFilter","logStream","fromRunLogPatch","state","id","type","includeEvent","paths","startsWith","split","dedupedPaths","Set","eventType","logEntry","logs","end_time","streamed_output","final_output","chunkCount","isRunnable","thing","withListeners","onStart","onEnd","onError","configFactories","asTool","convertRunnableToTool","_mergeConfig","configFactory","mergedOptions","individualOption","isRunnableBinding","_invoke","getChild","_patchConfigForRetry","attempt","tag","attemptNumber","error","retries","Math","max","randomize","_batch","configs","resultsMap","remainingIndexes","toString","remainingInputs","patchedConfigs","results","firstException","resultMapIndex","sort","a","b","parseInt","middle","omitSequenceTags","nextStepInput","initialSteps","step","nextStepInputs","j","childRunManager","otherOptions","concatSupported","finalGenerator","throwIfAborted","currentLastNode","forEach","index","stepGraph","trimFirstNode","trimLastNode","extend","stepFirstNode","firstNode","lastNode","isRunnableSequence","runnables","nameOrFields","extra","slice","getStepsKeys","promises","_transform","inputCopies","tasks","Map","gen","next","then","size","race","values","delete","done","set","RunnableTraceable","item","assertNonTraceableFunction","RunnableLambda","resolve","reject","childConfig","runWithConfig","res","RunnableParallel","fallback","otherConfigFields","firstError","originalStream","mapper","mapperResult","mapperKeys","forPassthrough","forMapper","mapperOutput","firstMapperChunkPromise","filtered","includes","_pick","picked","v","RunnableToolLike","sequence","toolInput","args","JSON","stringify","description","object","string"],"sources":["/Users/chetan/Desktop/summarize_agent/frontend/node_modules/@langchain/core/dist/runnables/base.js"],"sourcesContent":["import { z } from \"zod/v3\";\nimport pRetry from \"p-retry\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { isTraceableFunction, } from \"langsmith/singletons/traceable\";\nimport { LogStreamCallbackHandler, RunLog, RunLogPatch, isLogStreamHandler, } from \"../tracers/log_stream.js\";\nimport { EventStreamCallbackHandler, isStreamEventsHandler, } from \"../tracers/event_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream, concat, atee, pipeGeneratorWithSetup, AsyncGeneratorWithSetup, } from \"../utils/stream.js\";\nimport { raceWithSignal } from \"../utils/signal.js\";\nimport { DEFAULT_RECURSION_LIMIT, ensureConfig, getCallbackManagerForConfig, mergeConfigs, patchConfig, pickRunnableConfigKeys, } from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter, isRunnableInterface } from \"./utils.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { Graph } from \"./graph.js\";\nimport { convertToHttpEventStream } from \"./wrappers.js\";\nimport { consumeAsyncIterableInContext, consumeIteratorInContext, isAsyncIterable, isIterableIterator, isIterator, } from \"./iter.js\";\nimport { _isToolCall, ToolInputParsingException } from \"../tools/utils.js\";\nimport { getSchemaDescription, interopParseAsync, isSimpleStringZodSchema, } from \"../utils/types/zod.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value, defaultKey) {\n    return value &&\n        !Array.isArray(value) &&\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        !(value instanceof Date) &&\n        typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    getName(suffix) {\n        const name = \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.name ?? this.constructor.lc_name() ?? this.constructor.name;\n        return suffix ? `${name}${suffix}` : name;\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs, config: {} });\n    }\n    /**\n     * Return a new Runnable that maps a list of inputs to a list of outputs,\n     * by calling invoke() with each input.\n     *\n     * @deprecated This will be removed in the next breaking release.\n     */\n    map() {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableEach({ bound: this });\n    }\n    /**\n     * Add retry logic to an existing runnable.\n     * @param fields.stopAfterAttempt The number of attempts to retry.\n     * @param fields.onFailedAttempt A function that is called when a retry fails.\n     * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n     */\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this,\n            kwargs: {},\n            config: {},\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    /**\n     * Bind config to a Runnable, returning a new Runnable.\n     * @param config New configuration parameters to attach to the new runnable.\n     * @returns A new RunnableBinding with a config matching what's passed.\n     */\n    withConfig(config) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config,\n            kwargs: {},\n        });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options) && options.length !== length) {\n            throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n        }\n        if (Array.isArray(options)) {\n            return options.map(ensureConfig);\n        }\n        if (length > 1 && !Array.isArray(options) && options.runId) {\n            console.warn(\"Provided runId will be used only for the first element of the batch.\");\n            const subsequent = Object.fromEntries(Object.entries(options).filter(([key]) => key !== \"runId\"));\n            return Array.from({ length }, (_, i) => ensureConfig(i === 0 ? options : subsequent));\n        }\n        return Array.from({ length }, () => ensureConfig(options));\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const maxConcurrency = configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n        const caller = new AsyncCaller({\n            maxConcurrency,\n            onFailedAttempt: (e) => {\n                throw e;\n            },\n        });\n        const batchCalls = inputs.map((input, i) => caller.call(async () => {\n            try {\n                const result = await this.invoke(input, configList[i]);\n                return result;\n            }\n            catch (e) {\n                if (batchOptions?.returnExceptions) {\n                    return e;\n                }\n                throw e;\n            }\n        }));\n        return Promise.all(batchCalls);\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        // Buffer the first streamed chunk to allow for initial errors\n        // to surface immediately.\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this._streamIterator(input, config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n    _separateRunnableConfigFromCallOptions(options) {\n        let runnableConfig;\n        if (options === undefined) {\n            runnableConfig = ensureConfig(options);\n        }\n        else {\n            runnableConfig = ensureConfig({\n                callbacks: options.callbacks,\n                tags: options.tags,\n                metadata: options.metadata,\n                runName: options.runName,\n                configurable: options.configurable,\n                recursionLimit: options.recursionLimit,\n                maxConcurrency: options.maxConcurrency,\n                runId: options.runId,\n                timeout: options.timeout,\n                signal: options.signal,\n            });\n        }\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        delete callOptions.runName;\n        delete callOptions.configurable;\n        delete callOptions.recursionLimit;\n        delete callOptions.maxConcurrency;\n        delete callOptions.runId;\n        delete callOptions.timeout;\n        delete callOptions.signal;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, config?.runType, undefined, undefined, config?.runName ?? this.getName());\n        delete config.runId;\n        let output;\n        try {\n            const promise = func.call(this, input, config, runManager);\n            output = await raceWithSignal(promise, options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    /**\n     * Internal method that handles batching and configuration for a runnable\n     * It takes a function, input values, and optional configuration, and\n     * returns a promise that resolves to the output values.\n     * @param func The function to be executed for each input value.\n     * @param input The input values to be processed.\n     * @param config Optional configuration for the function execution.\n     * @returns A promise that resolves to the output values.\n     */\n    async _batchWithConfig(func, inputs, options, batchOptions) {\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(optionsList.map(getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), optionsList[i].runId, optionsList[i].runType, undefined, undefined, optionsList[i].runName ?? this.getName());\n            delete optionsList[i].runId;\n            return handleStartRes;\n        }));\n        let outputs;\n        try {\n            const promise = func.call(this, inputs, optionsList, runManagers, batchOptions);\n            outputs = await raceWithSignal(promise, optionsList?.[0]?.signal);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))));\n        return outputs;\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        return concat(first, second);\n    }\n    /**\n     * Helper method to transform an Iterator of Input values into an Iterator of\n     * Output values, with callbacks.\n     * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n     */\n    async *_transformStreamWithConfig(inputGenerator, transformer, options) {\n        let finalInput;\n        let finalInputSupported = true;\n        let finalOutput;\n        let finalOutputSupported = true;\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const outerThis = this;\n        async function* wrapInputForTracing() {\n            for await (const chunk of inputGenerator) {\n                if (finalInputSupported) {\n                    if (finalInput === undefined) {\n                        finalInput = chunk;\n                    }\n                    else {\n                        try {\n                            finalInput = outerThis._concatOutputChunks(finalInput, \n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            chunk);\n                        }\n                        catch {\n                            finalInput = undefined;\n                            finalInputSupported = false;\n                        }\n                    }\n                }\n                yield chunk;\n            }\n        }\n        let runManager;\n        try {\n            const pipe = await pipeGeneratorWithSetup(transformer.bind(this), wrapInputForTracing(), async () => callbackManager_?.handleChainStart(this.toJSON(), { input: \"\" }, config.runId, config.runType, undefined, undefined, config.runName ?? this.getName()), options?.signal, config);\n            delete config.runId;\n            runManager = pipe.setup;\n            const streamEventsHandler = runManager?.handlers.find(isStreamEventsHandler);\n            let iterator = pipe.output;\n            if (streamEventsHandler !== undefined && runManager !== undefined) {\n                iterator = streamEventsHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n            if (streamLogHandler !== undefined && runManager !== undefined) {\n                iterator = streamLogHandler.tapOutputIterable(runManager.runId, iterator);\n            }\n            for await (const chunk of iterator) {\n                yield chunk;\n                if (finalOutputSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            finalOutput = this._concatOutputChunks(finalOutput, \n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            chunk);\n                        }\n                        catch {\n                            finalOutput = undefined;\n                            finalOutputSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e, undefined, undefined, undefined, {\n                inputs: _coerceToDict(finalInput, \"input\"),\n            });\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {}, undefined, undefined, undefined, { inputs: _coerceToDict(finalInput, \"input\") });\n    }\n    getGraph(_) {\n        const graph = new Graph();\n        // TODO: Add input schema for runnables\n        const inputNode = graph.addNode({\n            name: `${this.getName()}Input`,\n            schema: z.any(),\n        });\n        const runnableNode = graph.addNode(this);\n        // TODO: Add output schemas for runnables\n        const outputNode = graph.addNode({\n            name: `${this.getName()}Output`,\n            schema: z.any(),\n        });\n        graph.addEdge(inputNode, runnableNode);\n        graph.addEdge(runnableNode, outputNode);\n        return graph;\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    /**\n     * Pick keys from the dict output of this runnable. Returns a new runnable.\n     */\n    pick(keys) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return this.pipe(new RunnablePick(keys));\n    }\n    /**\n     * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n     */\n    assign(mapping) {\n        return this.pipe(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap({ steps: mapping })));\n    }\n    /**\n     * Default implementation of transform, which buffers input and then calls stream.\n     * Subclasses should override this method if they can start producing output while\n     * input is still being generated.\n     * @param generator\n     * @param options\n     */\n    async *transform(generator, options) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                // This method should throw an error if gathering fails.\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                finalChunk = this._concatOutputChunks(finalChunk, chunk);\n            }\n        }\n        yield* this._streamIterator(finalChunk, ensureConfig(options));\n    }\n    /**\n     * Stream all output from a runnable, as reported to the callback system.\n     * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n     * Output is streamed as Log objects, which include a list of\n     * jsonpatch ops that describe how the state of the run has changed in each\n     * step, and the final state of the run.\n     * The jsonpatch ops can be applied in order to construct state.\n     * @param input\n     * @param options\n     * @param streamOptions\n     */\n    async *streamLog(input, options, streamOptions) {\n        const logStreamCallbackHandler = new LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"original\",\n        });\n        const config = ensureConfig(options);\n        yield* this._streamLog(input, logStreamCallbackHandler, config);\n    }\n    async *_streamLog(input, logStreamCallbackHandler, config) {\n        const { callbacks } = config;\n        if (callbacks === undefined) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = [logStreamCallbackHandler];\n        }\n        else if (Array.isArray(callbacks)) {\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const runnableStreamPromise = this.stream(input, config);\n        async function consumeRunnableStream() {\n            try {\n                const runnableStream = await runnableStreamPromise;\n                for await (const chunk of runnableStream) {\n                    const patch = new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: \"/streamed_output/-\",\n                                value: chunk,\n                            },\n                        ],\n                    });\n                    await logStreamCallbackHandler.writer.write(patch);\n                }\n            }\n            finally {\n                await logStreamCallbackHandler.writer.close();\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        try {\n            for await (const log of logStreamCallbackHandler) {\n                yield log;\n            }\n        }\n        finally {\n            await runnableStreamConsumePromise;\n        }\n    }\n    streamEvents(input, options, streamOptions) {\n        let stream;\n        if (options.version === \"v1\") {\n            stream = this._streamEventsV1(input, options, streamOptions);\n        }\n        else if (options.version === \"v2\") {\n            stream = this._streamEventsV2(input, options, streamOptions);\n        }\n        else {\n            throw new Error(`Only versions \"v1\" and \"v2\" of the schema are currently supported.`);\n        }\n        if (options.encoding === \"text/event-stream\") {\n            return convertToHttpEventStream(stream);\n        }\n        else {\n            return IterableReadableStream.fromAsyncGenerator(stream);\n        }\n    }\n    async *_streamEventsV2(input, options, streamOptions) {\n        const eventStreamer = new EventStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n        });\n        const config = ensureConfig(options);\n        const runId = config.runId ?? uuidv4();\n        config.runId = runId;\n        const callbacks = config.callbacks;\n        if (callbacks === undefined) {\n            config.callbacks = [eventStreamer];\n        }\n        else if (Array.isArray(callbacks)) {\n            config.callbacks = callbacks.concat(eventStreamer);\n        }\n        else {\n            const copiedCallbacks = callbacks.copy();\n            copiedCallbacks.addHandler(eventStreamer, true);\n            // eslint-disable-next-line no-param-reassign\n            config.callbacks = copiedCallbacks;\n        }\n        const abortController = new AbortController();\n        // Call the runnable in streaming mode,\n        // add each chunk to the output stream\n        const outerThis = this;\n        async function consumeRunnableStream() {\n            let signal;\n            let listener = null;\n            try {\n                if (options?.signal) {\n                    if (\"any\" in AbortSignal) {\n                        // Use native AbortSignal.any() if available (Node 19+)\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        signal = AbortSignal.any([\n                            abortController.signal,\n                            options.signal,\n                        ]);\n                    }\n                    else {\n                        // Fallback for Node 18 and below - just use the provided signal\n                        signal = options.signal;\n                        // Ensure we still abort our controller when the parent signal aborts\n                        listener = () => {\n                            abortController.abort();\n                        };\n                        options.signal.addEventListener(\"abort\", listener, { once: true });\n                    }\n                }\n                else {\n                    signal = abortController.signal;\n                }\n                const runnableStream = await outerThis.stream(input, {\n                    ...config,\n                    signal,\n                });\n                const tappedStream = eventStreamer.tapOutputIterable(runId, runnableStream);\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                for await (const _ of tappedStream) {\n                    // Just iterate so that the callback handler picks up events\n                    if (abortController.signal.aborted)\n                        break;\n                }\n            }\n            finally {\n                await eventStreamer.finish();\n                if (signal && listener) {\n                    signal.removeEventListener(\"abort\", listener);\n                }\n            }\n        }\n        const runnableStreamConsumePromise = consumeRunnableStream();\n        let firstEventSent = false;\n        let firstEventRunId;\n        try {\n            for await (const event of eventStreamer) {\n                // This is a work-around an issue where the inputs into the\n                // chain are not available until the entire input is consumed.\n                // As a temporary solution, we'll modify the input to be the input\n                // that was passed into the chain.\n                if (!firstEventSent) {\n                    event.data.input = input;\n                    firstEventSent = true;\n                    firstEventRunId = event.run_id;\n                    yield event;\n                    continue;\n                }\n                if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n                    // If it's the end event corresponding to the root runnable\n                    // we dont include the input in the event since it's guaranteed\n                    // to be included in the first event.\n                    if (event.data?.input) {\n                        delete event.data.input;\n                    }\n                }\n                yield event;\n            }\n        }\n        finally {\n            abortController.abort();\n            await runnableStreamConsumePromise;\n        }\n    }\n    async *_streamEventsV1(input, options, streamOptions) {\n        let runLog;\n        let hasEncounteredStartEvent = false;\n        const config = ensureConfig(options);\n        const rootTags = config.tags ?? [];\n        const rootMetadata = config.metadata ?? {};\n        const rootName = config.runName ?? this.getName();\n        const logStreamCallbackHandler = new LogStreamCallbackHandler({\n            ...streamOptions,\n            autoClose: false,\n            _schemaFormat: \"streaming_events\",\n        });\n        const rootEventFilter = new _RootEventFilter({\n            ...streamOptions,\n        });\n        const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n        for await (const log of logStream) {\n            if (!runLog) {\n                runLog = RunLog.fromRunLogPatch(log);\n            }\n            else {\n                runLog = runLog.concat(log);\n            }\n            if (runLog.state === undefined) {\n                throw new Error(`Internal error: \"streamEvents\" state is missing. Please open a bug report.`);\n            }\n            // Yield the start event for the root runnable if it hasn't been seen.\n            // The root run is never filtered out\n            if (!hasEncounteredStartEvent) {\n                hasEncounteredStartEvent = true;\n                const state = { ...runLog.state };\n                const event = {\n                    run_id: state.id,\n                    event: `on_${state.type}_start`,\n                    name: rootName,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    data: {\n                        input,\n                    },\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n            const paths = log.ops\n                .filter((op) => op.path.startsWith(\"/logs/\"))\n                .map((op) => op.path.split(\"/\")[2]);\n            const dedupedPaths = [...new Set(paths)];\n            for (const path of dedupedPaths) {\n                let eventType;\n                let data = {};\n                const logEntry = runLog.state.logs[path];\n                if (logEntry.end_time === undefined) {\n                    if (logEntry.streamed_output.length > 0) {\n                        eventType = \"stream\";\n                    }\n                    else {\n                        eventType = \"start\";\n                    }\n                }\n                else {\n                    eventType = \"end\";\n                }\n                if (eventType === \"start\") {\n                    // Include the inputs with the start event if they are available.\n                    // Usually they will NOT be available for components that operate\n                    // on streams, since those components stream the input and\n                    // don't know its final value until the end of the stream.\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                }\n                else if (eventType === \"end\") {\n                    if (logEntry.inputs !== undefined) {\n                        data.input = logEntry.inputs;\n                    }\n                    data.output = logEntry.final_output;\n                }\n                else if (eventType === \"stream\") {\n                    const chunkCount = logEntry.streamed_output.length;\n                    if (chunkCount !== 1) {\n                        throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`);\n                    }\n                    data = { chunk: logEntry.streamed_output[0] };\n                    // Clean up the stream, we don't need it anymore.\n                    // And this avoids duplicates as well!\n                    logEntry.streamed_output = [];\n                }\n                yield {\n                    event: `on_${logEntry.type}_${eventType}`,\n                    name: logEntry.name,\n                    run_id: logEntry.id,\n                    tags: logEntry.tags,\n                    metadata: logEntry.metadata,\n                    data,\n                };\n            }\n            // Finally, we take care of the streaming output from the root chain\n            // if there is any.\n            const { state } = runLog;\n            if (state.streamed_output.length > 0) {\n                const chunkCount = state.streamed_output.length;\n                if (chunkCount !== 1) {\n                    throw new Error(`Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`);\n                }\n                const data = { chunk: state.streamed_output[0] };\n                // Clean up the stream, we don't need it anymore.\n                state.streamed_output = [];\n                const event = {\n                    event: `on_${state.type}_stream`,\n                    run_id: state.id,\n                    tags: rootTags,\n                    metadata: rootMetadata,\n                    name: rootName,\n                    data,\n                };\n                if (rootEventFilter.includeEvent(event, state.type)) {\n                    yield event;\n                }\n            }\n        }\n        const state = runLog?.state;\n        if (state !== undefined) {\n            // Finally, yield the end event for the root runnable.\n            const event = {\n                event: `on_${state.type}_end`,\n                name: rootName,\n                run_id: state.id,\n                tags: rootTags,\n                metadata: rootMetadata,\n                data: {\n                    output: state.final_output,\n                },\n            };\n            if (rootEventFilter.includeEvent(event, state.type))\n                yield event;\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return isRunnableInterface(thing);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({\n            bound: this,\n            config: {},\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n    /**\n     * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`\n     * which contains the runnable, name, description and schema.\n     *\n     * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.\n     *\n     * @param fields\n     * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n     * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n     * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n     * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n     */\n    asTool(fields) {\n        return convertRunnableToTool(this, fields);\n    }\n}\n/**\n * Wraps a runnable and applies partial config upon invocation.\n *\n * @example\n * ```typescript\n * import {\n *   type RunnableConfig,\n *   RunnableLambda,\n * } from \"@langchain/core/runnables\";\n *\n * const enhanceProfile = (\n *   profile: Record<string, any>,\n *   config?: RunnableConfig\n * ) => {\n *   if (config?.configurable?.role) {\n *     return { ...profile, role: config.configurable.role };\n *   }\n *   return profile;\n * };\n *\n * const runnable = RunnableLambda.from(enhanceProfile);\n *\n * // Bind configuration to the runnable to set the user's role dynamically\n * const adminRunnable = runnable.bind({ configurable: { role: \"Admin\" } });\n * const userRunnable = runnable.bind({ configurable: { role: \"User\" } });\n *\n * const result1 = await adminRunnable.invoke({\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * });\n *\n * // { name: \"Alice\", email: \"alice@example.com\", role: \"Admin\" }\n *\n * const result2 = await userRunnable.invoke({\n *   name: \"Bob\",\n *   email: \"bob@example.com\"\n * });\n *\n * // { name: \"Bob\", email: \"bob@example.com\", role: \"User\" }\n * ```\n */\nexport class RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"config\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"configFactories\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n        this.config = fields.config;\n        this.configFactories = fields.configFactories;\n    }\n    getName(suffix) {\n        return this.bound.getName(suffix);\n    }\n    async _mergeConfig(...options) {\n        const config = mergeConfigs(this.config, ...options);\n        return mergeConfigs(config, ...(this.configFactories\n            ? await Promise.all(this.configFactories.map(async (configFactory) => await configFactory(config)))\n            : []));\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableBinding` class that is bound with the specified arguments.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n            config: this.config,\n        });\n    }\n    withConfig(config) {\n        return new this.constructor({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: { ...this.config, ...config },\n        });\n    }\n    withRetry(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableRetry({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            maxAttemptNumber: fields?.stopAfterAttempt,\n            ...fields,\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? await Promise.all(options.map(async (individualOption) => this._mergeConfig(ensureConfig(individualOption), this.kwargs)))\n            : await this._mergeConfig(ensureConfig(options), this.kwargs);\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        return this.bound._concatOutputChunks(first, second);\n    }\n    async *_streamIterator(input, options) {\n        yield* this.bound._streamIterator(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    async *transform(generator, options) {\n        yield* this.bound.transform(generator, await this._mergeConfig(ensureConfig(options), this.kwargs));\n    }\n    streamEvents(input, options, streamOptions) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const outerThis = this;\n        const generator = async function* () {\n            yield* outerThis.bound.streamEvents(input, {\n                ...(await outerThis._mergeConfig(ensureConfig(options), outerThis.kwargs)),\n                version: options.version,\n            }, streamOptions);\n        };\n        return IterableReadableStream.fromAsyncGenerator(generator());\n    }\n    static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        return thing.bound && Runnable.isRunnable(thing.bound);\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: this.kwargs,\n            config: this.config,\n            configFactories: [\n                (config) => ({\n                    callbacks: [\n                        new RootListenersTracer({\n                            config,\n                            onStart,\n                            onEnd,\n                            onError,\n                        }),\n                    ],\n                }),\n            ],\n        });\n    }\n}\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n * @example\n * ```typescript\n * import { RunnableEach, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const toUpperCase = (input: string): string => input.toUpperCase();\n * const addGreeting = (input: string): string => `Hello, ${input}!`;\n *\n * const upperCaseLambda = RunnableLambda.from(toUpperCase);\n * const greetingLambda = RunnableLambda.from(addGreeting);\n *\n * const chain = new RunnableEach({\n *   bound: upperCaseLambda.pipe(greetingLambda),\n * });\n *\n * const result = await chain.invoke([\"alice\", \"bob\", \"carol\"])\n *\n * // [\"Hello, ALICE!\", \"Hello, BOB!\", \"Hello, CAROL!\"]\n * ```\n *\n * @deprecated This will be removed in the next breaking release.\n */\nexport class RunnableEach extends Runnable {\n    static lc_name() {\n        return \"RunnableEach\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n    }\n    /**\n     * Binds the runnable with the specified arguments.\n     * @param kwargs The arguments to bind the runnable with.\n     * @returns A new instance of the `RunnableEach` class that is bound with the specified arguments.\n     *\n     * @deprecated Use {@link withConfig} instead. This will be removed in the next breaking release.\n     */\n    bind(kwargs) {\n        return new RunnableEach({\n            bound: this.bound.bind(kwargs),\n        });\n    }\n    /**\n     * Invokes the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(inputs, config) {\n        return this._callWithConfig(this._invoke.bind(this), inputs, config);\n    }\n    /**\n     * A helper method that is used to invoke the runnable with the specified input and configuration.\n     * @param input The input to invoke the runnable with.\n     * @param config The configuration to invoke the runnable with.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async _invoke(inputs, config, runManager) {\n        return this.bound.batch(inputs, patchConfig(config, { callbacks: runManager?.getChild() }));\n    }\n    /**\n     * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n     * The Run object contains information about the run, including its id,\n     * type, input, output, error, startTime, endTime, and any tags or metadata\n     * added to the run.\n     *\n     * @param {Object} params - The object containing the callback functions.\n     * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n     * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n     * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n     */\n    withListeners({ onStart, onEnd, onError, }) {\n        return new RunnableEach({\n            bound: this.bound.withListeners({ onStart, onEnd, onError }),\n        });\n    }\n}\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableRetry,\n * } from \"@langchain/core/runnables\";\n *\n * // Simulate an API call that fails\n * const simulateApiCall = (input: string): string => {\n *   console.log(`Attempting API call with input: ${input}`);\n *   throw new Error(\"API call failed due to network issue\");\n * };\n *\n * const apiCallLambda = RunnableLambda.from(simulateApiCall);\n *\n * // Apply retry logic using the .withRetry() method\n * const apiCallWithRetry = apiCallLambda.withRetry({ stopAfterAttempt: 3 });\n *\n * // Alternatively, create a RunnableRetry instance manually\n * const manualRetry = new RunnableRetry({\n *   bound: apiCallLambda,\n *   maxAttemptNumber: 3,\n *   config: {},\n * });\n *\n * // Example invocation using the .withRetry() method\n * const res = await apiCallWithRetry\n *   .invoke(\"Request 1\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n *\n * // Example invocation using the manual retry instance\n * const res2 = await manualRetry\n *   .invoke(\"Request 2\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n * ```\n */\nexport class RunnableRetry extends RunnableBinding {\n    static lc_name() {\n        return \"RunnableRetry\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"maxAttemptNumber\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 3\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"onFailedAttempt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: () => { }\n        });\n        this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n        this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n    }\n    _patchConfigForRetry(attempt, config, runManager) {\n        const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n        return patchConfig(config, { callbacks: runManager?.getChild(tag) });\n    }\n    async _invoke(input, config, runManager) {\n        return pRetry((attemptNumber) => super.invoke(input, this._patchConfigForRetry(attemptNumber, config, runManager)), {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onFailedAttempt: (error) => this.onFailedAttempt(error, input),\n            retries: Math.max(this.maxAttemptNumber - 1, 0),\n            randomize: true,\n        });\n    }\n    /**\n     * Method that invokes the runnable with the specified input, run manager,\n     * and config. It handles the retry logic by catching any errors and\n     * recursively invoking itself with the updated config for the next retry\n     * attempt.\n     * @param input The input for the runnable.\n     * @param runManager The run manager for the runnable.\n     * @param config The config for the runnable.\n     * @returns A promise that resolves to the output of the runnable.\n     */\n    async invoke(input, config) {\n        return this._callWithConfig(this._invoke.bind(this), input, config);\n    }\n    async _batch(inputs, configs, runManagers, batchOptions) {\n        const resultsMap = {};\n        try {\n            await pRetry(async (attemptNumber) => {\n                const remainingIndexes = inputs\n                    .map((_, i) => i)\n                    .filter((i) => resultsMap[i.toString()] === undefined ||\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    resultsMap[i.toString()] instanceof Error);\n                const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n                const patchedConfigs = remainingIndexes.map((i) => this._patchConfigForRetry(attemptNumber, configs?.[i], runManagers?.[i]));\n                const results = await super.batch(remainingInputs, patchedConfigs, {\n                    ...batchOptions,\n                    returnExceptions: true,\n                });\n                let firstException;\n                for (let i = 0; i < results.length; i += 1) {\n                    const result = results[i];\n                    const resultMapIndex = remainingIndexes[i];\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (result instanceof Error) {\n                        if (firstException === undefined) {\n                            firstException = result;\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            firstException.input = remainingInputs[i];\n                        }\n                    }\n                    resultsMap[resultMapIndex.toString()] = result;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n                return results;\n            }, {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                onFailedAttempt: (error) => this.onFailedAttempt(error, error.input),\n                retries: Math.max(this.maxAttemptNumber - 1, 0),\n                randomize: true,\n            });\n        }\n        catch (e) {\n            if (batchOptions?.returnExceptions !== true) {\n                throw e;\n            }\n        }\n        return Object.keys(resultsMap)\n            .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n            .map((key) => resultsMap[parseInt(key, 10)]);\n    }\n    async batch(inputs, options, batchOptions) {\n        return this._batchWithConfig(this._batch.bind(this), inputs, options, batchOptions);\n    }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({ model: \"gpt-4o-mini\" })]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"omitSequenceTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n        this.name = fields.name;\n        this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            const initialSteps = [this.first, ...this.middle];\n            for (let i = 0; i < initialSteps.length; i += 1) {\n                const step = initialSteps[i];\n                const promise = step.invoke(nextStepInput, patchConfig(config, {\n                    callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`),\n                }));\n                nextStepInput = await raceWithSignal(promise, options?.signal);\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            if (options?.signal?.aborted) {\n                throw new Error(\"Aborted\");\n            }\n            finalOutput = await this.last.invoke(nextStepInput, patchConfig(config, {\n                callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${this.steps.length}`),\n            }));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map(getCallbackManagerForConfig));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        try {\n            for (let i = 0; i < this.steps.length; i += 1) {\n                const step = this.steps[i];\n                const promise = step.batch(nextStepInputs, runManagers.map((runManager, j) => {\n                    const childRunManager = runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`);\n                    return patchConfig(configList[j], { callbacks: childRunManager });\n                }), batchOptions);\n                nextStepInputs = await raceWithSignal(promise, configList[0]?.signal);\n            }\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))));\n        return nextStepInputs;\n    }\n    /** @internal */\n    _concatOutputChunks(first, second) {\n        return this.last._concatOutputChunks(first, second);\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await getCallbackManagerForConfig(options);\n        const { runId, ...otherOptions } = options ?? {};\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherOptions?.runName);\n        const steps = [this.first, ...this.middle, this.last];\n        let concatSupported = true;\n        let finalOutput;\n        async function* inputGenerator() {\n            yield input;\n        }\n        try {\n            let finalGenerator = steps[0].transform(inputGenerator(), patchConfig(otherOptions, {\n                callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:1`),\n            }));\n            for (let i = 1; i < steps.length; i += 1) {\n                const step = steps[i];\n                finalGenerator = await step.transform(finalGenerator, patchConfig(otherOptions, {\n                    callbacks: runManager?.getChild(this.omitSequenceTags ? undefined : `seq:step:${i + 1}`),\n                }));\n            }\n            for await (const chunk of finalGenerator) {\n                options?.signal?.throwIfAborted();\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = this._concatOutputChunks(finalOutput, chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    getGraph(config) {\n        const graph = new Graph();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let currentLastNode = null;\n        this.steps.forEach((step, index) => {\n            const stepGraph = step.getGraph(config);\n            if (index !== 0) {\n                stepGraph.trimFirstNode();\n            }\n            if (index !== this.steps.length - 1) {\n                stepGraph.trimLastNode();\n            }\n            graph.extend(stepGraph);\n            const stepFirstNode = stepGraph.firstNode();\n            if (!stepFirstNode) {\n                throw new Error(`Runnable ${step} has no first node`);\n            }\n            if (currentLastNode) {\n                graph.addEdge(currentLastNode, stepFirstNode);\n            }\n            currentLastNode = stepGraph.lastNode();\n        });\n        return graph;\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n                name: this.name ?? coerceable.name,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n                name: this.name,\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from([first, ...runnables], nameOrFields) {\n        let extra = {};\n        if (typeof nameOrFields === \"string\") {\n            extra.name = nameOrFields;\n        }\n        else if (nameOrFields !== undefined) {\n            extra = nameOrFields;\n        }\n        return new RunnableSequence({\n            ...extra,\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n        });\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    getStepsKeys() {\n        return Object.keys(this.steps);\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    static from(steps) {\n        return new RunnableMap({ steps });\n    }\n    async invoke(input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        }, config.runId, undefined, undefined, undefined, config?.runName);\n        delete config.runId;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            const promises = Object.entries(this.steps).map(async ([key, runnable]) => {\n                output[key] = await runnable.invoke(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(`map:key:${key}`),\n                }));\n            });\n            await raceWithSignal(Promise.all(promises), options?.signal);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n    async *_transform(generator, runManager, options) {\n        // shallow copy steps to ignore changes while iterating\n        const steps = { ...this.steps };\n        // each step gets a copy of the input iterator\n        const inputCopies = atee(generator, Object.keys(steps).length);\n        // start the first iteration of each output iterator\n        const tasks = new Map(Object.entries(steps).map(([key, runnable], i) => {\n            const gen = runnable.transform(inputCopies[i], patchConfig(options, {\n                callbacks: runManager?.getChild(`map:key:${key}`),\n            }));\n            return [key, gen.next().then((result) => ({ key, gen, result }))];\n        }));\n        // yield chunks as they become available,\n        // starting new iterations as needed,\n        // until all iterators are done\n        while (tasks.size) {\n            const promise = Promise.race(tasks.values());\n            const { key, result, gen } = await raceWithSignal(promise, options?.signal);\n            tasks.delete(key);\n            if (!result.done) {\n                yield { [key]: result.value };\n                tasks.set(key, gen.next().then((result) => ({ key, gen, result })));\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nexport class RunnableTraceable extends Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (!isTraceableFunction(fields.func)) {\n            throw new Error(\"RunnableTraceable requires a function that is wrapped in traceable higher-order function\");\n        }\n        this.func = fields.func;\n    }\n    async invoke(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const callbacks = await getCallbackManagerForConfig(config);\n        const promise = this.func(patchConfig(config, { callbacks }), input);\n        return raceWithSignal(promise, config?.signal);\n    }\n    async *_streamIterator(input, options) {\n        const [config] = this._getOptionsList(options ?? {}, 1);\n        const result = await this.invoke(input, options);\n        if (isAsyncIterable(result)) {\n            for await (const item of result) {\n                config?.signal?.throwIfAborted();\n                yield item;\n            }\n            return;\n        }\n        if (isIterator(result)) {\n            while (true) {\n                config?.signal?.throwIfAborted();\n                const state = result.next();\n                if (state.done)\n                    break;\n                yield state.value;\n            }\n            return;\n        }\n        yield result;\n    }\n    static from(func) {\n        return new RunnableTraceable({ func });\n    }\n}\nfunction assertNonTraceableFunction(func) {\n    if (isTraceableFunction(func)) {\n        throw new Error(\"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\");\n    }\n}\n/**\n * A runnable that wraps an arbitrary function that takes a single argument.\n * @example\n * ```typescript\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const add = (input: { x: number; y: number }) => input.x + input.y;\n *\n * const multiply = (input: { value: number; multiplier: number }) =>\n *   input.value * input.multiplier;\n *\n * // Create runnables for the functions\n * const addLambda = RunnableLambda.from(add);\n * const multiplyLambda = RunnableLambda.from(multiply);\n *\n * // Chain the lambdas for a mathematical operation\n * const chainedLambda = addLambda.pipe((result) =>\n *   multiplyLambda.invoke({ value: result, multiplier: 2 })\n * );\n *\n * // Example invocation of the chainedLambda\n * const result = await chainedLambda.invoke({ x: 2, y: 3 });\n *\n * // Will log \"10\" (since (2 + 3) * 2 = 10)\n * ```\n */\nexport class RunnableLambda extends Runnable {\n    static lc_name() {\n        return \"RunnableLambda\";\n    }\n    constructor(fields) {\n        if (isTraceableFunction(fields.func)) {\n            // eslint-disable-next-line no-constructor-return\n            return RunnableTraceable.from(fields.func);\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        assertNonTraceableFunction(fields.func);\n        this.func = fields.func;\n    }\n    static from(func) {\n        return new RunnableLambda({\n            func,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        return new Promise((resolve, reject) => {\n            const childConfig = patchConfig(config, {\n                callbacks: runManager?.getChild(),\n                recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n            });\n            void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n                try {\n                    let output = await this.func(input, {\n                        ...childConfig,\n                    });\n                    if (output && Runnable.isRunnable(output)) {\n                        if (config?.recursionLimit === 0) {\n                            throw new Error(\"Recursion limit reached.\");\n                        }\n                        output = await output.invoke(input, {\n                            ...childConfig,\n                            recursionLimit: (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n                        });\n                    }\n                    else if (isAsyncIterable(output)) {\n                        let finalOutput;\n                        for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    finalOutput = this._concatOutputChunks(finalOutput, \n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    else if (isIterableIterator(output)) {\n                        let finalOutput;\n                        for (const chunk of consumeIteratorInContext(childConfig, output)) {\n                            config?.signal?.throwIfAborted();\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                // Make a best effort to gather, for any type that supports concat.\n                                try {\n                                    finalOutput = this._concatOutputChunks(finalOutput, \n                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                                    chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = chunk;\n                                }\n                            }\n                        }\n                        output = finalOutput;\n                    }\n                    resolve(output);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._invoke.bind(this), input, options);\n    }\n    async *_transform(generator, runManager, config) {\n        let finalChunk;\n        for await (const chunk of generator) {\n            if (finalChunk === undefined) {\n                finalChunk = chunk;\n            }\n            else {\n                // Make a best effort to gather, for any type that supports concat.\n                try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    finalChunk = this._concatOutputChunks(finalChunk, chunk);\n                }\n                catch (e) {\n                    finalChunk = chunk;\n                }\n            }\n        }\n        const childConfig = patchConfig(config, {\n            callbacks: runManager?.getChild(),\n            recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n        });\n        const output = await new Promise((resolve, reject) => {\n            void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n                try {\n                    const res = await this.func(finalChunk, {\n                        ...childConfig,\n                        config: childConfig,\n                    });\n                    resolve(res);\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        });\n        if (output && Runnable.isRunnable(output)) {\n            if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n            }\n            const stream = await output.stream(finalChunk, childConfig);\n            for await (const chunk of stream) {\n                yield chunk;\n            }\n        }\n        else if (isAsyncIterable(output)) {\n            for await (const chunk of consumeAsyncIterableInContext(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else if (isIterableIterator(output)) {\n            for (const chunk of consumeIteratorInContext(childConfig, output)) {\n                config?.signal?.throwIfAborted();\n                yield chunk;\n            }\n        }\n        else {\n            yield output;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const addYears = (age: number): number => age + 5;\n * const yearsToFifty = (age: number): number => 50 - age;\n * const yearsToHundred = (age: number): number => 100 - age;\n *\n * const addYearsLambda = RunnableLambda.from(addYears);\n * const milestoneFiftyLambda = RunnableLambda.from(yearsToFifty);\n * const milestoneHundredLambda = RunnableLambda.from(yearsToHundred);\n *\n * // Pipe will coerce objects into RunnableParallel by default, but we\n * // explicitly instantiate one here to demonstrate\n * const sequence = addYearsLambda.pipe(\n *   RunnableParallel.from({\n *     years_to_fifty: milestoneFiftyLambda,\n *     years_to_hundred: milestoneHundredLambda,\n *   })\n * );\n *\n * // Invoke the sequence with a single age input\n * const res = await sequence.invoke(25);\n *\n * // { years_to_fifty: 20, years_to_hundred: 70 }\n * ```\n */\nexport class RunnableParallel extends RunnableMap {\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n * External APIs (e.g., APIs for a language model) may at times experience\n * degraded performance or even downtime.\n *\n * In these cases, it can be useful to have a fallback Runnable that can be\n * used in place of the original Runnable (e.g., fallback to another LLM provider).\n *\n * Fallbacks can be defined at the level of a single Runnable, or at the level\n * of a chain of Runnables. Fallbacks are tried in order until one succeeds or\n * all fail.\n *\n * While you can instantiate a `RunnableWithFallbacks` directly, it is usually\n * more convenient to use the `withFallbacks` method on an existing Runnable.\n *\n * When streaming, fallbacks will only be called on failures during the initial\n * stream creation. Errors that occur after a stream starts will not fallback\n * to the next Runnable.\n *\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableWithFallbacks,\n * } from \"@langchain/core/runnables\";\n *\n * const primaryOperation = (input: string): string => {\n *   if (input !== \"safe\") {\n *     throw new Error(\"Primary operation failed due to unsafe input\");\n *   }\n *   return `Processed: ${input}`;\n * };\n *\n * // Define a fallback operation that processes the input differently\n * const fallbackOperation = (input: string): string =>\n *   `Fallback processed: ${input}`;\n *\n * const primaryRunnable = RunnableLambda.from(primaryOperation);\n * const fallbackRunnable = RunnableLambda.from(fallbackOperation);\n *\n * // Apply the fallback logic using the .withFallbacks() method\n * const runnableWithFallback = primaryRunnable.withFallbacks([fallbackRunnable]);\n *\n * // Alternatively, create a RunnableWithFallbacks instance manually\n * const manualFallbackChain = new RunnableWithFallbacks({\n *   runnable: primaryRunnable,\n *   fallbacks: [fallbackRunnable],\n * });\n *\n * // Example invocation using .withFallbacks()\n * const res = await runnableWithFallback\n *   .invoke(\"unsafe input\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Fallback processed: unsafe input\"\n *\n * // Example invocation using manual instantiation\n * const res = await manualFallbackChain\n *   .invoke(\"safe\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Processed: safe\"\n * ```\n */\nexport class RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        const childConfig = patchConfig(otherConfigFields, {\n            callbacks: runManager?.getChild(),\n        });\n        const res = await AsyncLocalStorageProviderSingleton.runWithConfig(childConfig, async () => {\n            let firstError;\n            for (const runnable of this.runnables()) {\n                config?.signal?.throwIfAborted();\n                try {\n                    const output = await runnable.invoke(input, childConfig);\n                    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                    return output;\n                }\n                catch (e) {\n                    if (firstError === undefined) {\n                        firstError = e;\n                    }\n                }\n            }\n            if (firstError === undefined) {\n                throw new Error(\"No error stored at end of fallback.\");\n            }\n            await runManager?.handleChainError(firstError);\n            throw firstError;\n        });\n        return res;\n    }\n    async *_streamIterator(input, options) {\n        const config = ensureConfig(options);\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const { runId, ...otherConfigFields } = config;\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), runId, undefined, undefined, undefined, otherConfigFields?.runName);\n        let firstError;\n        let stream;\n        for (const runnable of this.runnables()) {\n            config?.signal?.throwIfAborted();\n            const childConfig = patchConfig(otherConfigFields, {\n                callbacks: runManager?.getChild(),\n            });\n            try {\n                const originalStream = await runnable.stream(input, childConfig);\n                stream = consumeAsyncIterableInContext(childConfig, originalStream);\n                break;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (stream === undefined) {\n            const error = firstError ?? new Error(\"No error stored at end of fallback.\");\n            await runManager?.handleChainError(error);\n            throw error;\n        }\n        let output;\n        try {\n            for await (const chunk of stream) {\n                yield chunk;\n                try {\n                    output =\n                        output === undefined\n                            ? output\n                            : this._concatOutputChunks(output, chunk);\n                }\n                catch (e) {\n                    output = undefined;\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    }\n    async batch(inputs, options, batchOptions) {\n        if (batchOptions?.returnExceptions) {\n            throw new Error(\"Not implemented.\");\n        }\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => getCallbackManagerForConfig(config)));\n        const runManagers = await Promise.all(callbackManagers.map(async (callbackManager, i) => {\n            const handleStartRes = await callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"), configList[i].runId, undefined, undefined, undefined, configList[i].runName);\n            delete configList[i].runId;\n            return handleStartRes;\n        }));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            configList[0].signal?.throwIfAborted();\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => patchConfig(configList[j], {\n                    callbacks: runManager?.getChild(),\n                })), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({\n            steps: runnables,\n        });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * @example\n * ```typescript\n * import {\n *   RunnableAssign,\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const calculateAge = (x: { birthYear: number }): { age: number } => {\n *   const currentYear = new Date().getFullYear();\n *   return { age: currentYear - x.birthYear };\n * };\n *\n * const createGreeting = (x: { name: string }): { greeting: string } => {\n *   return { greeting: `Hello, ${x.name}!` };\n * };\n *\n * const mapper = RunnableParallel.from({\n *   age_step: RunnableLambda.from(calculateAge),\n *   greeting_step: RunnableLambda.from(createGreeting),\n * });\n *\n * const runnableAssign = new RunnableAssign({ mapper });\n *\n * const res = await runnableAssign.invoke({ name: \"Alice\", birthYear: 1990 });\n *\n * // { name: \"Alice\", birthYear: 1990, age_step: { age: 34 }, greeting_step: { greeting: \"Hello, Alice!\" } }\n * ```\n */\nexport class RunnableAssign extends Runnable {\n    static lc_name() {\n        return \"RunnableAssign\";\n    }\n    constructor(fields) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (fields instanceof RunnableMap) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { mapper: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"mapper\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.mapper = fields.mapper;\n    }\n    async invoke(input, options) {\n        const mapperResult = await this.mapper.invoke(input, options);\n        return {\n            ...input,\n            ...mapperResult,\n        };\n    }\n    async *_transform(generator, runManager, options) {\n        // collect mapper keys\n        const mapperKeys = this.mapper.getStepsKeys();\n        // create two input gens, one for the mapper, one for the input\n        const [forPassthrough, forMapper] = atee(generator);\n        // create mapper output gen\n        const mapperOutput = this.mapper.transform(forMapper, patchConfig(options, { callbacks: runManager?.getChild() }));\n        // start the mapper\n        const firstMapperChunkPromise = mapperOutput.next();\n        // yield the passthrough\n        for await (const chunk of forPassthrough) {\n            if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n                throw new Error(`RunnableAssign can only be used with objects as input, got ${typeof chunk}`);\n            }\n            const filtered = Object.fromEntries(Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key)));\n            if (Object.keys(filtered).length > 0) {\n                yield filtered;\n            }\n        }\n        // yield the mapper output\n        yield (await firstMapperChunkPromise).value;\n        for await (const chunk of mapperOutput) {\n            yield chunk;\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * Useful for streaming, can be automatically created and chained by calling `runnable.pick();`.\n * @example\n * ```typescript\n * import { RunnablePick } from \"@langchain/core/runnables\";\n *\n * const inputData = {\n *   name: \"John\",\n *   age: 30,\n *   city: \"New York\",\n *   country: \"USA\",\n *   email: \"john.doe@example.com\",\n *   phone: \"+1234567890\",\n * };\n *\n * const basicInfoRunnable = new RunnablePick([\"name\", \"city\"]);\n *\n * // Example invocation\n * const res = await basicInfoRunnable.invoke(inputData);\n *\n * // { name: 'John', city: 'New York' }\n * ```\n */\nexport class RunnablePick extends Runnable {\n    static lc_name() {\n        return \"RunnablePick\";\n    }\n    constructor(fields) {\n        if (typeof fields === \"string\" || Array.isArray(fields)) {\n            // eslint-disable-next-line no-param-reassign\n            fields = { keys: fields };\n        }\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"keys\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keys = fields.keys;\n    }\n    async _pick(input) {\n        if (typeof this.keys === \"string\") {\n            return input[this.keys];\n        }\n        else {\n            const picked = this.keys\n                .map((key) => [key, input[key]])\n                .filter((v) => v[1] !== undefined);\n            return picked.length === 0\n                ? undefined\n                : Object.fromEntries(picked);\n        }\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(this._pick.bind(this), input, options);\n    }\n    async *_transform(generator) {\n        for await (const chunk of generator) {\n            const picked = await this._pick(chunk);\n            if (picked !== undefined) {\n                yield picked;\n            }\n        }\n    }\n    transform(generator, options) {\n        return this._transformStreamWithConfig(generator, this._transform.bind(this), options);\n    }\n    async stream(input, options) {\n        async function* generator() {\n            yield input;\n        }\n        const config = ensureConfig(options);\n        const wrappedGenerator = new AsyncGeneratorWithSetup({\n            generator: this.transform(generator(), config),\n            config,\n        });\n        await wrappedGenerator.setup;\n        return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n    }\n}\nexport class RunnableToolLike extends RunnableBinding {\n    constructor(fields) {\n        const sequence = RunnableSequence.from([\n            RunnableLambda.from(async (input) => {\n                let toolInput;\n                if (_isToolCall(input)) {\n                    try {\n                        toolInput = await interopParseAsync(this.schema, input.args);\n                    }\n                    catch (e) {\n                        throw new ToolInputParsingException(`Received tool input did not match expected schema`, JSON.stringify(input.args));\n                    }\n                }\n                else {\n                    toolInput = input;\n                }\n                return toolInput;\n            }).withConfig({ runName: `${fields.name}:parse_input` }),\n            fields.bound,\n        ]).withConfig({ runName: fields.name });\n        super({\n            bound: sequence,\n            config: fields.config ?? {},\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.schema = fields.schema;\n    }\n    static lc_name() {\n        return \"RunnableToolLike\";\n    }\n}\n/**\n * Given a runnable and a Zod schema, convert the runnable to a tool.\n *\n * @template RunInput The input type for the runnable.\n * @template RunOutput The output type for the runnable.\n *\n * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.\n * @param fields\n * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n * @param {InteropZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n * @returns {RunnableToolLike<InteropZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n */\nexport function convertRunnableToTool(runnable, fields) {\n    const name = fields.name ?? runnable.getName();\n    const description = fields.description ?? getSchemaDescription(fields.schema);\n    if (isSimpleStringZodSchema(fields.schema)) {\n        return new RunnableToolLike({\n            name,\n            description,\n            schema: z\n                .object({ input: z.string() })\n                .transform((input) => input.input),\n            bound: runnable,\n        });\n    }\n    return new RunnableToolLike({\n        name,\n        description,\n        schema: fields.schema,\n        bound: runnable,\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}