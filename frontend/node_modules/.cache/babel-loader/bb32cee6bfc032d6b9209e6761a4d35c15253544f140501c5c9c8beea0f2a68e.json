{"ast":null,"code":"/* eslint-disable */\n// @ts-nocheck\nimport { getLangSmithEnvironmentVariable } from \"../../utils/env.js\";\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = {\n  result: \"[Circular]\"\n};\nvar arr = [];\nvar replacerStack = [];\nconst encoder = new TextEncoder();\nfunction defaultOptions() {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  };\n}\nfunction encodeString(str) {\n  return encoder.encode(str);\n}\n// Shared function to handle well-known types\nfunction serializeWellKnownTypes(val) {\n  if (val && typeof val === \"object\" && val !== null) {\n    if (val instanceof Map) {\n      return Object.fromEntries(val);\n    } else if (val instanceof Set) {\n      return Array.from(val);\n    } else if (val instanceof Date) {\n      return val.toISOString();\n    } else if (val instanceof RegExp) {\n      return val.toString();\n    } else if (val instanceof Error) {\n      return {\n        name: val.name,\n        message: val.message\n      };\n    }\n  } else if (typeof val === \"bigint\") {\n    return val.toString();\n  }\n  return val;\n}\n// Default replacer function to handle well-known types\nfunction createDefaultReplacer(userReplacer) {\n  return function (key, val) {\n    // Apply user replacer first if provided\n    if (userReplacer) {\n      const userResult = userReplacer.call(this, key, val);\n      // If user replacer returned undefined, fall back to our serialization\n      if (userResult !== undefined) {\n        return userResult;\n      }\n    }\n    // Fall back to our well-known type handling\n    return serializeWellKnownTypes(val);\n  };\n}\n// Regular stringify\nexport function serialize(obj, errorContext, replacer, spacer, options) {\n  try {\n    const str = JSON.stringify(obj, createDefaultReplacer(replacer), spacer);\n    return encodeString(str);\n  } catch (e) {\n    // Fall back to more complex stringify if circular reference\n    if (!e.message?.includes(\"Converting circular structure to JSON\")) {\n      console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n      return encodeString(\"[Unserializable]\");\n    }\n    getLangSmithEnvironmentVariable(\"SUPPRESS_CIRCULAR_JSON_WARNINGS\") !== \"true\" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n    if (typeof options === \"undefined\") {\n      options = defaultOptions();\n    }\n    decirc(obj, \"\", 0, [], undefined, 0, options);\n    let res;\n    try {\n      if (replacerStack.length === 0) {\n        res = JSON.stringify(obj, replacer, spacer);\n      } else {\n        res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n      }\n    } catch (_) {\n      return encodeString(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally {\n      while (arr.length !== 0) {\n        const part = arr.pop();\n        if (part.length === 4) {\n          Object.defineProperty(part[0], part[1], part[3]);\n        } else {\n          part[0][part[1]] = part[2];\n        }\n      }\n    }\n    return encodeString(res);\n  }\n}\nfunction setReplace(replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, {\n        value: replace\n      });\n      arr.push([parent, k, val, propertyDescriptor]);\n    } else {\n      replacerStack.push([val, k, replace]);\n    }\n  } else {\n    parent[k] = replace;\n    arr.push([parent, k, val]);\n  }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (typeof val === \"object\" && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n    if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      // Handle well-known types before Object.keys iteration\n      val = serializeWellKnownTypes(val);\n      var keys = Object.keys(val);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        decirc(val[key], key, i, stack, val, depth, options);\n      }\n    }\n    stack.pop();\n  }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n  if (typeof options === \"undefined\") {\n    options = defaultOptions();\n  }\n  var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer);\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (typeof val === \"object\" && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n    try {\n      if (typeof val.toJSON === \"function\") {\n        return;\n      }\n    } catch (_) {\n      return;\n    }\n    if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      // Handle well-known types before Object.keys iteration\n      val = serializeWellKnownTypes(val);\n      // Create a temporary object in the required way\n      var tmp = {};\n      var keys = Object.keys(val).sort(compareFunction);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        deterministicDecirc(val[key], key, i, stack, val, depth, options);\n        tmp[key] = val[key];\n      }\n      if (typeof parent !== \"undefined\") {\n        arr.push([parent, k, val]);\n        parent[k] = tmp;\n      } else {\n        return tmp;\n      }\n    }\n    stack.pop();\n  }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n  replacer = typeof replacer !== \"undefined\" ? replacer : function (k, v) {\n    return v;\n  };\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i];\n        if (part[1] === key && part[0] === val) {\n          val = part[2];\n          replacerStack.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return replacer.call(this, key, val);\n  };\n}","map":{"version":3,"names":["getLangSmithEnvironmentVariable","LIMIT_REPLACE_NODE","CIRCULAR_REPLACE_NODE","result","arr","replacerStack","encoder","TextEncoder","defaultOptions","depthLimit","Number","MAX_SAFE_INTEGER","edgesLimit","encodeString","str","encode","serializeWellKnownTypes","val","Map","Object","fromEntries","Set","Array","from","Date","toISOString","RegExp","toString","Error","name","message","createDefaultReplacer","userReplacer","key","userResult","call","undefined","serialize","obj","errorContext","replacer","spacer","options","JSON","stringify","e","includes","console","warn","decirc","res","length","replaceGetterValues","_","part","pop","defineProperty","setReplace","replace","k","parent","propertyDescriptor","getOwnPropertyDescriptor","get","configurable","value","push","edgeIndex","stack","depth","i","isArray","keys","compareFunction","a","b","deterministicStringify","tmp","deterministicDecirc","toJSON","sort","v","splice"],"sources":["/Users/chetan/Desktop/summarize_agent/frontend/node_modules/@langchain/core/node_modules/langsmith/dist/utils/fast-safe-stringify/index.js"],"sourcesContent":["/* eslint-disable */\n// @ts-nocheck\nimport { getLangSmithEnvironmentVariable } from \"../../utils/env.js\";\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = { result: \"[Circular]\" };\nvar arr = [];\nvar replacerStack = [];\nconst encoder = new TextEncoder();\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER,\n    };\n}\nfunction encodeString(str) {\n    return encoder.encode(str);\n}\n// Shared function to handle well-known types\nfunction serializeWellKnownTypes(val) {\n    if (val && typeof val === \"object\" && val !== null) {\n        if (val instanceof Map) {\n            return Object.fromEntries(val);\n        }\n        else if (val instanceof Set) {\n            return Array.from(val);\n        }\n        else if (val instanceof Date) {\n            return val.toISOString();\n        }\n        else if (val instanceof RegExp) {\n            return val.toString();\n        }\n        else if (val instanceof Error) {\n            return {\n                name: val.name,\n                message: val.message,\n            };\n        }\n    }\n    else if (typeof val === \"bigint\") {\n        return val.toString();\n    }\n    return val;\n}\n// Default replacer function to handle well-known types\nfunction createDefaultReplacer(userReplacer) {\n    return function (key, val) {\n        // Apply user replacer first if provided\n        if (userReplacer) {\n            const userResult = userReplacer.call(this, key, val);\n            // If user replacer returned undefined, fall back to our serialization\n            if (userResult !== undefined) {\n                return userResult;\n            }\n        }\n        // Fall back to our well-known type handling\n        return serializeWellKnownTypes(val);\n    };\n}\n// Regular stringify\nexport function serialize(obj, errorContext, replacer, spacer, options) {\n    try {\n        const str = JSON.stringify(obj, createDefaultReplacer(replacer), spacer);\n        return encodeString(str);\n    }\n    catch (e) {\n        // Fall back to more complex stringify if circular reference\n        if (!e.message?.includes(\"Converting circular structure to JSON\")) {\n            console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n            return encodeString(\"[Unserializable]\");\n        }\n        getLangSmithEnvironmentVariable(\"SUPPRESS_CIRCULAR_JSON_WARNINGS\") !==\n            \"true\" &&\n            console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n        if (typeof options === \"undefined\") {\n            options = defaultOptions();\n        }\n        decirc(obj, \"\", 0, [], undefined, 0, options);\n        let res;\n        try {\n            if (replacerStack.length === 0) {\n                res = JSON.stringify(obj, replacer, spacer);\n            }\n            else {\n                res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n            }\n        }\n        catch (_) {\n            return encodeString(\"[unable to serialize, circular reference is too complex to analyze]\");\n        }\n        finally {\n            while (arr.length !== 0) {\n                const part = arr.pop();\n                if (part.length === 4) {\n                    Object.defineProperty(part[0], part[1], part[3]);\n                }\n                else {\n                    part[0][part[1]] = part[2];\n                }\n            }\n        }\n        return encodeString(res);\n    }\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, { value: replace });\n            arr.push([parent, k, val, propertyDescriptor]);\n        }\n        else {\n            replacerStack.push([val, k, replace]);\n        }\n    }\n    else {\n        parent[k] = replace;\n        arr.push([parent, k, val]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            var keys = Object.keys(val);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        }\n        else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    }\n    catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    }\n    finally {\n        // Ensure that we restore the object as it was.\n        while (arr.length !== 0) {\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            }\n            else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        }\n        catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([parent, k, val]);\n                parent[k] = tmp;\n            }\n            else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer =\n        typeof replacer !== \"undefined\"\n            ? replacer\n            : function (k, v) {\n                return v;\n            };\n    return function (key, val) {\n        if (replacerStack.length > 0) {\n            for (var i = 0; i < replacerStack.length; i++) {\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}